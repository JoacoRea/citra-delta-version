// shader: 8DD9, 6F6B8D04DE5400F0

layout(triangles) in;
layout(triangle_strip, max_vertices=3) out;

layout(location=1) out vec4 primary_color;
layout(location=2) out vec2 texcoord0;
layout(location=3) out vec2 texcoord1;
layout(location=4) out vec2 texcoord2;
layout(location=5) out float texcoord0_w;
layout(location=6) out vec4 normquat;
layout(location=7) out vec3 view;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

layout(location=0) in vec4 vs_out_attr0[];
layout(location=1) in vec4 vs_out_attr1[];
struct Vertex {
    vec4 attributes[2];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(0.0, 0.0, 0.0, 0.0);
    primary_color = clamp(vtx_color, vec4(0), vec4(1));

    texcoord0 = vec2(vtx.attributes[1].x, vtx.attributes[1].y);
    texcoord1 = vec2(0.0, 0.0);

    texcoord0_w = 0.0;
    view = vec3(0.0, 0.0, 0.0);
    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[2](vs_out_attr0[0], vs_out_attr1[0]);
    prim_buffer[1].attributes = vec4[2](vs_out_attr0[1], vs_out_attr1[1]);
    prim_buffer[2].attributes = vec4[2](vs_out_attr0[2], vs_out_attr1[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: E0A3E62E72D05152, 6F6B8D04DE5400F0
// shader: 8B31, 42F5A78E196F5B15

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_1();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
reg_tmp14.xy = (vs_in_reg0).xy;
reg_tmp14.zw = (uniforms.f[95].xyxy).zw;
reg_tmp15.x = dot_s(uniforms.f[4], reg_tmp14);
reg_tmp15.y = dot_s(uniforms.f[5], reg_tmp14);
reg_tmp15.z = (uniforms.f[6].wwww).z;
reg_tmp15.w = (uniforms.f[95].yyyy).w;
reg_tmp14.x = (uniforms.f[7].xxxx).x;
reg_tmp14.z = (uniforms.f[6].wwww).z;
bool_regs = notEqual(uniforms.f[95].xx, reg_tmp14.xz);
if (all(bool_regs)) {
sub_1();
}
vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp15);
vs_out_attr1 = vs_in_reg1.xyxy;
return true;
}
bool sub_1() {
reg_tmp14.x = (uniforms.f[7].xxxx).x;
reg_tmp14.z = (uniforms.f[7].zzzz + reg_tmp14.zzzz).z;
reg_tmp14.y = (-uniforms.f[7].yyyy + reg_tmp14.zzzz).y;
reg_tmp14.z = rcp_s(reg_tmp14.z);
reg_tmp14.z = (mul_s(reg_tmp14.yyyy, reg_tmp14.zzzz)).z;
reg_tmp15.x = (fma_s(reg_tmp14.xxxx, reg_tmp14.zzzz, reg_tmp15.xxxx)).x;
return false;
}
// reference: 5CAE34861756B918, 42F5A78E196F5B15
// shader: 8B30, BE0EFAD295AC1477
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C56D949613355603, BE0EFAD295AC1477
// program: 42F5A78E196F5B15, 6F6B8D04DE5400F0, BE0EFAD295AC1477
// reference: C4AFFEA113355603, BE0EFAD295AC1477
// shader: 8B30, FC473B8639326E4D
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AA1B6833E563F102, FC473B8639326E4D
// program: 42F5A78E196F5B15, 6F6B8D04DE5400F0, FC473B8639326E4D
// shader: 8DD9, C8DF8CC87A4E8CE6

layout(triangles) in;
layout(triangle_strip, max_vertices=3) out;

layout(location=1) out vec4 primary_color;
layout(location=2) out vec2 texcoord0;
layout(location=3) out vec2 texcoord1;
layout(location=4) out vec2 texcoord2;
layout(location=5) out float texcoord0_w;
layout(location=6) out vec4 normquat;
layout(location=7) out vec3 view;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

layout(location=0) in vec4 vs_out_attr0[];
layout(location=1) in vec4 vs_out_attr1[];
layout(location=2) in vec4 vs_out_attr2[];
layout(location=3) in vec4 vs_out_attr3[];
layout(location=4) in vec4 vs_out_attr4[];
struct Vertex {
    vec4 attributes[5];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = clamp(vtx_color, vec4(0), vec4(1));

    texcoord0 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);
    texcoord1 = vec2(0.0, 0.0);

    texcoord0_w = vtx.attributes[4].z;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);
    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[5](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0]);
    prim_buffer[1].attributes = vec4[5](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1]);
    prim_buffer[2].attributes = vec4[5](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: CD8210802464D9AE, C8DF8CC87A4E8CE6
// shader: 8B31, 9E00A12FA5BE63C7

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=7) in vec4 vs_in_reg7;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_1();
bool sub_2();
bool sub_3();
bool sub_4();
bool sub_6();
bool sub_7();
bool sub_17();
bool sub_5();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_28();
bool sub_27();
bool sub_29();
bool sub_0();

bool exec_shader() {
sub_0();
return true;
}

bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_2();
} else {
sub_3();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_4();
} else {
sub_6();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_2() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_3() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_4() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_5();
return false;
}
bool sub_6() {
if (all(bool_regs)) {
sub_7();
} else {
sub_17();
}
return false;
}
bool sub_7() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_8();
return false;
}
bool sub_17() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_5() {
uint jmp_to = 73u;
while (true) {
switch (jmp_to) {
case 73u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 89u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 89u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 89u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_8() {
uint jmp_to = 90u;
while (true) {
switch (jmp_to) {
case 90u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 165u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 127u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 165u; break;
}
case 127u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_9();
} else {
sub_14();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 165u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_9() {
if (bool_regs.y) {
sub_10();
} else {
sub_11();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_10() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_11() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_12();
} else {
sub_13();
}
return false;
}
bool sub_12() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_14() {
if (bool_regs.y) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_18() {
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9 = uniforms.f[21];
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (bool_regs.y) {
sub_19();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_19() {
if (uniforms.b[7]) {
sub_20();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_20() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_21() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_22();
} else {
sub_23();
}
return false;
}
bool sub_22() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_23() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_24();
} else {
sub_25();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_24() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_25() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_26();
} else {
sub_28();
}
return false;
}
bool sub_26() {
sub_27();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_28() {
sub_29();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_27() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_29() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_0() {
sub_1();
sub_18();
sub_21();
return true;
}
// reference: E89BB720253AE361, 9E00A12FA5BE63C7
// shader: 8B30, FF052BD1AB26E7D1
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(normal, normalize(half_vector)))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(normal, normalize(half_vector)))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor0.aaa), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0EFF921449577191, FF052BD1AB26E7D1
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, FF052BD1AB26E7D1
// reference: 407699BD0E44876A, FF052BD1AB26E7D1
// shader: 8B30, FA7E40A8EEC8551A
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTSigned(0, dot(normal, normalize(half_vector)))) * light_src[0].specular_0) * geo_factor) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTSigned(0, dot(normal, normalize(half_vector)))) * light_src[1].specular_0) * geo_factor) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 456823025F0B789D, FA7E40A8EEC8551A
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, FA7E40A8EEC8551A
// shader: 8DD9, EADA2116091C5E01

layout(triangles) in;
layout(triangle_strip, max_vertices=3) out;

layout(location=1) out vec4 primary_color;
layout(location=2) out vec2 texcoord0;
layout(location=3) out vec2 texcoord1;
layout(location=4) out vec2 texcoord2;
layout(location=5) out float texcoord0_w;
layout(location=6) out vec4 normquat;
layout(location=7) out vec3 view;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

layout(location=0) in vec4 vs_out_attr0[];
layout(location=1) in vec4 vs_out_attr1[];
layout(location=2) in vec4 vs_out_attr2[];
layout(location=3) in vec4 vs_out_attr3[];
layout(location=4) in vec4 vs_out_attr4[];
layout(location=5) in vec4 vs_out_attr5[];
layout(location=6) in vec4 vs_out_attr6[];
struct Vertex {
    vec4 attributes[7];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = clamp(vtx_color, vec4(0), vec4(1));

    texcoord0 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);
    texcoord1 = vec2(vtx.attributes[5].x, vtx.attributes[5].y);

    texcoord0_w = vtx.attributes[4].z;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);
    texcoord2 = vec2(vtx.attributes[6].x, vtx.attributes[6].y);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[7](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0], vs_out_attr5[0], vs_out_attr6[0]);
    prim_buffer[1].attributes = vec4[7](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1], vs_out_attr5[1], vs_out_attr6[1]);
    prim_buffer[2].attributes = vec4[7](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2], vs_out_attr5[2], vs_out_attr6[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: FC74FA4ACA1C8C74, EADA2116091C5E01
// shader: 8B31, 5593DF1E36F9D5E0

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_21();
bool sub_4();
bool sub_9();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_10();
bool sub_20();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_6();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_45();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_44();
bool sub_46();
bool sub_47();
bool sub_48();
bool sub_49();
bool sub_50();
bool sub_51();
bool sub_52();
bool sub_53();
bool sub_54();
bool sub_55();
bool sub_56();
bool sub_57();
bool sub_58();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
sub_30();
sub_33();
sub_47();
sub_54();
return true;
}
bool sub_21() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_9() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_23();
}
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_7();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_7() {
if (all(bool_regs)) {
sub_8();
} else {
sub_20();
}
return false;
}
bool sub_8() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_9();
}
if (uniforms.b[8]) {
sub_10();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_11();
return false;
}
bool sub_10() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_9();
}
return false;
}
bool sub_20() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_21();
}
if (uniforms.b[8]) {
sub_22();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_22() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_21();
}
return false;
}
bool sub_23() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_24();
} else {
sub_25();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_26();
} else {
sub_27();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_24() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_25() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_26() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_27() {
if (all(bool_regs)) {
sub_28();
} else {
sub_29();
}
return false;
}
bool sub_28() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_11();
return false;
}
bool sub_29() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_6() {
uint jmp_to = 202u;
while (true) {
switch (jmp_to) {
case 202u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 218u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 218u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 218u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
uint jmp_to = 219u;
while (true) {
switch (jmp_to) {
case 219u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 294u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 256u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 294u; break;
}
case 256u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_12();
} else {
sub_17();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 294u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_12() {
if (bool_regs.y) {
sub_13();
} else {
sub_14();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_14() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_17() {
if (bool_regs.y) {
sub_18();
} else {
sub_19();
}
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_19() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_30() {
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9 = uniforms.f[21];
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (bool_regs.y) {
sub_31();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_31() {
if (uniforms.b[7]) {
sub_32();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_32() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_33() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_34();
} else {
sub_40();
}
return false;
}
bool sub_34() {
sub_35();
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_40() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_41();
} else {
sub_42();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_41() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_42() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_43();
} else {
sub_45();
}
return false;
}
bool sub_43() {
sub_44();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_45() {
sub_46();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_35() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_36();
} else {
sub_37();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_36() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_37() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_38();
} else {
sub_39();
}
return false;
}
bool sub_38() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_39() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_44() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_46() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_47() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_48();
} else {
sub_49();
}
return false;
}
bool sub_48() {
sub_35();
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_49() {
if (uniforms.b[13]) {
sub_50();
} else {
sub_53();
}
return false;
}
bool sub_50() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_51();
} else {
sub_52();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_51() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_52() {
sub_46();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_53() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_54() {
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
if (uniforms.b[11]) {
sub_55();
} else {
sub_56();
}
return false;
}
bool sub_55() {
sub_35();
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_56() {
if (uniforms.b[14]) {
sub_57();
} else {
sub_58();
}
return false;
}
bool sub_57() {
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.zw = (reg_tmp6.zwww).zw;
sub_46();
reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_58() {
vs_out_attr6 = uniforms.f[93].xxxx;
return false;
}
// reference: 2ACEB9754E962C80, 5593DF1E36F9D5E0
// shader: 8B30, 85F1FB16ACA5F40E
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(light_vector, normal), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(light_vector, normal), 0.0))) * light_src[1].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((secondary_fragment_color.aaa) * (texcolor0.rrr) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((texcolor1.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3C5B652E3BD7BAFD, 85F1FB16ACA5F40E
// program: 5593DF1E36F9D5E0, EADA2116091C5E01, 85F1FB16ACA5F40E
// shader: 8B30, F9387F8B7C2D9EE6
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) * geo_factor) + (((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1) * geo_factor)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) * geo_factor) + (((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[1].specular_1) * geo_factor)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].aaa), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].aaa), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 90628CF097E1B018, F9387F8B7C2D9EE6
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, F9387F8B7C2D9EE6
// shader: 8DD9, F777123A8C3D5E20

layout(triangles) in;
layout(triangle_strip, max_vertices=3) out;

layout(location=1) out vec4 primary_color;
layout(location=2) out vec2 texcoord0;
layout(location=3) out vec2 texcoord1;
layout(location=4) out vec2 texcoord2;
layout(location=5) out float texcoord0_w;
layout(location=6) out vec4 normquat;
layout(location=7) out vec3 view;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

layout(location=0) in vec4 vs_out_attr0[];
layout(location=1) in vec4 vs_out_attr1[];
layout(location=2) in vec4 vs_out_attr2[];
layout(location=3) in vec4 vs_out_attr3[];
layout(location=4) in vec4 vs_out_attr4[];
layout(location=5) in vec4 vs_out_attr5[];
struct Vertex {
    vec4 attributes[6];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = clamp(vtx_color, vec4(0), vec4(1));

    texcoord0 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);
    texcoord1 = vec2(vtx.attributes[5].x, vtx.attributes[5].y);

    texcoord0_w = vtx.attributes[4].z;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);
    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[6](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0], vs_out_attr5[0]);
    prim_buffer[1].attributes = vec4[6](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1], vs_out_attr5[1]);
    prim_buffer[2].attributes = vec4[6](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2], vs_out_attr5[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: 46A0C2E6B155D5CD, F777123A8C3D5E20
// shader: 8B31, 25474969E3E91F82

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_21();
bool sub_4();
bool sub_9();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_10();
bool sub_20();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_6();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_45();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_44();
bool sub_46();
bool sub_47();
bool sub_48();
bool sub_49();
bool sub_50();
bool sub_51();
bool sub_52();
bool sub_53();
bool sub_0();

bool exec_shader() {
sub_0();
return true;
}

bool sub_21() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_9() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_23();
}
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_7();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_7() {
if (all(bool_regs)) {
sub_8();
} else {
sub_20();
}
return false;
}
bool sub_8() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_9();
}
if (uniforms.b[8]) {
sub_10();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_11();
return false;
}
bool sub_10() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_9();
}
return false;
}
bool sub_20() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_21();
}
if (uniforms.b[8]) {
sub_22();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_22() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_21();
}
return false;
}
bool sub_23() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_24();
} else {
sub_25();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_26();
} else {
sub_27();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_24() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_25() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_26() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_27() {
if (all(bool_regs)) {
sub_28();
} else {
sub_29();
}
return false;
}
bool sub_28() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_11();
return false;
}
bool sub_29() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_6() {
uint jmp_to = 202u;
while (true) {
switch (jmp_to) {
case 202u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 218u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 218u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 218u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
uint jmp_to = 219u;
while (true) {
switch (jmp_to) {
case 219u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 294u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 256u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 294u; break;
}
case 256u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_12();
} else {
sub_17();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 294u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_12() {
if (bool_regs.y) {
sub_13();
} else {
sub_14();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_14() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_17() {
if (bool_regs.y) {
sub_18();
} else {
sub_19();
}
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_19() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_30() {
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9 = uniforms.f[21];
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (bool_regs.y) {
sub_31();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_31() {
if (uniforms.b[7]) {
sub_32();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_32() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_33() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_34();
} else {
sub_40();
}
return false;
}
bool sub_34() {
sub_35();
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_40() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_41();
} else {
sub_42();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_41() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_42() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_43();
} else {
sub_45();
}
return false;
}
bool sub_43() {
sub_44();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_45() {
sub_46();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_35() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_36();
} else {
sub_37();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_36() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_37() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_38();
} else {
sub_39();
}
return false;
}
bool sub_38() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_39() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_44() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_46() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_47() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_48();
} else {
sub_49();
}
return false;
}
bool sub_48() {
sub_35();
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_49() {
if (uniforms.b[13]) {
sub_50();
} else {
sub_53();
}
return false;
}
bool sub_50() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_51();
} else {
sub_52();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_51() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_52() {
sub_46();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_53() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_0() {
sub_1();
sub_30();
sub_33();
sub_47();
return true;
}
// reference: 3D364C57543BE47A, 25474969E3E91F82
// shader: 8B30, 60FDEEF3BAE3EBD6
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(light_vector, normal), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(light_vector, normal), 0.0))) * light_src[1].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (secondary_fragment_color.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb) + (last_tex_env_out.rgb) * (vec3(1) - (texcolor1.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2B44C8549AEF6A59, 60FDEEF3BAE3EBD6
// program: 25474969E3E91F82, F777123A8C3D5E20, 60FDEEF3BAE3EBD6
// reference: 65CDC3FD9AEF6A59, 60FDEEF3BAE3EBD6
// shader: 8B31, 64A15DE7F2BB2A3E

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_4();
bool sub_6();
bool sub_7();
bool sub_17();
bool sub_5();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_28();
bool sub_27();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
sub_18();
sub_21();
sub_30();
sub_37();
return true;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_2();
} else {
sub_3();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_4();
} else {
sub_6();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_2() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_3() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_4() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_5();
return false;
}
bool sub_6() {
if (all(bool_regs)) {
sub_7();
} else {
sub_17();
}
return false;
}
bool sub_7() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_8();
return false;
}
bool sub_17() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_5() {
uint jmp_to = 73u;
while (true) {
switch (jmp_to) {
case 73u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 89u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 89u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 89u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_8() {
uint jmp_to = 90u;
while (true) {
switch (jmp_to) {
case 90u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 165u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 127u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 165u; break;
}
case 127u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_9();
} else {
sub_14();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 165u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_9() {
if (bool_regs.y) {
sub_10();
} else {
sub_11();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_10() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_11() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_12();
} else {
sub_13();
}
return false;
}
bool sub_12() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_14() {
if (bool_regs.y) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_18() {
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9 = uniforms.f[21];
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (bool_regs.y) {
sub_19();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_19() {
if (uniforms.b[7]) {
sub_20();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_20() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_21() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_22();
} else {
sub_23();
}
return false;
}
bool sub_22() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_23() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_24();
} else {
sub_25();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_24() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_25() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_26();
} else {
sub_28();
}
return false;
}
bool sub_26() {
sub_27();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_28() {
sub_29();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_27() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_29() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_30() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_31();
} else {
sub_32();
}
return false;
}
bool sub_31() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_32() {
if (uniforms.b[13]) {
sub_33();
} else {
sub_36();
}
return false;
}
bool sub_33() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_34();
} else {
sub_35();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_34() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_35() {
sub_29();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_36() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_37() {
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
if (uniforms.b[11]) {
sub_38();
} else {
sub_39();
}
return false;
}
bool sub_38() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_39() {
if (uniforms.b[14]) {
sub_40();
} else {
sub_41();
}
return false;
}
bool sub_40() {
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.zw = (reg_tmp6.zwww).zw;
sub_29();
reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_41() {
vs_out_attr6 = uniforms.f[93].xxxx;
return false;
}
// reference: D5DFF28ACD673B6D, 64A15DE7F2BB2A3E
// shader: 8B30, 167BE202B581D088
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor2.rgb) * (vec3(1) - last_tex_env_out.aaa) + (texcolor1.rgb) * (vec3(1) - (vec3(1) - last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (const_color[1].a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor0.rrr), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (const_color[4].rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((const_color[5].rgb) * (texcolor0.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 860E2BEA5D25A999, 167BE202B581D088
// program: 64A15DE7F2BB2A3E, EADA2116091C5E01, 167BE202B581D088
// shader: 8B30, DE2A5A1ED4A2AB30
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) * geo_factor) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) * geo_factor) + (refl_value * light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((texcolor1.rgb) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8781292684B823FD, DE2A5A1ED4A2AB30
// program: 25474969E3E91F82, F777123A8C3D5E20, DE2A5A1ED4A2AB30
// shader: 8B30, B1A2FB9FE1A49C81
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) * geo_factor) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) * geo_factor) + (refl_value * light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((texcolor1.rgb) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((texcolor1.rgb) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 650A057F7E72FBD4, B1A2FB9FE1A49C81
// program: 25474969E3E91F82, F777123A8C3D5E20, B1A2FB9FE1A49C81
// reference: C908228FC3ABD506, DE2A5A1ED4A2AB30
// shader: 8B30, 50B63AFBF2910682
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) * geo_factor) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) * geo_factor) + (refl_value * light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((texcolor1.rgb) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CEB7D73294B291A6, 50B63AFBF2910682
// program: 25474969E3E91F82, F777123A8C3D5E20, 50B63AFBF2910682
// shader: 8B30, 9FF74197F44C3422
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 25A23F3DC3047916, 9FF74197F44C3422
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 9FF74197F44C3422
// shader: 8B30, 56190CF0B5DE64D7
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) * geo_factor) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) * geo_factor) + (refl_value * light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((texcolor1.rgb) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C908228F060E5862, 56190CF0B5DE64D7
// program: 25474969E3E91F82, F777123A8C3D5E20, 56190CF0B5DE64D7
// shader: 8B30, 76FD32B6EF051669
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(light_vector, normal), 0.0))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(light_vector, normal), 0.0))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AA9712A89DA6D9EF, 76FD32B6EF051669
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 76FD32B6EF051669
// shader: 8B30, EE2F81E7863D3CB5
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texture(tex_cube, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texture(tex_cube, vec3(texcoord0, texcoord0_w)).rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 49C32948BD45D3FA, EE2F81E7863D3CB5
// program: 25474969E3E91F82, F777123A8C3D5E20, EE2F81E7863D3CB5
// shader: 8B30, 519CE5E918BFA611
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((secondary_fragment_color.rgb) * (secondary_fragment_color.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp(min((const_color[2].rgb) + (rounded_primary_color.rgb), vec3(1)) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 017FC1ADBB40DDFA, 519CE5E918BFA611
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 519CE5E918BFA611
// reference: 25A23F3D84178FED, 9FF74197F44C3422
// shader: 8B30, DA8BA90DB05101A2
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) * geo_factor) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) * geo_factor) + (refl_value * light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor2.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((texcolor1.rgb) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((texcolor1.rgb) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2144AB24D4DB3787, DA8BA90DB05101A2
// program: 5593DF1E36F9D5E0, EADA2116091C5E01, DA8BA90DB05101A2
// shader: 8B30, 9226A2254E449341
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor1.rgb);
float alpha_output_0 = byteround(clamp((texcolor0.r) * (rounded_primary_color.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor0.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (texcolor0.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BE55643E584FE66F, 9226A2254E449341
// program: 64A15DE7F2BB2A3E, EADA2116091C5E01, 9226A2254E449341
// reference: 6FCDA08D93C8C17C, DA8BA90DB05101A2
// shader: 8B30, AE18B08979F396A4
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = (1.0 - texcolor0.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9A63F8E4A19ECBB9, AE18B08979F396A4
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, AE18B08979F396A4
// shader: 8B30, B5F4D2005E3F937D
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0AAFB860EF26C985, B5F4D2005E3F937D
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, B5F4D2005E3F937D
// shader: 8B30, ABC54812EC5E97C2
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 657250FAC0879D8A, ABC54812EC5E97C2
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, ABC54812EC5E97C2
// shader: 8B30, 3E49A9B642B67E23
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FA247874AF1693F0, 3E49A9B642B67E23
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 3E49A9B642B67E23
// shader: 8B30, C6D55AD7CCC445EA
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((secondary_fragment_color.rgb) * (secondary_fragment_color.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp(min((const_color[2].rgb) + (rounded_primary_color.rgb), vec3(1)) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 017FC1ADE4253215, C6D55AD7CCC445EA
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, C6D55AD7CCC445EA
// shader: 8DD9, 58F5ACF9B36D7DF3

layout(triangles) in;
layout(triangle_strip, max_vertices=3) out;

layout(location=1) out vec4 primary_color;
layout(location=2) out vec2 texcoord0;
layout(location=3) out vec2 texcoord1;
layout(location=4) out vec2 texcoord2;
layout(location=5) out float texcoord0_w;
layout(location=6) out vec4 normquat;
layout(location=7) out vec3 view;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

layout(location=0) in vec4 vs_out_attr0[];
layout(location=1) in vec4 vs_out_attr1[];
layout(location=2) in vec4 vs_out_attr2[];
layout(location=3) in vec4 vs_out_attr3[];
struct Vertex {
    vec4 attributes[4];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = clamp(vtx_color, vec4(0), vec4(1));

    texcoord0 = vec2(0.0, 0.0);
    texcoord1 = vec2(0.0, 0.0);

    texcoord0_w = 0.0;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);
    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[4](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0]);
    prim_buffer[1].attributes = vec4[4](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1]);
    prim_buffer[2].attributes = vec4[4](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: 3901EC4BEC56958E, 58F5ACF9B36D7DF3
// shader: 8B31, 7145BC773338A58F

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=7) in vec4 vs_in_reg7;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_1();
bool sub_2();
bool sub_3();
bool sub_4();
bool sub_6();
bool sub_7();
bool sub_17();
bool sub_5();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_0();

bool exec_shader() {
sub_0();
return true;
}

bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_2();
} else {
sub_3();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_4();
} else {
sub_6();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_2() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_3() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_4() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_5();
return false;
}
bool sub_6() {
if (all(bool_regs)) {
sub_7();
} else {
sub_17();
}
return false;
}
bool sub_7() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_8();
return false;
}
bool sub_17() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_5() {
uint jmp_to = 73u;
while (true) {
switch (jmp_to) {
case 73u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 89u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 89u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 89u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_8() {
uint jmp_to = 90u;
while (true) {
switch (jmp_to) {
case 90u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 165u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 127u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 165u; break;
}
case 127u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_9();
} else {
sub_14();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 165u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_9() {
if (bool_regs.y) {
sub_10();
} else {
sub_11();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_10() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_11() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_12();
} else {
sub_13();
}
return false;
}
bool sub_12() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_14() {
if (bool_regs.y) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_18() {
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9 = uniforms.f[21];
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (bool_regs.y) {
sub_19();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_19() {
if (uniforms.b[7]) {
sub_20();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_20() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_0() {
sub_1();
sub_18();
return true;
}
// reference: 5A5700C3208CB306, 7145BC773338A58F
// shader: 8B30, 335FE3A4F5DAEFBA
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9AC98A889E2ABC6F, 335FE3A4F5DAEFBA
// program: 7145BC773338A58F, 58F5ACF9B36D7DF3, 335FE3A4F5DAEFBA
// shader: 8B30, 794C19794FDD94EF
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1A222FB90BD440FD, 794C19794FDD94EF
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 794C19794FDD94EF
// shader: 8B30, 49982E81698CB229
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (rounded_primary_color.rgb);
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BE98D8DA50F3C433, 49982E81698CB229
// program: 7145BC773338A58F, 58F5ACF9B36D7DF3, 49982E81698CB229
// shader: 8B30, E756489652AF30F5
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) + (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 26B95ADE49A484DA, E756489652AF30F5
// program: 7145BC773338A58F, 58F5ACF9B36D7DF3, E756489652AF30F5
// shader: 8DD9, D9AC2D854F4D2F3B

layout(triangles) in;
layout(triangle_strip, max_vertices=3) out;

layout(location=1) out vec4 primary_color;
layout(location=2) out vec2 texcoord0;
layout(location=3) out vec2 texcoord1;
layout(location=4) out vec2 texcoord2;
layout(location=5) out float texcoord0_w;
layout(location=6) out vec4 normquat;
layout(location=7) out vec3 view;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

layout(location=0) in vec4 vs_out_attr0[];
layout(location=1) in vec4 vs_out_attr1[];
layout(location=2) in vec4 vs_out_attr2[];
layout(location=3) in vec4 vs_out_attr3[];
struct Vertex {
    vec4 attributes[4];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
    primary_color = clamp(vtx_color, vec4(0), vec4(1));

    texcoord0 = vec2(vtx.attributes[2].x, vtx.attributes[2].y);
    texcoord1 = vec2(vtx.attributes[3].x, vtx.attributes[3].y);

    texcoord0_w = 0.0;
    view = vec3(0.0, 0.0, 0.0);
    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[4](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0]);
    prim_buffer[1].attributes = vec4[4](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1]);
    prim_buffer[2].attributes = vec4[4](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: A55C6948CCF76B42, D9AC2D854F4D2F3B
// shader: 8B31, 2043B1F9BC437834

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_1();
bool sub_16();
bool sub_2();
bool sub_3();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_0();
bool sub_4();
bool sub_5();

bool exec_shader() {
sub_0();
return true;
}

bool sub_1() {
addr_regs.x = (ivec2(vs_in_reg0.zz)).x;
reg_tmp10 = uniforms.f[0].xxxz;
reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
reg_tmp11 = uniforms.f[0].xxxx;
reg_tmp12 = uniforms.f[0].xxxx;
reg_tmp13 = uniforms.f[0].zzzz;
reg_tmp4 = uniforms.f[0].xxxx;
reg_tmp5 = uniforms.f[0].xxxx;
return false;
}
bool sub_16() {
vs_out_attr0 = reg_tmp10;
reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
vs_out_attr1 = reg_tmp13;
reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
reg_tmp14.y = (uniforms.f[81].wwww).y;
reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
reg_tmp2.x = rcp_s(reg_tmp14.x);
reg_tmp14.z = (reg_tmp2.xxxx).z;
reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
vs_out_attr2 = reg_tmp11;
vs_out_attr3 = reg_tmp12;
return false;
}
bool sub_2() {
reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
reg_tmp6.w = (uniforms.f[0].xxxx).w;
reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
reg_tmp6 = min_s(uniforms.f[81].xxxx, reg_tmp6);
reg_tmp6 = max_s(-uniforms.f[81].xxxx, reg_tmp6);
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
reg_tmp4.x = (reg_tmp1.xxxx).x;
reg_tmp5.x = (reg_tmp1.yyyy).x;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
reg_tmp4.y = (reg_tmp1.xxxx).y;
reg_tmp5.y = (reg_tmp1.yyyy).y;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
reg_tmp4.z = (reg_tmp1.xxxx).z;
reg_tmp5.z = (reg_tmp1.yyyy).z;
reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
reg_tmp6.y = (reg_tmp5.zzzz).y;
reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
reg_tmp6.w = (uniforms.f[0].xxxx).w;
reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
reg_tmp7.w = (uniforms.f[0].xxxx).w;
reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
reg_tmp8.w = (uniforms.f[0].xxxx).w;
reg_tmp9 = uniforms.f[0].xxxz;
return false;
}
bool sub_3() {
reg_tmp6.x = (uniforms.f[90].xxxx).x;
reg_tmp6.y = (uniforms.f[91].xxxx).y;
reg_tmp6.z = (uniforms.f[92].xxxx).z;
reg_tmp6.w = (uniforms.f[0].xxxx).w;
reg_tmp7.x = (uniforms.f[90].yyyy).x;
reg_tmp7.y = (uniforms.f[91].yyyy).y;
reg_tmp7.z = (uniforms.f[92].yyyy).z;
reg_tmp7.w = (uniforms.f[0].xxxx).w;
reg_tmp8.x = (uniforms.f[90].zzzz).x;
reg_tmp8.y = (uniforms.f[91].zzzz).y;
reg_tmp8.z = (uniforms.f[92].zzzz).z;
reg_tmp8.w = (uniforms.f[0].xxxx).w;
reg_tmp9.x = (uniforms.f[90].wwww).x;
reg_tmp9.y = (uniforms.f[91].wwww).y;
reg_tmp9.z = (uniforms.f[92].wwww).z;
reg_tmp9.w = (uniforms.f[0].zzzz).w;
return false;
}
bool sub_6() {
reg_tmp2 = uniforms.f[90];
reg_tmp3 = uniforms.f[91];
reg_tmp4 = uniforms.f[92];
reg_tmp5 = uniforms.f[0].xxxz;
reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
return false;
}
bool sub_7() {
reg_tmp2.x = rcp_s(uniforms.f[81].y);
reg_tmp2.xy = (mul_s(uniforms.f[2 + addr_regs.x].zwww, reg_tmp2.xxxx)).xy;
reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
reg_tmp2.xy = (uniforms.f[2 + addr_regs.x].zwww + -reg_tmp2.xyyy).xy;
reg_tmp0.xy = (min_s(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
reg_tmp0.xy = (max_s(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
reg_tmp5.x = (uniforms.f[5 + addr_regs.x].wwww).x;
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
bool_regs.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_8();
}
bool_regs.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_9();
}
bool_regs.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_10();
}
bool_regs.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_11();
}
reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
reg_tmp4.z = (uniforms.f[83].xxxx).z;
reg_tmp4.w = (-uniforms.f[83].yyyy).w;
reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + addr_regs.x].xyyy)).xy;
reg_tmp4.z = (-uniforms.f[3 + addr_regs.x].zzzz).z;
reg_tmp4.w = (-uniforms.f[3 + addr_regs.x].wwww).w;
reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
reg_tmp11.xy = (reg_tmp5.xyyy).xy;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
reg_tmp5.x = (uniforms.f[6 + addr_regs.x].wwww).x;
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
bool_regs.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_12();
}
bool_regs.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_13();
}
bool_regs.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_14();
}
bool_regs.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_15();
}
reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
reg_tmp4.z = (uniforms.f[83].zzzz).z;
reg_tmp4.w = (-uniforms.f[83].wwww).w;
reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + addr_regs.x].xyyy)).xy;
reg_tmp4.z = (-uniforms.f[4 + addr_regs.x].zzzz).z;
reg_tmp4.w = (-uniforms.f[4 + addr_regs.x].wwww).w;
reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
reg_tmp12.xy = (reg_tmp5.xyyy).xy;
return false;
}
bool sub_8() {
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
return false;
}
bool sub_9() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
return false;
}
bool sub_10() {
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_11() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_12() {
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
return false;
}
bool sub_13() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
return false;
}
bool sub_14() {
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_15() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_0() {
sub_1();
reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
reg_tmp10.xy = (mul_s(uniforms.f[2 + addr_regs.x].xyyy, reg_tmp10.xyyy)).xy;
reg_tmp0 = uniforms.f[7 + addr_regs.x];
sub_2();
reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
reg_tmp10 = reg_tmp2;
sub_3();
reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
reg_tmp3.xyz = (uniforms.f[5 + addr_regs.x].xyzz).xyz;
reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
if (bool_regs.x) {
sub_4();
} else {
sub_5();
}
reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp10.xyz = (uniforms.f[5 + addr_regs.x].xyzz + reg_tmp2.xyzz).xyz;
reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
sub_6();
reg_tmp2 = reg_tmp10;
reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
reg_tmp2 = uniforms.f[1 + addr_regs.x];
reg_tmp3 = max_s(uniforms.f[0].xxxx, reg_tmp2);
reg_tmp2 = min_s(uniforms.f[0].zzzz, reg_tmp3);
reg_tmp13 = reg_tmp2;
sub_7();
sub_16();
return true;
}
bool sub_4() {
reg_tmp4.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_5() {
reg_tmp4.x = rsq_s(reg_tmp4.x);
return false;
}
// reference: 15D7A4B59B2B2298, 2043B1F9BC437834
// shader: 8B30, 353651469CD69573
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.r) + (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 1.0, alpha_output_1 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 08FF7D5C7C5323CA, 353651469CD69573
// program: 2043B1F9BC437834, D9AC2D854F4D2F3B, 353651469CD69573
// shader: 8B30, 472E3AD88253EEDC
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4AD66289F9F7F8FB, 472E3AD88253EEDC
// program: 2043B1F9BC437834, D9AC2D854F4D2F3B, 472E3AD88253EEDC
// shader: 8B31, DD46645290F0BF46

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_1();
bool sub_19();
bool sub_2();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_0();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();

bool exec_shader() {
sub_0();
return true;
}

bool sub_1() {
reg_tmp10 = uniforms.f[0].xxxz;
reg_tmp10.xyz = (vs_in_reg0.xyzz).xyz;
reg_tmp11 = uniforms.f[0].xxxx;
reg_tmp12 = uniforms.f[0].xxxx;
reg_tmp11.xy = (vs_in_reg1.xyyy).xy;
reg_tmp13 = uniforms.f[0].zzzz;
reg_tmp4 = uniforms.f[0].xxxx;
reg_tmp5 = uniforms.f[0].xxxx;
return false;
}
bool sub_19() {
vs_out_attr0 = reg_tmp10;
reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
vs_out_attr1 = mul_s(vs_in_reg2, reg_tmp13);
reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
reg_tmp14.y = (uniforms.f[81].wwww).y;
reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
reg_tmp2.x = rcp_s(reg_tmp14.x);
reg_tmp14.z = (reg_tmp2.xxxx).z;
reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
vs_out_attr2 = reg_tmp11;
vs_out_attr3 = reg_tmp12;
return false;
}
bool sub_2() {
reg_tmp1.xyz = (uniforms.f[92].xyzz).xyz;
reg_tmp1.w = (uniforms.f[0].xxxx).w;
return false;
}
bool sub_9() {
reg_tmp2 = uniforms.f[90];
reg_tmp3 = uniforms.f[91];
reg_tmp4 = uniforms.f[92];
reg_tmp5 = uniforms.f[0].xxxz;
reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
return false;
}
bool sub_10() {
reg_tmp2.x = rcp_s(uniforms.f[81].y);
reg_tmp2.xy = (mul_s(uniforms.f[2].zwww, reg_tmp2.xxxx)).xy;
reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
reg_tmp2.xy = (uniforms.f[2].zwww + -reg_tmp2.xyyy).xy;
reg_tmp0.xy = (min_s(uniforms.f[81].xxxx, reg_tmp2.xyyy)).xy;
reg_tmp0.xy = (max_s(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
reg_tmp5.x = (uniforms.f[5].wwww).x;
reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
bool_regs.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_11();
}
bool_regs.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_12();
}
bool_regs.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_13();
}
bool_regs.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_14();
}
reg_tmp3 = reg_tmp14.xyxy;
reg_tmp3.y = (uniforms.f[0].zzzz + -reg_tmp3.yyyy).y;
reg_tmp3.w = (uniforms.f[0].zzzz + -reg_tmp3.wwww).w;
reg_tmp2 = mul_s(uniforms.f[83].xxyy, reg_tmp3);
reg_tmp2 = -uniforms.f[0].yyyy + reg_tmp2;
reg_tmp2 = mul_s(reg_tmp2, reg_tmp1.xyyx);
reg_tmp2.x = (reg_tmp2.xxxx + -reg_tmp2.yyyy).x;
reg_tmp2.y = (reg_tmp2.zzzz + reg_tmp2.wwww).y;
reg_tmp4.xy = (uniforms.f[3].xyyy).xy;
reg_tmp3.xy = (fma_s(reg_tmp2.xyyy, uniforms.f[3].zwww, reg_tmp4.xyyy)).xy;
reg_tmp3.xy = (uniforms.f[0].yyyy + reg_tmp3.xyyy).xy;
reg_tmp11.xy = (reg_tmp3.xyyy).xy;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
reg_tmp5.x = (uniforms.f[6].wwww).x;
reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
bool_regs.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_15();
}
bool_regs.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_16();
}
bool_regs.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_17();
}
bool_regs.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_18();
}
reg_tmp3 = reg_tmp14.xyxy;
reg_tmp3.y = (uniforms.f[0].zzzz + -reg_tmp3.yyyy).y;
reg_tmp3.w = (uniforms.f[0].zzzz + -reg_tmp3.wwww).w;
reg_tmp2 = mul_s(uniforms.f[83].zzww, reg_tmp3);
reg_tmp2 = -uniforms.f[0].yyyy + reg_tmp2;
reg_tmp2 = mul_s(reg_tmp2, reg_tmp1.xyyx);
reg_tmp2.x = (reg_tmp2.xxxx + -reg_tmp2.yyyy).x;
reg_tmp2.y = (reg_tmp2.zzzz + reg_tmp2.wwww).y;
reg_tmp4.xy = (uniforms.f[4].xyyy).xy;
reg_tmp3.xy = (fma_s(reg_tmp2.xyyy, uniforms.f[4].zwww, reg_tmp4.xyyy)).xy;
reg_tmp3.xy = (uniforms.f[0].yyyy + reg_tmp3.xyyy).xy;
reg_tmp12.xy = (reg_tmp3.xyyy).xy;
return false;
}
bool sub_11() {
reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
return false;
}
bool sub_12() {
reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
return false;
}
bool sub_13() {
reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
return false;
}
bool sub_14() {
reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
return false;
}
bool sub_15() {
reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
return false;
}
bool sub_16() {
reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
return false;
}
bool sub_17() {
reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
return false;
}
bool sub_18() {
reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
return false;
}
bool sub_0() {
sub_1();
reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
reg_tmp10.xyz = (mul_s(uniforms.f[2].xyxx, reg_tmp10.xyzz)).xyz;
sub_2();
reg_tmp2.xyz = (-reg_tmp1.xyzz).xyz;
reg_tmp3.xyz = (uniforms.f[6].xyzz).xyz;
reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
if (bool_regs.x) {
sub_3();
} else {
sub_4();
}
reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp4.xyz = (mul_s(reg_tmp2.yzxx, reg_tmp3.zxyy)).xyz;
reg_tmp4.xyz = (fma_s(-reg_tmp3.yzxx, reg_tmp2.zxyy, reg_tmp4)).xyz;
reg_tmp5.x = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
if (bool_regs.x) {
sub_5();
} else {
sub_6();
}
reg_tmp4.xyz = (mul_s(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
reg_tmp5.xyz = (mul_s(reg_tmp4.yzxx, reg_tmp3.zxyy)).xyz;
reg_tmp5.xyz = (fma_s(-reg_tmp3.yzxx, reg_tmp4.zxyy, reg_tmp5)).xyz;
reg_tmp6.x = (reg_tmp4.xxxx).x;
reg_tmp6.y = (reg_tmp3.xxxx).y;
reg_tmp6.z = (reg_tmp5.xxxx).z;
reg_tmp6.w = (uniforms.f[0].xxxx).w;
reg_tmp7.x = (reg_tmp4.yyyy).x;
reg_tmp7.y = (reg_tmp3.yyyy).y;
reg_tmp7.z = (reg_tmp5.yyyy).z;
reg_tmp7.w = (uniforms.f[0].xxxx).w;
reg_tmp8.x = (reg_tmp4.zzzz).x;
reg_tmp8.y = (reg_tmp3.zzzz).y;
reg_tmp8.z = (reg_tmp5.zzzz).z;
reg_tmp8.w = (uniforms.f[0].xxxx).w;
reg_tmp9 = uniforms.f[0].xxxz;
reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
reg_tmp3.xyz = (uniforms.f[5].xyzz).xyz;
reg_tmp3.xyz = (-uniforms.f[85].xyzz + reg_tmp3.xyzz).xyz;
reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
if (bool_regs.x) {
sub_7();
} else {
sub_8();
}
reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp10.xyz = (uniforms.f[5].xyzz + reg_tmp2.xyzz).xyz;
reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, -uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
sub_9();
reg_tmp2 = reg_tmp10;
reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
reg_tmp2 = uniforms.f[1];
reg_tmp3 = max_s(uniforms.f[0].xxxx, reg_tmp2);
reg_tmp2 = min_s(uniforms.f[0].zzzz, reg_tmp3);
reg_tmp13 = reg_tmp2;
sub_10();
sub_19();
return true;
}
bool sub_3() {
reg_tmp4.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_4() {
reg_tmp4.x = rsq_s(reg_tmp4.x);
return false;
}
bool sub_5() {
reg_tmp5.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_6() {
reg_tmp5.x = rsq_s(reg_tmp5.x);
return false;
}
bool sub_7() {
reg_tmp4.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_8() {
reg_tmp4.x = rsq_s(reg_tmp4.x);
return false;
}
// reference: 41E38AB4DA25FE4E, DD46645290F0BF46
// program: DD46645290F0BF46, D9AC2D854F4D2F3B, 472E3AD88253EEDC
// shader: 8B31, 9A33D22D27DAF17E

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_1();
bool sub_19();
bool sub_2();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_0();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();

bool exec_shader() {
sub_0();
return true;
}

bool sub_1() {
addr_regs.x = (ivec2(vs_in_reg0.zz)).x;
reg_tmp10 = uniforms.f[0].xxxz;
reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
reg_tmp11 = uniforms.f[0].xxxx;
reg_tmp12 = uniforms.f[0].xxxx;
reg_tmp13 = uniforms.f[0].zzzz;
reg_tmp4 = uniforms.f[0].xxxx;
reg_tmp5 = uniforms.f[0].xxxx;
return false;
}
bool sub_19() {
vs_out_attr0 = reg_tmp10;
reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
vs_out_attr1 = reg_tmp13;
reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
reg_tmp14.y = (uniforms.f[81].wwww).y;
reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
reg_tmp2.x = rcp_s(reg_tmp14.x);
reg_tmp14.z = (reg_tmp2.xxxx).z;
reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
vs_out_attr2 = reg_tmp11;
vs_out_attr3 = reg_tmp12;
return false;
}
bool sub_2() {
reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
reg_tmp6.w = (uniforms.f[0].xxxx).w;
reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
reg_tmp6 = min_s(uniforms.f[81].xxxx, reg_tmp6);
reg_tmp6 = max_s(-uniforms.f[81].xxxx, reg_tmp6);
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
reg_tmp4.x = (reg_tmp1.xxxx).x;
reg_tmp5.x = (reg_tmp1.yyyy).x;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
reg_tmp4.y = (reg_tmp1.xxxx).y;
reg_tmp5.y = (reg_tmp1.yyyy).y;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
reg_tmp4.z = (reg_tmp1.xxxx).z;
reg_tmp5.z = (reg_tmp1.yyyy).z;
reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
reg_tmp6.y = (reg_tmp5.zzzz).y;
reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
reg_tmp6.w = (uniforms.f[0].xxxx).w;
reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
reg_tmp7.w = (uniforms.f[0].xxxx).w;
reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
reg_tmp8.w = (uniforms.f[0].xxxx).w;
reg_tmp9 = uniforms.f[0].xxxz;
return false;
}
bool sub_9() {
reg_tmp2 = uniforms.f[90];
reg_tmp3 = uniforms.f[91];
reg_tmp4 = uniforms.f[92];
reg_tmp5 = uniforms.f[0].xxxz;
reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
return false;
}
bool sub_10() {
reg_tmp2.x = rcp_s(uniforms.f[81].y);
reg_tmp2.xy = (mul_s(uniforms.f[2 + addr_regs.x].zwww, reg_tmp2.xxxx)).xy;
reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
reg_tmp2.xy = (uniforms.f[2 + addr_regs.x].zwww + -reg_tmp2.xyyy).xy;
reg_tmp0.xy = (min_s(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
reg_tmp0.xy = (max_s(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
reg_tmp5.x = (uniforms.f[5 + addr_regs.x].wwww).x;
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
bool_regs.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_11();
}
bool_regs.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_12();
}
bool_regs.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_13();
}
bool_regs.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_14();
}
reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
reg_tmp4.z = (uniforms.f[83].xxxx).z;
reg_tmp4.w = (-uniforms.f[83].yyyy).w;
reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + addr_regs.x].xyyy)).xy;
reg_tmp4.z = (-uniforms.f[3 + addr_regs.x].zzzz).z;
reg_tmp4.w = (-uniforms.f[3 + addr_regs.x].wwww).w;
reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
reg_tmp11.xy = (reg_tmp5.xyyy).xy;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
reg_tmp5.x = (uniforms.f[6 + addr_regs.x].wwww).x;
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
bool_regs.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_15();
}
bool_regs.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_16();
}
bool_regs.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_17();
}
bool_regs.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_18();
}
reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
reg_tmp4.z = (uniforms.f[83].zzzz).z;
reg_tmp4.w = (-uniforms.f[83].wwww).w;
reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + addr_regs.x].xyyy)).xy;
reg_tmp4.z = (-uniforms.f[4 + addr_regs.x].zzzz).z;
reg_tmp4.w = (-uniforms.f[4 + addr_regs.x].wwww).w;
reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
reg_tmp12.xy = (reg_tmp5.xyyy).xy;
return false;
}
bool sub_11() {
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
return false;
}
bool sub_12() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
return false;
}
bool sub_13() {
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_14() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_15() {
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
return false;
}
bool sub_16() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
return false;
}
bool sub_17() {
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_18() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_0() {
sub_1();
reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
reg_tmp10.xy = (mul_s(uniforms.f[2 + addr_regs.x].xyyy, reg_tmp10.xyyy)).xy;
reg_tmp14 = reg_tmp10;
reg_tmp0 = uniforms.f[7 + addr_regs.x];
sub_2();
reg_tmp10.x = dot_s(reg_tmp14, reg_tmp6);
reg_tmp10.y = dot_s(reg_tmp14, reg_tmp7);
reg_tmp10.z = dot_s(reg_tmp14, reg_tmp8);
reg_tmp10.w = dot_s(reg_tmp14, reg_tmp9);
reg_tmp2.x = (uniforms.f[8 + addr_regs.x].yyyy).x;
reg_tmp2.y = (uniforms.f[9 + addr_regs.x].yyyy).y;
reg_tmp2.z = (uniforms.f[10 + addr_regs.x].yyyy).z;
reg_tmp3.xyz = (uniforms.f[6 + addr_regs.x].xyzz).xyz;
reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
if (bool_regs.x) {
sub_3();
} else {
sub_4();
}
reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp4.xyz = (mul_s(reg_tmp2.yzxx, reg_tmp3.zxyy)).xyz;
reg_tmp4.xyz = (fma_s(-reg_tmp3.yzxx, reg_tmp2.zxyy, reg_tmp4)).xyz;
reg_tmp5.x = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
if (bool_regs.x) {
sub_5();
} else {
sub_6();
}
reg_tmp4.xyz = (mul_s(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
reg_tmp5.xyz = (mul_s(reg_tmp4.yzxx, reg_tmp3.zxyy)).xyz;
reg_tmp5.xyz = (fma_s(-reg_tmp3.yzxx, reg_tmp4.zxyy, reg_tmp5)).xyz;
reg_tmp6.x = (reg_tmp4.xxxx).x;
reg_tmp6.y = (reg_tmp3.xxxx).y;
reg_tmp6.z = (reg_tmp5.xxxx).z;
reg_tmp6.w = (uniforms.f[0].xxxx).w;
reg_tmp7.x = (reg_tmp4.yyyy).x;
reg_tmp7.y = (reg_tmp3.yyyy).y;
reg_tmp7.z = (reg_tmp5.yyyy).z;
reg_tmp7.w = (uniforms.f[0].xxxx).w;
reg_tmp8.x = (reg_tmp4.zzzz).x;
reg_tmp8.y = (reg_tmp3.zzzz).y;
reg_tmp8.z = (reg_tmp5.zzzz).z;
reg_tmp8.w = (uniforms.f[0].xxxx).w;
reg_tmp9 = uniforms.f[0].xxxz;
reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
reg_tmp3.xyz = (uniforms.f[5 + addr_regs.x].xyzz).xyz;
reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
if (bool_regs.x) {
sub_7();
} else {
sub_8();
}
reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp10.xyz = (uniforms.f[5 + addr_regs.x].xyzz + reg_tmp2.xyzz).xyz;
reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
sub_9();
reg_tmp2 = reg_tmp10;
reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
reg_tmp2 = uniforms.f[1 + addr_regs.x];
reg_tmp3 = max_s(uniforms.f[0].xxxx, reg_tmp2);
reg_tmp2 = min_s(uniforms.f[0].zzzz, reg_tmp3);
reg_tmp13 = reg_tmp2;
sub_10();
sub_19();
return true;
}
bool sub_3() {
reg_tmp4.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_4() {
reg_tmp4.x = rsq_s(reg_tmp4.x);
return false;
}
bool sub_5() {
reg_tmp5.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_6() {
reg_tmp5.x = rsq_s(reg_tmp5.x);
return false;
}
bool sub_7() {
reg_tmp4.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_8() {
reg_tmp4.x = rsq_s(reg_tmp4.x);
return false;
}
// reference: AE521CFA019403FD, 9A33D22D27DAF17E
// program: 9A33D22D27DAF17E, D9AC2D854F4D2F3B, 472E3AD88253EEDC
// shader: 8B30, 03C796BF3C4847CA
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7E79444618059053, 03C796BF3C4847CA
// program: 2043B1F9BC437834, D9AC2D854F4D2F3B, 03C796BF3C4847CA
// shader: 8B30, 06629A88DBE56314
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp(min((texcolor1.rgb) + (texcolor2.rgb), vec3(1)) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].aaa), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CD61A18991F330A1, 06629A88DBE56314
// program: 5593DF1E36F9D5E0, EADA2116091C5E01, 06629A88DBE56314
// shader: 8B31, A6FB5CB53EA51ED8

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_20();
bool sub_3();
bool sub_8();
bool sub_1();
bool sub_2();
bool sub_4();
bool sub_6();
bool sub_7();
bool sub_9();
bool sub_19();
bool sub_21();
bool sub_5();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_32();
bool sub_31();
bool sub_33();
bool sub_0();

bool exec_shader() {
sub_0();
return true;
}

bool sub_20() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_3() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_8() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_2();
} else {
sub_6();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_2() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_3();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_3();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_3();
}
if (uniforms.b[8]) {
sub_4();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_5();
return false;
}
bool sub_4() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_3();
}
return false;
}
bool sub_6() {
if (all(bool_regs)) {
sub_7();
} else {
sub_19();
}
return false;
}
bool sub_7() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_8();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_8();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_8();
}
if (uniforms.b[8]) {
sub_9();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_10();
return false;
}
bool sub_9() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_8();
}
return false;
}
bool sub_19() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_20();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_20();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_20();
}
if (uniforms.b[8]) {
sub_21();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_21() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_20();
}
return false;
}
bool sub_5() {
uint jmp_to = 139u;
while (true) {
switch (jmp_to) {
case 139u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 155u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 155u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 155u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_10() {
uint jmp_to = 156u;
while (true) {
switch (jmp_to) {
case 156u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 231u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 193u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 231u; break;
}
case 193u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_11();
} else {
sub_16();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 231u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
if (bool_regs.y) {
sub_12();
} else {
sub_13();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_12() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_13() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_14();
} else {
sub_15();
}
return false;
}
bool sub_14() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_15() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_16() {
if (bool_regs.y) {
sub_17();
} else {
sub_18();
}
return false;
}
bool sub_17() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_22() {
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9 = uniforms.f[21];
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (bool_regs.y) {
sub_23();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_23() {
if (uniforms.b[7]) {
sub_24();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_24() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_25() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_26();
} else {
sub_27();
}
return false;
}
bool sub_26() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_27() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_28();
} else {
sub_29();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_28() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_29() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_30();
} else {
sub_32();
}
return false;
}
bool sub_30() {
sub_31();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_32() {
sub_33();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_31() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_33() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_0() {
sub_1();
sub_22();
sub_25();
return true;
}
// reference: 352F338983EE9C18, A6FB5CB53EA51ED8
// shader: 8B30, 10C3650E3222344C
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CB17905AC2CC1FE9, 10C3650E3222344C
// program: A6FB5CB53EA51ED8, C8DF8CC87A4E8CE6, 10C3650E3222344C
// reference: BE98D8DA1BCA65FB, 49982E81698CB229
// shader: 8B30, 47B12A49A7EB9ADF
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (const_color[0].aaa), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4F013BB2C4D22E71, 47B12A49A7EB9ADF
// program: 7145BC773338A58F, 58F5ACF9B36D7DF3, 47B12A49A7EB9ADF
// shader: 8DD9, B6B95AFD9466EC70

layout(triangles) in;
layout(triangle_strip, max_vertices=3) out;

layout(location=1) out vec4 primary_color;
layout(location=2) out vec2 texcoord0;
layout(location=3) out vec2 texcoord1;
layout(location=4) out vec2 texcoord2;
layout(location=5) out float texcoord0_w;
layout(location=6) out vec4 normquat;
layout(location=7) out vec3 view;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

layout(location=0) in vec4 vs_out_attr0[];
layout(location=1) in vec4 vs_out_attr1[];
layout(location=2) in vec4 vs_out_attr2[];
layout(location=3) in vec4 vs_out_attr3[];
layout(location=4) in vec4 vs_out_attr4[];
struct Vertex {
    vec4 attributes[5];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
    primary_color = clamp(vtx_color, vec4(0), vec4(1));

    texcoord0 = vec2(vtx.attributes[2].x, vtx.attributes[2].y);
    texcoord1 = vec2(vtx.attributes[3].x, vtx.attributes[3].y);

    texcoord0_w = 0.0;
    view = vec3(0.0, 0.0, 0.0);
    texcoord2 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[5](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0]);
    prim_buffer[1].attributes = vec4[5](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1]);
    prim_buffer[2].attributes = vec4[5](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: 5DAD5699F59B3586, B6B95AFD9466EC70
// shader: 8B31, 9EAFCF401AA96956

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_1();
bool sub_0();
bool sub_2();
bool sub_3();
bool sub_4();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();

bool exec_shader() {
sub_0();
return true;
}

bool sub_5() {
reg_tmp13 = floor(reg_tmp0.xxxx);
reg_tmp13 = reg_tmp0.xxxx + -reg_tmp13;
addr_regs.y = (ivec2(reg_tmp11.zz)).y;
bool_regs = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
if (bool_regs.x) {
sub_6();
}
bool_regs = lessThanEqual(uniforms.f[5].yy, reg_tmp11.xy);
if (!bool_regs.y) {
sub_15();
} else {
sub_22();
}
return false;
}
bool sub_6() {
reg_tmp12.xy = (uniforms.f[5].xyyy + vs_in_reg0.zwww).xy;
reg_tmp14.xy = (uniforms.f[6].wzzz).xy;
reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
reg_tmp13.y = (floor(reg_tmp13)).y;
reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
bool_regs = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
if (bool_regs.x) {
sub_7();
}
reg_tmp14.xy = (mul_s(reg_tmp14, reg_tmp2)).xy;
reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
reg_tmp13.zw = (floor(reg_tmp13)).zw;
reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
bool_regs = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
if (bool_regs.y) {
sub_8();
}
if (bool_regs.x) {
sub_9();
}
reg_tmp14.xy = (uniforms.f[5].yyyy + -reg_tmp14.xyyy).xy;
reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
reg_tmp13.zw = (floor(reg_tmp13)).zw;
reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
bool_regs = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
if (bool_regs.y) {
sub_10();
}
if (bool_regs.x) {
sub_11();
}
reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
reg_tmp13.zw = (floor(reg_tmp13)).zw;
reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
bool_regs = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
if (bool_regs.y) {
sub_12();
}
if (bool_regs.x) {
sub_13();
}
reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
reg_tmp13.y = (floor(reg_tmp13)).y;
reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
bool_regs = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
if (bool_regs.x) {
sub_14();
}
reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
return false;
}
bool sub_7() {
reg_tmp14.xy = (reg_tmp14.yxxx).xy;
return false;
}
bool sub_8() {
reg_tmp12.x = (mul_s(reg_tmp12.xxxx, reg_tmp14.xxxx)).x;
return false;
}
bool sub_9() {
reg_tmp12.y = (fma_s(reg_tmp12.yyyy, reg_tmp14.yyyy, uniforms.f[5].yyyy)).y;
reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
return false;
}
bool sub_10() {
reg_tmp12.x = (reg_tmp12.xxxx + reg_tmp14.xxxx).x;
return false;
}
bool sub_11() {
reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
return false;
}
bool sub_12() {
reg_tmp12.x = (uniforms.f[5].yyyy + -reg_tmp12.xxxx).x;
return false;
}
bool sub_13() {
reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
return false;
}
bool sub_14() {
reg_tmp12.xy = (uniforms.f[5].yyyy + -reg_tmp12.yxxx).xy;
return false;
}
bool sub_15() {
reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
bool_regs = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
reg_tmp13 = uniforms.f[32 + addr_regs.y].wzyx;
if (bool_regs.x) {
sub_16();
} else {
sub_17();
}
reg_tmp11.z = (uniforms.f[5].yyyy + reg_tmp11.zzzz).z;
return false;
}
bool sub_16() {
reg_tmp11.xy = (fma_s(reg_tmp12.xyyy, reg_tmp13.xyyy, reg_tmp13.zwww)).xy;
reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
return false;
}
bool sub_17() {
bool_regs = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
if (!bool_regs.x) {
sub_18();
} else {
sub_19();
}
if (!bool_regs.y) {
sub_20();
} else {
sub_21();
}
return false;
}
bool sub_18() {
reg_tmp11.x = (reg_tmp13.xxxx).x;
return false;
}
bool sub_19() {
reg_tmp11.x = (reg_tmp13.zzzz).x;
return false;
}
bool sub_20() {
reg_tmp11.y = (reg_tmp13.yyyy).y;
return false;
}
bool sub_21() {
reg_tmp11.y = (reg_tmp13.wwww).y;
return false;
}
bool sub_22() {
if (!bool_regs.x) {
sub_23();
} else {
sub_32();
}
reg_tmp11.z = (uniforms.f[5].zzzz + reg_tmp11.zzzz).z;
return false;
}
bool sub_23() {
reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
bool_regs = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
if (bool_regs.x) {
sub_24();
} else {
sub_25();
}
return false;
}
bool sub_24() {
reg_tmp12.zw = (uniforms.f[5].xxxy).zw;
reg_tmp11.x = dot_s(uniforms.f[32 + addr_regs.y].wzyx, reg_tmp12);
reg_tmp11.y = dot_s(uniforms.f[33 + addr_regs.y].wzyx, reg_tmp12);
reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
return false;
}
bool sub_25() {
reg_tmp14 = uniforms.f[32 + addr_regs.y].wzyx;
reg_tmp13 = uniforms.f[33 + addr_regs.y].wzyx;
bool_regs = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
if (!bool_regs.y) {
sub_26();
} else {
sub_29();
}
return false;
}
bool sub_26() {
if (!bool_regs.x) {
sub_27();
} else {
sub_28();
}
return false;
}
bool sub_27() {
reg_tmp11.xy = (reg_tmp14.xyyy).xy;
return false;
}
bool sub_28() {
reg_tmp11.xy = (reg_tmp13.zwww).xy;
return false;
}
bool sub_29() {
if (!bool_regs.x) {
sub_30();
} else {
sub_31();
}
return false;
}
bool sub_30() {
reg_tmp11.xy = (reg_tmp13.xyyy).xy;
return false;
}
bool sub_31() {
reg_tmp11.xy = (reg_tmp14.zwww).xy;
return false;
}
bool sub_32() {
reg_tmp11.x = dot_s(uniforms.f[32 + addr_regs.y].wzyx, reg_tmp1);
reg_tmp11.y = dot_s(uniforms.f[33 + addr_regs.y].wzyx, reg_tmp1);
return false;
}
bool sub_1() {
uint jmp_to = 97u;
while (true) {
switch (jmp_to) {
case 97u:
reg_tmp3.x = dot_s(uniforms.f[32 + addr_regs.x].wzyx, reg_tmp1);
reg_tmp3.y = dot_s(uniforms.f[33 + addr_regs.x].wzyx, reg_tmp1);
reg_tmp3.z = dot_s(uniforms.f[34 + addr_regs.x].wzyx, reg_tmp1);
reg_tmp3.w = (reg_tmp1.wwww).w;
reg_tmp11 = uniforms.f[4].wzyx;
reg_tmp11.z = (-uniforms.f[34 + addr_regs.x].xxxx + reg_tmp11.zzzz).z;
bool_regs.x = uniforms.f[5].xxxx.x != reg_tmp11.xzzz.x;
bool_regs.y = uniforms.f[5].xxxx.y < reg_tmp11.xzzz.y;
if (any(not(bool_regs))) {
jmp_to = 108u; break;
}
reg_tmp11.z = rcp_s(reg_tmp11.z);
reg_tmp3.x = (reg_tmp3.xxxx + reg_tmp11.xxxx).x;
reg_tmp3.x = (fma_s(-reg_tmp11.yyyy, reg_tmp11.zzzz, reg_tmp3.xxxx)).x;
case 108u:
default: return false;
}
}
return false;
}
bool sub_0() {
uint jmp_to = 109u;
while (true) {
switch (jmp_to) {
case 109u:
addr_regs.x = (ivec2(vs_in_reg0.xx)).x;
reg_tmp0 = uniforms.f[9 + addr_regs.x].wzyx;
reg_tmp1.xy = (vs_in_reg0.zwzw).xy;
reg_tmp1.zw = (uniforms.f[5].xyxy).zw;
addr_regs.xy = ivec2(reg_tmp0.xy);
reg_tmp2 = uniforms.f[32 + addr_regs.y].wzyx;
if (uniforms.b[0]) {
jmp_to = 191u; break;
}
reg_tmp4 = uniforms.f[31 + addr_regs.x].wzyx;
reg_tmp1.xy = (fma_s(reg_tmp1.xyyy, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
sub_1();
vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
bool_regs = greaterThanEqual(uniforms.f[5].yy, reg_tmp0.ww);
if (all(bool_regs)) {
sub_2();
} else {
sub_3();
}
reg_tmp11.z = (reg_tmp0.zzzz).z;
reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp0.zzzz);
reg_tmp9.xy = (floor(reg_tmp9)).xy;
reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
reg_tmp14 = uniforms.f[6].wzyx;
reg_tmp11.xy = (reg_tmp9.xyyy).xy;
sub_5();
if (uniforms.b[1]) {
sub_33();
}
if (uniforms.b[2]) {
sub_34();
}
vs_out_attr2 = reg_tmp11.xyyy;
reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
reg_tmp9.xy = (floor(reg_tmp9)).xy;
reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
reg_tmp14 = uniforms.f[7].wzyx;
reg_tmp11.xy = (reg_tmp9.xyyy).xy;
sub_5();
if (uniforms.b[3]) {
sub_35();
}
if (uniforms.b[4]) {
sub_36();
}
vs_out_attr3 = reg_tmp11.xyyy;
reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
reg_tmp9.xy = (floor(reg_tmp9)).xy;
reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
reg_tmp14 = uniforms.f[8].wzyx;
reg_tmp11.xy = (reg_tmp9.xyyy).xy;
sub_5();
if (uniforms.b[5]) {
sub_37();
}
if (uniforms.b[6]) {
sub_38();
}
vs_out_attr4 = reg_tmp11.xyyy;
return true;
case 191u:
reg_tmp2.w = (reg_tmp2.wwww + reg_tmp2.yyyy).w;
reg_tmp1.y = (-uniforms.f[5].yyyy + -reg_tmp1.yyyy).y;
reg_tmp13.xy = (mul_s(uniforms.f[36 + addr_regs.x].wzzz, reg_tmp2.xyyy)).xy;
reg_tmp11.x = (mul_s(uniforms.f[35 + addr_regs.x].wwww, -reg_tmp1.yyyy)).x;
reg_tmp1.xy = (mul_s(reg_tmp1.xyyy, reg_tmp13.xyyy)).xy;
reg_tmp1.x = (reg_tmp1.xxxx + reg_tmp11.xxxx).x;
if (uniforms.b[1]) {
sub_39();
}
reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp2.zwww).xy;
reg_tmp1.xy = (uniforms.f[36 + addr_regs.x].yxxx + reg_tmp1.xyyy).xy;
sub_1();
vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
if (uniforms.b[2]) {
sub_40();
} else {
sub_41();
}
reg_tmp8 = reg_tmp8 + -reg_tmp7;
vs_out_attr1 = fma_s(reg_tmp8, reg_tmp11.yyyy, reg_tmp7);
reg_tmp9.xy = (mul_s(uniforms.f[32 + addr_regs.x].yxxx, reg_tmp11)).xy;
reg_tmp11.zw = (vec4(lessThan(reg_tmp11, uniforms.f[5].yyyy))).zw;
reg_tmp9.xy = (fma_s(reg_tmp11.zwww, uniforms.f[32 + addr_regs.x].wzzz, reg_tmp9.xyyy)).xy;
reg_tmp9.y = (uniforms.f[5].yyyy + -reg_tmp9.yyyy).y;
vs_out_attr2 = reg_tmp9;
vs_out_attr3 = reg_tmp9;
vs_out_attr4 = reg_tmp9;
return true;
default: return false;
}
}
return false;
}
bool sub_2() {
vs_out_attr1.xyz = (uniforms.f[5].yyyy).xyz;
vs_out_attr1.w = (reg_tmp0.wwww).w;
return false;
}
bool sub_3() {
addr_regs.y = (ivec2(reg_tmp0.ww)).y;
reg_tmp7 = uniforms.f[32 + addr_regs.y].wzyx;
reg_tmp8 = uniforms.f[33 + addr_regs.y].wzyx;
reg_tmp9 = uniforms.f[34 + addr_regs.y].wzyx;
reg_tmp10 = uniforms.f[35 + addr_regs.y].wzyx;
reg_tmp11.xy = (vs_in_reg0.zwww).xy;
reg_tmp14.x = (floor(reg_tmp0.yyyy)).x;
reg_tmp14.x = (reg_tmp0.yyyy + -reg_tmp14.xxxx).x;
bool_regs = lessThanEqual(uniforms.f[5].ww, reg_tmp14.xx);
if (bool_regs.x) {
sub_4();
}
reg_tmp11.xy = (abs(reg_tmp11.xyyy)).xy;
reg_tmp8 = reg_tmp8 + -reg_tmp7;
reg_tmp8 = fma_s(reg_tmp8, reg_tmp11.xxxx, reg_tmp7);
reg_tmp10 = reg_tmp10 + -reg_tmp9;
reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.xxxx, reg_tmp9);
reg_tmp10 = reg_tmp10 + -reg_tmp8;
reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.yyyy, reg_tmp8);
vs_out_attr1 = reg_tmp10;
return false;
}
bool sub_4() {
reg_tmp11.z = rcp_s(reg_tmp4.x);
reg_tmp11.w = rcp_s(reg_tmp4.y);
reg_tmp11.xy = (reg_tmp1.xyyy + -reg_tmp4.zwww).xy;
reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp11.zwww)).xy;
return false;
}
bool sub_33() {
reg_tmp11.xy = (reg_tmp11.yxxx).xy;
reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
return false;
}
bool sub_34() {
reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
return false;
}
bool sub_35() {
reg_tmp11.xy = (reg_tmp11.yxxx).xy;
reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
return false;
}
bool sub_36() {
reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
return false;
}
bool sub_37() {
reg_tmp11.xy = (reg_tmp11.yxxx).xy;
reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
return false;
}
bool sub_38() {
reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
return false;
}
bool sub_39() {
reg_tmp13.xzw = (mul_s(uniforms.f[5].wxxx, reg_tmp13.xxxx)).xzw;
reg_tmp13.y = (mul_s(uniforms.f[34 + addr_regs.y].yyyy, reg_tmp13.yyyy)).y;
reg_tmp11 = fma_s(reg_tmp1, uniforms.f[5].yyxx, -reg_tmp13);
reg_tmp14 = uniforms.f[33 + addr_regs.y].wzyx;
reg_tmp1.x = dot_3(reg_tmp11.xyz, reg_tmp14.xyy);
reg_tmp1.y = dot_3(reg_tmp11.xyz, reg_tmp14.zww);
reg_tmp14 = uniforms.f[34 + addr_regs.y].wzyx;
reg_tmp1.z = dot_s(vec4(reg_tmp11.xyz, 1.0), reg_tmp14);
reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp13.xyyy).xy;
return false;
}
bool sub_40() {
reg_tmp11 = abs(vs_in_reg0.zwzw);
reg_tmp14.w = (floor(reg_tmp0.zzzz)).w;
reg_tmp14.w = (reg_tmp0.zzzz + -reg_tmp14).w;
addr_regs.xy = ivec2(reg_tmp0.zx);
reg_tmp14.w = (mul_s(uniforms.f[5].zzzz, reg_tmp14.wwww)).w;
reg_tmp14.xyz = (uniforms.f[5].yyyy).xyz;
reg_tmp7 = mul_s(uniforms.f[37 + addr_regs.y].wzyx, reg_tmp14);
reg_tmp8 = mul_s(uniforms.f[38 + addr_regs.y].wzyx, reg_tmp14);
return false;
}
bool sub_41() {
reg_tmp11 = abs(vs_in_reg0.zwzw);
addr_regs.xy = ivec2(reg_tmp0.zw);
reg_tmp7 = uniforms.f[32 + addr_regs.y].wzyx;
reg_tmp8 = uniforms.f[33 + addr_regs.y].wzyx;
return false;
}
// reference: 896F315385750974, 9EAFCF401AA96956
// shader: 8B30, 5FC81C924BE2676A
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1) - (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 183504DF3C7564E8, 5FC81C924BE2676A
// program: 9EAFCF401AA96956, B6B95AFD9466EC70, 5FC81C924BE2676A
// reference: 72D26E873BD7BAFD, 85F1FB16ACA5F40E
// reference: 650A057F39610D2F, B1A2FB9FE1A49C81
// reference: C908228F84B823FD, DE2A5A1ED4A2AB30
// reference: 49C32948FA562501, EE2F81E7863D3CB5
// reference: CEB7D732D3A1675D, 50B63AFBF2910682
// reference: C908228F411DAE99, 56190CF0B5DE64D7
// reference: FA247874E805650B, 3E49A9B642B67E23
// reference: 9AC98A88D9394A94, 335FE3A4F5DAEFBA
// reference: 0BE128AB18188E66, FA7E40A8EEC8551A
// reference: 26B95ADE0EB77221, E756489652AF30F5
// reference: 407699BD49577191, FF052BD1AB26E7D1
// reference: 2144AB2493C8C17C, DA8BA90DB05101A2
// reference: AA9712A8DAB52F14, 76FD32B6EF051669
// reference: 4568230218188E66, FA7E40A8EEC8551A
// reference: 2B44C854DDFC9CA2, 60FDEEF3BAE3EBD6
// reference: DEEB8759D0F246E3, F9387F8B7C2D9EE6
// reference: 72D26E877CC44C06, 85F1FB16ACA5F40E
// reference: 55226E4B3BD7BAFD, 85F1FB16ACA5F40E
// reference: DEEB875997E1B018, F9387F8B7C2D9EE6
// reference: 2B830ED67E72FBD4, B1A2FB9FE1A49C81
// shader: 8B30, 995ECC9F6528A122
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor0.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3CDF68A00ECBB98B, 995ECC9F6528A122
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 995ECC9F6528A122
// reference: 017FC1ADA336C4EE, C6D55AD7CCC445EA
// reference: 4FF6CA04FC532B01, 519CE5E918BFA611
// reference: 2BFB5B5387946B71, ABC54812EC5E97C2
// reference: 3C5B652E7CC44C06, 85F1FB16ACA5F40E
// shader: 8B30, A873DC2E8ED866AE
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1) - (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 183504DF415F9796, A873DC2E8ED866AE
// program: 9EAFCF401AA96956, B6B95AFD9466EC70, A873DC2E8ED866AE
// reference: E41E1901DAB52F14, 76FD32B6EF051669
// shader: 8B30, 0E73206276A851CE
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1) - (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7DE83FC92F3A67A6, 0E73206276A851CE
// program: 9EAFCF401AA96956, B6B95AFD9466EC70, 0E73206276A851CE
// reference: 074A22E1FA562501, EE2F81E7863D3CB5
// shader: 8B31, 174AFEF4CB3DDB9E

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_1();
bool sub_19();
bool sub_2();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_0();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();

bool exec_shader() {
sub_0();
return true;
}

bool sub_1() {
addr_regs.x = (ivec2(vs_in_reg0.zz)).x;
reg_tmp10 = uniforms.f[0].xxxz;
reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
reg_tmp11 = uniforms.f[0].xxxx;
reg_tmp12 = uniforms.f[0].xxxx;
reg_tmp13 = uniforms.f[0].zzzz;
reg_tmp4 = uniforms.f[0].xxxx;
reg_tmp5 = uniforms.f[0].xxxx;
return false;
}
bool sub_19() {
vs_out_attr0 = reg_tmp10;
reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
vs_out_attr1 = reg_tmp13;
reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
reg_tmp14.y = (uniforms.f[81].wwww).y;
reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
reg_tmp2.x = rcp_s(reg_tmp14.x);
reg_tmp14.z = (reg_tmp2.xxxx).z;
reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
vs_out_attr2 = reg_tmp11;
vs_out_attr3 = reg_tmp12;
return false;
}
bool sub_2() {
reg_tmp1.xyz = (uniforms.f[92].xyzz).xyz;
reg_tmp1.w = (uniforms.f[0].xxxx).w;
return false;
}
bool sub_9() {
reg_tmp2 = uniforms.f[90];
reg_tmp3 = uniforms.f[91];
reg_tmp4 = uniforms.f[92];
reg_tmp5 = uniforms.f[0].xxxz;
reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
return false;
}
bool sub_10() {
reg_tmp2.x = rcp_s(uniforms.f[81].y);
reg_tmp2.xy = (mul_s(uniforms.f[2 + addr_regs.x].zwww, reg_tmp2.xxxx)).xy;
reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
reg_tmp2.xy = (uniforms.f[2 + addr_regs.x].zwww + -reg_tmp2.xyyy).xy;
reg_tmp0.xy = (min_s(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
reg_tmp0.xy = (max_s(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
reg_tmp5.x = (uniforms.f[5 + addr_regs.x].wwww).x;
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
bool_regs.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_11();
}
bool_regs.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_12();
}
bool_regs.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_13();
}
bool_regs.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_14();
}
reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
reg_tmp4.z = (uniforms.f[83].xxxx).z;
reg_tmp4.w = (-uniforms.f[83].yyyy).w;
reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + addr_regs.x].xyyy)).xy;
reg_tmp4.z = (-uniforms.f[3 + addr_regs.x].zzzz).z;
reg_tmp4.w = (-uniforms.f[3 + addr_regs.x].wwww).w;
reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
reg_tmp11.xy = (reg_tmp5.xyyy).xy;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
reg_tmp5.x = (uniforms.f[6 + addr_regs.x].wwww).x;
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
bool_regs.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_15();
}
bool_regs.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_16();
}
bool_regs.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_17();
}
bool_regs.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_18();
}
reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
reg_tmp4.z = (uniforms.f[83].zzzz).z;
reg_tmp4.w = (-uniforms.f[83].wwww).w;
reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + addr_regs.x].xyyy)).xy;
reg_tmp4.z = (-uniforms.f[4 + addr_regs.x].zzzz).z;
reg_tmp4.w = (-uniforms.f[4 + addr_regs.x].wwww).w;
reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
reg_tmp12.xy = (reg_tmp5.xyyy).xy;
return false;
}
bool sub_11() {
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
return false;
}
bool sub_12() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
return false;
}
bool sub_13() {
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_14() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_15() {
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
return false;
}
bool sub_16() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
return false;
}
bool sub_17() {
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_18() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_0() {
sub_1();
reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
reg_tmp10.xy = (mul_s(uniforms.f[2 + addr_regs.x].xyyy, reg_tmp10.xyyy)).xy;
sub_2();
reg_tmp2.xyz = (reg_tmp1.xyzz).xyz;
reg_tmp3.xyz = (uniforms.f[6 + addr_regs.x].xyzz).xyz;
reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
if (bool_regs.x) {
sub_3();
} else {
sub_4();
}
reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp4.xyz = (mul_s(reg_tmp3.yzxx, reg_tmp2.zxyy)).xyz;
reg_tmp4.xyz = (fma_s(-reg_tmp2.yzxx, reg_tmp3.zxyy, reg_tmp4)).xyz;
reg_tmp5.x = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
if (bool_regs.x) {
sub_5();
} else {
sub_6();
}
reg_tmp4.xyz = (mul_s(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
reg_tmp5.xyz = (mul_s(reg_tmp3.yzxx, reg_tmp4.zxyy)).xyz;
reg_tmp5.xyz = (fma_s(-reg_tmp4.yzxx, reg_tmp3.zxyy, reg_tmp5)).xyz;
reg_tmp6.x = (reg_tmp4.xxxx).x;
reg_tmp6.y = (reg_tmp3.xxxx).y;
reg_tmp6.z = (reg_tmp5.xxxx).z;
reg_tmp6.w = (uniforms.f[0].xxxx).w;
reg_tmp7.x = (reg_tmp4.yyyy).x;
reg_tmp7.y = (reg_tmp3.yyyy).y;
reg_tmp7.z = (reg_tmp5.yyyy).z;
reg_tmp7.w = (uniforms.f[0].xxxx).w;
reg_tmp8.x = (reg_tmp4.zzzz).x;
reg_tmp8.y = (reg_tmp3.zzzz).y;
reg_tmp8.z = (reg_tmp5.zzzz).z;
reg_tmp8.w = (uniforms.f[0].xxxx).w;
reg_tmp9 = uniforms.f[0].xxxz;
reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
reg_tmp3.xyz = (uniforms.f[5 + addr_regs.x].xyzz).xyz;
reg_tmp3.xyz = (-uniforms.f[85].xyzz + reg_tmp3.xyzz).xyz;
reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
if (bool_regs.x) {
sub_7();
} else {
sub_8();
}
reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp10.xyz = (uniforms.f[5 + addr_regs.x].xyzz + reg_tmp2.xyzz).xyz;
reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, -uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
sub_9();
reg_tmp2 = reg_tmp10;
reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
reg_tmp2 = uniforms.f[1 + addr_regs.x];
reg_tmp3 = max_s(uniforms.f[0].xxxx, reg_tmp2);
reg_tmp2 = min_s(uniforms.f[0].zzzz, reg_tmp3);
reg_tmp13 = reg_tmp2;
sub_10();
sub_19();
return true;
}
bool sub_3() {
reg_tmp4.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_4() {
reg_tmp4.x = rsq_s(reg_tmp4.x);
return false;
}
bool sub_5() {
reg_tmp5.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_6() {
reg_tmp5.x = rsq_s(reg_tmp5.x);
return false;
}
bool sub_7() {
reg_tmp4.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_8() {
reg_tmp4.x = rsq_s(reg_tmp4.x);
return false;
}
// reference: 5C1EACCA480019B3, 174AFEF4CB3DDB9E
// shader: 8B30, C85CAF97291E3277
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FC6EE9BFD0C88432, C85CAF97291E3277
// program: 174AFEF4CB3DDB9E, D9AC2D854F4D2F3B, C85CAF97291E3277
// shader: 8B30, 6285197F9A33596C
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C8C1CF70313AEC9A, 6285197F9A33596C
// program: 174AFEF4CB3DDB9E, D9AC2D854F4D2F3B, 6285197F9A33596C
// reference: 90628CF0D0F246E3, F9387F8B7C2D9EE6
// reference: 4FF6CA04BB40DDFA, 519CE5E918BFA611
// reference: 017FC1ADFC532B01, 519CE5E918BFA611
// shader: 8B30, C970B327219E3A0A
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BB25D78818059053, C970B327219E3A0A
// program: 174AFEF4CB3DDB9E, D9AC2D854F4D2F3B, C970B327219E3A0A
// shader: 8B30, 93461E60313C558F
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 1.0, alpha_output_1 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C93B280A9DA14B62, 93461E60313C558F
// program: 174AFEF4CB3DDB9E, D9AC2D854F4D2F3B, 93461E60313C558F
// shader: 8B31, 9889EDC95D31FFC9

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_1();
bool sub_20();
bool sub_2();
bool sub_3();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_0();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();

bool exec_shader() {
sub_0();
return true;
}

bool sub_1() {
addr_regs.x = (ivec2(vs_in_reg0.zz)).x;
reg_tmp10 = uniforms.f[0].xxxz;
reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
reg_tmp11 = uniforms.f[0].xxxx;
reg_tmp12 = uniforms.f[0].xxxx;
reg_tmp13 = uniforms.f[0].zzzz;
reg_tmp4 = uniforms.f[0].xxxx;
reg_tmp5 = uniforms.f[0].xxxx;
return false;
}
bool sub_20() {
vs_out_attr0 = reg_tmp10;
reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
vs_out_attr1 = reg_tmp13;
reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
reg_tmp14.y = (uniforms.f[81].wwww).y;
reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
reg_tmp2.x = rcp_s(reg_tmp14.x);
reg_tmp14.z = (reg_tmp2.xxxx).z;
reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
vs_out_attr2 = reg_tmp11;
vs_out_attr3 = reg_tmp12;
return false;
}
bool sub_2() {
reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
reg_tmp6.w = (uniforms.f[0].xxxx).w;
reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
reg_tmp6 = min_s(uniforms.f[81].xxxx, reg_tmp6);
reg_tmp6 = max_s(-uniforms.f[81].xxxx, reg_tmp6);
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
reg_tmp4.x = (reg_tmp1.xxxx).x;
reg_tmp5.x = (reg_tmp1.yyyy).x;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
reg_tmp4.y = (reg_tmp1.xxxx).y;
reg_tmp5.y = (reg_tmp1.yyyy).y;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
reg_tmp4.z = (reg_tmp1.xxxx).z;
reg_tmp5.z = (reg_tmp1.yyyy).z;
reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
reg_tmp6.y = (reg_tmp5.zzzz).y;
reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
reg_tmp6.w = (uniforms.f[0].xxxx).w;
reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
reg_tmp7.w = (uniforms.f[0].xxxx).w;
reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
reg_tmp8.w = (uniforms.f[0].xxxx).w;
reg_tmp9 = uniforms.f[0].xxxz;
return false;
}
bool sub_3() {
reg_tmp1.xyz = (uniforms.f[92].xyzz).xyz;
reg_tmp1.w = (uniforms.f[0].xxxx).w;
return false;
}
bool sub_10() {
reg_tmp2 = uniforms.f[90];
reg_tmp3 = uniforms.f[91];
reg_tmp4 = uniforms.f[92];
reg_tmp5 = uniforms.f[0].xxxz;
reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
return false;
}
bool sub_11() {
reg_tmp2.x = rcp_s(uniforms.f[81].y);
reg_tmp2.xy = (mul_s(uniforms.f[2 + addr_regs.x].zwww, reg_tmp2.xxxx)).xy;
reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
reg_tmp2.xy = (uniforms.f[2 + addr_regs.x].zwww + -reg_tmp2.xyyy).xy;
reg_tmp0.xy = (min_s(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
reg_tmp0.xy = (max_s(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
reg_tmp5.x = (uniforms.f[5 + addr_regs.x].wwww).x;
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
bool_regs.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_12();
}
bool_regs.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_13();
}
bool_regs.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_14();
}
bool_regs.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_15();
}
reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
reg_tmp4.z = (uniforms.f[83].xxxx).z;
reg_tmp4.w = (-uniforms.f[83].yyyy).w;
reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + addr_regs.x].xyyy)).xy;
reg_tmp4.z = (-uniforms.f[3 + addr_regs.x].zzzz).z;
reg_tmp4.w = (-uniforms.f[3 + addr_regs.x].wwww).w;
reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
reg_tmp11.xy = (reg_tmp5.xyyy).xy;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
reg_tmp5.x = (uniforms.f[6 + addr_regs.x].wwww).x;
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
bool_regs.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_16();
}
bool_regs.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_17();
}
bool_regs.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_18();
}
bool_regs.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_19();
}
reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
reg_tmp4.z = (uniforms.f[83].zzzz).z;
reg_tmp4.w = (-uniforms.f[83].wwww).w;
reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + addr_regs.x].xyyy)).xy;
reg_tmp4.z = (-uniforms.f[4 + addr_regs.x].zzzz).z;
reg_tmp4.w = (-uniforms.f[4 + addr_regs.x].wwww).w;
reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
reg_tmp12.xy = (reg_tmp5.xyyy).xy;
return false;
}
bool sub_12() {
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
return false;
}
bool sub_13() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
return false;
}
bool sub_14() {
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_15() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_16() {
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
return false;
}
bool sub_17() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
return false;
}
bool sub_18() {
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_19() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_0() {
sub_1();
reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
reg_tmp10.xy = (mul_s(uniforms.f[2 + addr_regs.x].xyyy, reg_tmp10.xyyy)).xy;
reg_tmp0 = uniforms.f[7 + addr_regs.x];
sub_2();
reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
reg_tmp10 = reg_tmp2;
sub_3();
reg_tmp2.xyz = (reg_tmp1.xyzz).xyz;
reg_tmp3.xyz = (uniforms.f[6 + addr_regs.x].xyzz).xyz;
reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
if (bool_regs.x) {
sub_4();
} else {
sub_5();
}
reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp4.xyz = (mul_s(reg_tmp3.yzxx, reg_tmp2.zxyy)).xyz;
reg_tmp4.xyz = (fma_s(-reg_tmp2.yzxx, reg_tmp3.zxyy, reg_tmp4)).xyz;
reg_tmp5.x = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
if (bool_regs.x) {
sub_6();
} else {
sub_7();
}
reg_tmp4.xyz = (mul_s(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
reg_tmp5.xyz = (mul_s(reg_tmp3.yzxx, reg_tmp4.zxyy)).xyz;
reg_tmp5.xyz = (fma_s(-reg_tmp4.yzxx, reg_tmp3.zxyy, reg_tmp5)).xyz;
reg_tmp6.x = (reg_tmp4.xxxx).x;
reg_tmp6.y = (reg_tmp3.xxxx).y;
reg_tmp6.z = (reg_tmp5.xxxx).z;
reg_tmp6.w = (uniforms.f[0].xxxx).w;
reg_tmp7.x = (reg_tmp4.yyyy).x;
reg_tmp7.y = (reg_tmp3.yyyy).y;
reg_tmp7.z = (reg_tmp5.yyyy).z;
reg_tmp7.w = (uniforms.f[0].xxxx).w;
reg_tmp8.x = (reg_tmp4.zzzz).x;
reg_tmp8.y = (reg_tmp3.zzzz).y;
reg_tmp8.z = (reg_tmp5.zzzz).z;
reg_tmp8.w = (uniforms.f[0].xxxx).w;
reg_tmp9 = uniforms.f[0].xxxz;
reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
reg_tmp3.xyz = (uniforms.f[5 + addr_regs.x].xyzz).xyz;
reg_tmp3.xyz = (-uniforms.f[85].xyzz + reg_tmp3.xyzz).xyz;
reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
if (bool_regs.x) {
sub_8();
} else {
sub_9();
}
reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp10.xyz = (uniforms.f[5 + addr_regs.x].xyzz + reg_tmp2.xyzz).xyz;
reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, -uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
sub_10();
reg_tmp2 = reg_tmp10;
reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
reg_tmp2 = uniforms.f[1 + addr_regs.x];
reg_tmp3 = max_s(uniforms.f[0].xxxx, reg_tmp2);
reg_tmp2 = min_s(uniforms.f[0].zzzz, reg_tmp3);
reg_tmp13 = reg_tmp2;
sub_11();
sub_20();
return true;
}
bool sub_4() {
reg_tmp4.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_5() {
reg_tmp4.x = rsq_s(reg_tmp4.x);
return false;
}
bool sub_6() {
reg_tmp5.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_7() {
reg_tmp5.x = rsq_s(reg_tmp5.x);
return false;
}
bool sub_8() {
reg_tmp4.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_9() {
reg_tmp4.x = rsq_s(reg_tmp4.x);
return false;
}
// reference: 5C1EACCA2BCFF7E0, 9889EDC95D31FFC9
// shader: 8B30, F5A8D3B4515BD238
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0C60AAA6F9F7F8FB, F5A8D3B4515BD238
// program: 9889EDC95D31FFC9, D9AC2D854F4D2F3B, F5A8D3B4515BD238
// shader: 8B30, 3188E4465A9664CF
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 1.0, alpha_output_1 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2DE6C6797C5323CA, 3188E4465A9664CF
// program: 9889EDC95D31FFC9, D9AC2D854F4D2F3B, 3188E4465A9664CF
// shader: 8B30, EAB8FB1F001F732A
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 1.0, alpha_output_1 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1) - (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1A6944432F355ED2, EAB8FB1F001F732A
// program: 9EAFCF401AA96956, B6B95AFD9466EC70, EAB8FB1F001F732A
// reference: 2BFB5B53C0879D8A, ABC54812EC5E97C2
// shader: 8B30, 58274098246417E9
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1) - (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: DF32C6EF4B63ED4B, 58274098246417E9
// program: 9EAFCF401AA96956, B6B95AFD9466EC70, 58274098246417E9
// reference: D4408121D9394A94, 335FE3A4F5DAEFBA
// shader: 8B31, 6B7C305F63AF4E6E

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_1();
bool sub_15();
bool sub_2();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_0();
bool sub_3();
bool sub_4();

bool exec_shader() {
sub_0();
return true;
}

bool sub_1() {
addr_regs.x = (ivec2(vs_in_reg0.zz)).x;
reg_tmp10 = uniforms.f[0].xxxz;
reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
reg_tmp11 = uniforms.f[0].xxxx;
reg_tmp12 = uniforms.f[0].xxxx;
reg_tmp13 = uniforms.f[0].zzzz;
reg_tmp4 = uniforms.f[0].xxxx;
reg_tmp5 = uniforms.f[0].xxxx;
return false;
}
bool sub_15() {
vs_out_attr0 = reg_tmp10;
reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
vs_out_attr1 = reg_tmp13;
reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
reg_tmp14.y = (uniforms.f[81].wwww).y;
reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
reg_tmp2.x = rcp_s(reg_tmp14.x);
reg_tmp14.z = (reg_tmp2.xxxx).z;
reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
vs_out_attr2 = reg_tmp11;
vs_out_attr3 = reg_tmp12;
return false;
}
bool sub_2() {
reg_tmp6.x = (uniforms.f[90].xxxx).x;
reg_tmp6.y = (uniforms.f[91].xxxx).y;
reg_tmp6.z = (uniforms.f[92].xxxx).z;
reg_tmp6.w = (uniforms.f[0].xxxx).w;
reg_tmp7.x = (uniforms.f[90].yyyy).x;
reg_tmp7.y = (uniforms.f[91].yyyy).y;
reg_tmp7.z = (uniforms.f[92].yyyy).z;
reg_tmp7.w = (uniforms.f[0].xxxx).w;
reg_tmp8.x = (uniforms.f[90].zzzz).x;
reg_tmp8.y = (uniforms.f[91].zzzz).y;
reg_tmp8.z = (uniforms.f[92].zzzz).z;
reg_tmp8.w = (uniforms.f[0].xxxx).w;
reg_tmp9.x = (uniforms.f[90].wwww).x;
reg_tmp9.y = (uniforms.f[91].wwww).y;
reg_tmp9.z = (uniforms.f[92].wwww).z;
reg_tmp9.w = (uniforms.f[0].zzzz).w;
return false;
}
bool sub_5() {
reg_tmp2 = uniforms.f[90];
reg_tmp3 = uniforms.f[91];
reg_tmp4 = uniforms.f[92];
reg_tmp5 = uniforms.f[0].xxxz;
reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
return false;
}
bool sub_6() {
reg_tmp2.x = rcp_s(uniforms.f[81].y);
reg_tmp2.xy = (mul_s(uniforms.f[2 + addr_regs.x].zwww, reg_tmp2.xxxx)).xy;
reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
reg_tmp2.xy = (uniforms.f[2 + addr_regs.x].zwww + -reg_tmp2.xyyy).xy;
reg_tmp0.xy = (min_s(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
reg_tmp0.xy = (max_s(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
reg_tmp5.x = (uniforms.f[5 + addr_regs.x].wwww).x;
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
bool_regs.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_7();
}
bool_regs.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_8();
}
bool_regs.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_9();
}
bool_regs.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_10();
}
reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
reg_tmp4.z = (uniforms.f[83].xxxx).z;
reg_tmp4.w = (-uniforms.f[83].yyyy).w;
reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + addr_regs.x].xyyy)).xy;
reg_tmp4.z = (-uniforms.f[3 + addr_regs.x].zzzz).z;
reg_tmp4.w = (-uniforms.f[3 + addr_regs.x].wwww).w;
reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
reg_tmp11.xy = (reg_tmp5.xyyy).xy;
reg_tmp2 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp2 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
reg_tmp5.x = (uniforms.f[6 + addr_regs.x].wwww).x;
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
bool_regs.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_11();
}
bool_regs.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_12();
}
bool_regs.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_13();
}
bool_regs.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
bool_regs.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
if (bool_regs.x) {
sub_14();
}
reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
reg_tmp4.z = (uniforms.f[83].zzzz).z;
reg_tmp4.w = (-uniforms.f[83].wwww).w;
reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + addr_regs.x].xyyy)).xy;
reg_tmp4.z = (-uniforms.f[4 + addr_regs.x].zzzz).z;
reg_tmp4.w = (-uniforms.f[4 + addr_regs.x].wwww).w;
reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
reg_tmp12.xy = (reg_tmp5.xyyy).xy;
return false;
}
bool sub_7() {
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
return false;
}
bool sub_8() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
return false;
}
bool sub_9() {
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_10() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_11() {
reg_tmp14.x = (vs_in_reg0.xxxx).x;
reg_tmp14.y = (vs_in_reg0.yyyy).y;
return false;
}
bool sub_12() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
return false;
}
bool sub_13() {
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_14() {
reg_tmp14.x = (-vs_in_reg0.xxxx).x;
reg_tmp14.y = (-vs_in_reg0.yyyy).y;
return false;
}
bool sub_0() {
sub_1();
reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
reg_tmp10.xy = (mul_s(uniforms.f[2 + addr_regs.x].xyyy, reg_tmp10.xyyy)).xy;
sub_2();
reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
reg_tmp3.xyz = (uniforms.f[5 + addr_regs.x].xyzz).xyz;
reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
if (bool_regs.x) {
sub_3();
} else {
sub_4();
}
reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp10.xyz = (uniforms.f[5 + addr_regs.x].xyzz + reg_tmp2.xyzz).xyz;
reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
sub_5();
reg_tmp2 = reg_tmp10;
reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
reg_tmp2 = uniforms.f[1 + addr_regs.x];
reg_tmp3 = max_s(uniforms.f[0].xxxx, reg_tmp2);
reg_tmp2 = min_s(uniforms.f[0].zzzz, reg_tmp3);
reg_tmp13 = reg_tmp2;
sub_6();
sub_15();
return true;
}
bool sub_3() {
reg_tmp4.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_4() {
reg_tmp4.x = rsq_s(reg_tmp4.x);
return false;
}
// reference: 2BC49DCEAA0789EF, 6B7C305F63AF4E6E
// program: 6B7C305F63AF4E6E, D9AC2D854F4D2F3B, 93461E60313C558F
// program: 6B7C305F63AF4E6E, D9AC2D854F4D2F3B, F5A8D3B4515BD238
// shader: 8B30, 6FCA7D04D2D833F6
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.aaa) - (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1) - (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 31B942CCAB8A40C9, 6FCA7D04D2D833F6
// program: 9EAFCF401AA96956, B6B95AFD9466EC70, 6FCA7D04D2D833F6
// shader: 8B30, 82A8A0A566A2F085
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.aaa) - (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1) - (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 546479DAC5EFB0F9, 82A8A0A566A2F085
// program: 9EAFCF401AA96956, B6B95AFD9466EC70, 82A8A0A566A2F085
// reference: 803EDC9B94B291A6, 50B63AFBF2910682
// reference: 803EDC9BD3A1675D, 50B63AFBF2910682
// reference: 6B2B3494C3047916, 9FF74197F44C3422
// reference: 6B2B349484178FED, 9FF74197F44C3422
// reference: 2B830ED639610D2F, B1A2FB9FE1A49C81
// reference: 87812926060E5862, 56190CF0B5DE64D7
// shader: 8B31, 2B023264C0CB680F

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_2();
bool sub_5();
bool sub_1();
bool sub_7();
bool sub_6();
bool sub_0();
bool sub_3();
bool sub_4();

bool exec_shader() {
sub_0();
return true;
}

bool sub_2() {
reg_tmp1.xyz = (uniforms.f[92].xyzz).xyz;
reg_tmp1.w = (uniforms.f[0].xxxx).w;
return false;
}
bool sub_5() {
reg_tmp2 = uniforms.f[90];
reg_tmp3 = uniforms.f[91];
reg_tmp4 = uniforms.f[92];
reg_tmp5 = uniforms.f[0].xxxz;
reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
return false;
}
bool sub_1() {
addr_regs.x = (ivec2(vs_in_reg0.xx)).x;
reg_tmp10 = uniforms.f[0].xxxz;
reg_tmp10.xyz = (uniforms.f[1 + addr_regs.x].xyzz).xyz;
reg_tmp11 = uniforms.f[0].xxxx;
reg_tmp11.xy = (uniforms.f[4 + addr_regs.x].xyyy).xy;
reg_tmp12 = uniforms.f[0].xxxx;
reg_tmp12.xy = (uniforms.f[4 + addr_regs.x].xyyy).xy;
reg_tmp13 = uniforms.f[0].zzzz;
reg_tmp2 = uniforms.f[0].xxxx;
reg_tmp3 = uniforms.f[0].xxxx;
reg_tmp4 = uniforms.f[0].xxxx;
return false;
}
bool sub_7() {
vs_out_attr0 = reg_tmp10;
vs_out_attr1 = reg_tmp13;
reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
reg_tmp14.y = (uniforms.f[75].wwww).y;
reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
reg_tmp2.x = rcp_s(reg_tmp14.x);
reg_tmp14.z = (reg_tmp2.xxxx).z;
reg_tmp3.xy = (uniforms.f[75].wwww + reg_tmp11.xyyy).xy;
reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
reg_tmp11.xy = (-uniforms.f[75].wwww + reg_tmp4.xyyy).xy;
reg_tmp3.xy = (uniforms.f[75].wwww + reg_tmp12.xyyy).xy;
reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
reg_tmp12.xy = (-uniforms.f[75].wwww + reg_tmp4.xyyy).xy;
vs_out_attr2 = reg_tmp11;
vs_out_attr3 = reg_tmp12;
return false;
}
bool sub_6() {
reg_tmp14.z = (uniforms.f[78].zzzz).z;
reg_tmp14.w = (uniforms.f[79].zzzz).w;
reg_tmp2.x = rcp_s(uniforms.f[75].y);
reg_tmp2.xy = (mul_s(reg_tmp14.zwww, reg_tmp2.xxxx)).xy;
reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
reg_tmp2.xy = (mul_s(uniforms.f[75].yyyy, reg_tmp3.xyyy)).xy;
reg_tmp2.xy = (reg_tmp14.zwww + -reg_tmp2.xyyy).xy;
reg_tmp0.xy = (min_s(uniforms.f[75].xxxx, reg_tmp2.xyyy)).xy;
reg_tmp0.xy = (max_s(-uniforms.f[75].xxxx, reg_tmp0.xyyy)).xy;
reg_tmp4 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp4.xyyy, reg_tmp4.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp4 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp4.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp4.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
reg_tmp4 = uniforms.f[4 + addr_regs.x].xxyy;
reg_tmp4 = -uniforms.f[0].yyyy + reg_tmp4;
reg_tmp4 = mul_s(reg_tmp4, reg_tmp1.xyyx);
reg_tmp11.xy = (reg_tmp4.xyyy + reg_tmp4.zwww).xy;
reg_tmp5.xy = (uniforms.f[78].xyyy).xy;
reg_tmp11.xy = (fma_s(reg_tmp11.xyyy, reg_tmp5.xyyy, uniforms.f[77].xyyy)).xy;
reg_tmp11.xy = (uniforms.f[0].yyyy + reg_tmp11.xyyy).xy;
reg_tmp4 = uniforms.f[95];
reg_tmp3 = uniforms.f[94];
reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp4.xyyy, reg_tmp4.zwww)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
reg_tmp4 = uniforms.f[93];
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp4.xyyy)).xy;
reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp4.zwww)).xy;
reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
reg_tmp4 = uniforms.f[4 + addr_regs.x].zzww;
reg_tmp4 = -uniforms.f[0].yyyy + reg_tmp4;
reg_tmp4 = mul_s(reg_tmp4, reg_tmp1.xyyx);
reg_tmp12.xy = (reg_tmp4.xyyy + reg_tmp4.zwww).xy;
reg_tmp5.xy = (uniforms.f[79].xyyy).xy;
reg_tmp12.xy = (fma_s(reg_tmp12.xyyy, reg_tmp5.xyyy, uniforms.f[77].zwww)).xy;
reg_tmp12.xy = (uniforms.f[0].yyyy + reg_tmp12.xyyy).xy;
return false;
}
bool sub_0() {
sub_1();
sub_2();
reg_tmp2 = reg_tmp1;
reg_tmp3.xyz = (mul_s(-uniforms.f[2 + addr_regs.x].yzxx, reg_tmp2.zxyy)).xyz;
reg_tmp3.xyz = (fma_s(reg_tmp2.yzxx, uniforms.f[2 + addr_regs.x].zxyy, reg_tmp3)).xyz;
reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
reg_tmp4.x = rsq_s(reg_tmp4.x);
reg_tmp4.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp4.xyz = (mul_s(uniforms.f[3 + addr_regs.x].wwww, reg_tmp4.xyzz)).xyz;
reg_tmp4.xyz = (mul_s(uniforms.f[0].yyyy, reg_tmp4.xyzz)).xyz;
reg_tmp10.xyz = (reg_tmp10.xyzz + -reg_tmp4.xyzz).xyz;
sub_2();
reg_tmp3 = reg_tmp1;
reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
bool_regs.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
bool_regs.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
if (bool_regs.x) {
sub_3();
} else {
sub_4();
}
reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[76].zzzz, reg_tmp10.xyzz)).xyz;
sub_5();
reg_tmp2 = reg_tmp10;
reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
reg_tmp2 = uniforms.f[80];
reg_tmp2.w = (mul_s(uniforms.f[1 + addr_regs.x].wwww, reg_tmp2.wwww)).w;
reg_tmp3 = max_s(uniforms.f[0].xxxx, reg_tmp2);
reg_tmp2 = min_s(uniforms.f[0].zzzz, reg_tmp3);
reg_tmp13 = reg_tmp2;
sub_6();
sub_7();
return true;
}
bool sub_3() {
reg_tmp4.x = (uniforms.f[0].zzzz).x;
return false;
}
bool sub_4() {
reg_tmp4.x = rsq_s(reg_tmp4.x);
return false;
}
// reference: 38430F892853A06C, 2B023264C0CB680F
// shader: 8B30, 472E3AD85527FB1E
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C93C3968F9F7F8FB, 472E3AD85527FB1E
// program: 2B023264C0CB680F, D9AC2D854F4D2F3B, 472E3AD85527FB1E
// reference: 6806CAC8BB40DDFA, 519CE5E918BFA611
// shader: 8B30, 883C0E899CD69573
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 1.0, alpha_output_1 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BB22C6EA7C5323CA, 883C0E899CD69573
// program: 2043B1F9BC437834, D9AC2D854F4D2F3B, 883C0E899CD69573
// program: 2043B1F9BC437834, D9AC2D854F4D2F3B, 472E3AD85527FB1E
// program: 174AFEF4CB3DDB9E, D9AC2D854F4D2F3B, 472E3AD85527FB1E
// shader: 8B30, C23151DEE8E28AA2
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 1.0, alpha_output_1 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0C67BBC49DA14B62, C23151DEE8E28AA2
// program: 2043B1F9BC437834, D9AC2D854F4D2F3B, C23151DEE8E28AA2
// program: 174AFEF4CB3DDB9E, D9AC2D854F4D2F3B, 472E3AD88253EEDC
// reference: 87812926411DAE99, 56190CF0B5DE64D7
// shader: 8B30, 9DE9D6F4D4229729
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(light_vector, normal), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(light_vector, normal), 0.0))) * light_src[1].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((secondary_fragment_color.aaa) * (texcolor0.rrr) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BB1C19A9383FA24D, 9DE9D6F4D4229729
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 9DE9D6F4D4229729
// shader: 8B30, C23151DE4EE1951F
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 1.0, alpha_output_1 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8F8DE0259DA14B62, C23151DE4EE1951F
// program: 174AFEF4CB3DDB9E, D9AC2D854F4D2F3B, C23151DE4EE1951F
// reference: 0C0B5B9F63F56BE8, ABC54812EC5E97C2
// reference: BB1C19A97F2C54B6, 9DE9D6F4D4229729
// program: 6B7C305F63AF4E6E, D9AC2D854F4D2F3B, 472E3AD85527FB1E
// reference: 9CEC19657F2C54B6, 9DE9D6F4D4229729
// reference: D26512CC383FA24D, 9DE9D6F4D4229729
// program: 6B7C305F63AF4E6E, D9AC2D854F4D2F3B, 472E3AD88253EEDC
// program: 6B7C305F63AF4E6E, D9AC2D854F4D2F3B, C23151DE4EE1951F
// reference: 4282503624E69D13, ABC54812EC5E97C2
// shader: 8B30, 3BDE586E91E5FE92
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AE84789D904B50EC, 3BDE586E91E5FE92
// program: 174AFEF4CB3DDB9E, D9AC2D854F4D2F3B, 3BDE586E91E5FE92
// program: 6B7C305F63AF4E6E, D9AC2D854F4D2F3B, 3BDE586E91E5FE92
// shader: 8B30, 266E533C415DF9ED
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 1.0, alpha_output_1 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6BDFFA31F41DE375, 266E533C415DF9ED
// program: 174AFEF4CB3DDB9E, D9AC2D854F4D2F3B, 266E533C415DF9ED
// program: 6B7C305F63AF4E6E, D9AC2D854F4D2F3B, 266E533C415DF9ED
// reference: 65CDC3FDDDFC9CA2, 60FDEEF3BAE3EBD6
// reference: FE3712417AD13CC9, 3BDE586E91E5FE92
// reference: F59512007F2C54B6, 9DE9D6F4D4229729
// shader: 8B30, 96F0ABF6A4743798
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5BE8DD3245AA4ED0, 96F0ABF6A4743798
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 96F0ABF6A4743798
// reference: D26512CC7F2C54B6, 9DE9D6F4D4229729
// program: 174AFEF4CB3DDB9E, D9AC2D854F4D2F3B, 883C0E899CD69573
// program: 6B7C305F63AF4E6E, D9AC2D854F4D2F3B, 883C0E899CD69573
// program: 2043B1F9BC437834, D9AC2D854F4D2F3B, C23151DE4EE1951F
// shader: 8B30, 1FBE26CC7E3738F0
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) + (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb) + (texcolor0.rgb) * (vec3(1) - (texcolor1.rgb)), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((secondary_fragment_color.rgb) * (secondary_fragment_color.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp(min((const_color[4].rgb) + (rounded_primary_color.rgb), vec3(1)) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 82E0B00EE8405E82, 1FBE26CC7E3738F0
// program: 25474969E3E91F82, F777123A8C3D5E20, 1FBE26CC7E3738F0
// shader: 8B30, 9BB58F80D792665B
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((secondary_fragment_color.rgb) * (secondary_fragment_color.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 954E3C497C5561B9, 9BB58F80D792665B
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 9BB58F80D792665B
// program: A6FB5CB53EA51ED8, C8DF8CC87A4E8CE6, 9BB58F80D792665B
// reference: 954E3C493B469742, 9BB58F80D792665B
// shader: 8B30, 8833B5CFEBD4CC77
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texture(tex_cube, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texture(tex_cube, vec3(texcoord0, texcoord0_w)).rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 49C329486C9AF0DD, 8833B5CFEBD4CC77
// program: 25474969E3E91F82, F777123A8C3D5E20, 8833B5CFEBD4CC77
// shader: 8B30, DE22ACC13529C97C
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor2.rgb) * (vec3(1) - texcolor1.aaa) + (texcolor1.rgb) * (vec3(1) - (vec3(1) - texcolor1.aaa)), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((secondary_fragment_color.rgb) * (secondary_fragment_color.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9F91A377447B0372, DE22ACC13529C97C
// program: 5593DF1E36F9D5E0, EADA2116091C5E01, DE22ACC13529C97C
// reference: 9F91A3770368F589, DE22ACC13529C97C
// reference: CC69BBA7AF53A879, 1FBE26CC7E3738F0
// reference: CC69BBA721111947, 1FBE26CC7E3738F0
// shader: 8B30, 1BDA5D975738EF06
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(normal, normalize(half_vector)))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(normal, normalize(half_vector)))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((texcolor0.aaa) * (vec3(1) - secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6C6AA1868B934E83, 1BDA5D975738EF06
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 1BDA5D975738EF06
// shader: 8B30, 491D04EA56D21D39
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp(min((const_color[2].rgb) + (rounded_primary_color.rgb), vec3(1)) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 415AE2743F665088, 491D04EA56D21D39
// program: 25474969E3E91F82, F777123A8C3D5E20, 491D04EA56D21D39
// shader: 8B30, 7DA59F281C4D0829
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp(min((const_color[3].rgb) + (rounded_primary_color.rgb), vec3(1)) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 37F92428D8FE4314, 7DA59F281C4D0829
// program: 25474969E3E91F82, F777123A8C3D5E20, 7DA59F281C4D0829
// shader: 8B30, 0DFF3EE50D9F7C67
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp(min((const_color[2].rgb) + (rounded_primary_color.rgb), vec3(1)) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 41998EA10CDB3AF2, 0DFF3EE50D9F7C67
// program: 25474969E3E91F82, F777123A8C3D5E20, 0DFF3EE50D9F7C67
// shader: 8B31, 7B4FF07FB7BDE950

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=7) in vec4 vs_in_reg7;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_1();
bool sub_2();
bool sub_3();
bool sub_4();
bool sub_6();
bool sub_7();
bool sub_17();
bool sub_5();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_28();
bool sub_27();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_0();

bool exec_shader() {
sub_0();
return true;
}

bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_2();
} else {
sub_3();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_4();
} else {
sub_6();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_2() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_3() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_4() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_5();
return false;
}
bool sub_6() {
if (all(bool_regs)) {
sub_7();
} else {
sub_17();
}
return false;
}
bool sub_7() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_8();
return false;
}
bool sub_17() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_5() {
uint jmp_to = 73u;
while (true) {
switch (jmp_to) {
case 73u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 89u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 89u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 89u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_8() {
uint jmp_to = 90u;
while (true) {
switch (jmp_to) {
case 90u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 165u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 127u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 165u; break;
}
case 127u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_9();
} else {
sub_14();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 165u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_9() {
if (bool_regs.y) {
sub_10();
} else {
sub_11();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_10() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_11() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_12();
} else {
sub_13();
}
return false;
}
bool sub_12() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_14() {
if (bool_regs.y) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_18() {
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9 = uniforms.f[21];
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (bool_regs.y) {
sub_19();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_19() {
if (uniforms.b[7]) {
sub_20();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_20() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_21() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_22();
} else {
sub_23();
}
return false;
}
bool sub_22() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_23() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_24();
} else {
sub_25();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_24() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_25() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_26();
} else {
sub_28();
}
return false;
}
bool sub_26() {
sub_27();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_28() {
sub_29();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_27() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_29() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_30() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_31();
} else {
sub_32();
}
return false;
}
bool sub_31() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_32() {
if (uniforms.b[13]) {
sub_33();
} else {
sub_36();
}
return false;
}
bool sub_33() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_34();
} else {
sub_35();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_34() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_35() {
sub_29();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_36() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_0() {
sub_1();
sub_18();
sub_21();
sub_30();
return true;
}
// reference: C22707A8E70B0634, 7B4FF07FB7BDE950
// shader: 8B30, 1F56C1FA06102ADF
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(normal, normalize(half_vector)))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(normal, normalize(half_vector)))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp(min((const_color[0].rgb) + (rounded_primary_color.rgb), vec3(1)) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor1.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((vec3(1) - secondary_fragment_color.rgb) * (texcolor0.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1DCF09E81A44E06A, 1F56C1FA06102ADF
// program: 7B4FF07FB7BDE950, F777123A8C3D5E20, 1F56C1FA06102ADF
// shader: 8B30, B0DC1D8544DFAE24
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) * geo_factor) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) * geo_factor) + (refl_value * light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((texcolor1.rgb) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CAEF315C62874DC5, B0DC1D8544DFAE24
// program: 25474969E3E91F82, F777123A8C3D5E20, B0DC1D8544DFAE24
// shader: 8B30, 22EEA0B271FA4D18
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(normal, normalize(half_vector)))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(normal, normalize(half_vector)))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0 * 4.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor0.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B914E11839797B79, 22EEA0B271FA4D18
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 22EEA0B271FA4D18
// shader: 8B30, 90CF8BE9928F125F
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(normal, normalize(half_vector)))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(normal, normalize(half_vector)))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb) + (texcolor0.bbb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp(min((const_color[2].rgb) + (texcolor2.aaa), vec3(1)) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor0.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2B2BAF9A0CDA7832, 90CF8BE9928F125F
// program: 64A15DE7F2BB2A3E, EADA2116091C5E01, 90CF8BE9928F125F
// shader: 8B30, D3E4FA73144AADED
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor0.rgb) + (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb) + (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (rounded_primary_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7C4497D0D4AF78C4, D3E4FA73144AADED
// program: 5593DF1E36F9D5E0, EADA2116091C5E01, D3E4FA73144AADED
// shader: 8B30, 5898BC84B4CEB3F4
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((secondary_fragment_color.rgb) * (secondary_fragment_color.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: DBC737E0ACAACE91, 5898BC84B4CEB3F4
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 5898BC84B4CEB3F4
// reference: 954E3C49ACAACE91, 5898BC84B4CEB3F4
// shader: 8B30, 000EC7623C5957F5
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) * geo_factor) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) * geo_factor) + (refl_value * light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((texcolor1.rgb) * (vec3(1) - secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((texcolor1.rgb) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 272D0E8E99DD4610, 000EC7623C5957F5
// program: 25474969E3E91F82, F777123A8C3D5E20, 000EC7623C5957F5
// shader: 8B30, E4EB0A5B1E28C922
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) * geo_factor) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
geo_factor = dot(half_vector, half_vector);
geo_factor = geo_factor == 0.0 ? 0.0 : min(dot_product / geo_factor, 1.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) * geo_factor) + (refl_value * light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp(min((const_color[0].rgb) + (texcolor0.rgb), vec3(1)) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((texcolor1.rgb) * (vec3(1) - secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 917B8FA695EFD41D, E4EB0A5B1E28C922
// program: 25474969E3E91F82, F777123A8C3D5E20, E4EB0A5B1E28C922
// shader: 8B30, 85E382EB92EE1B2A
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp(min((texcolor0.rgb) + (secondary_fragment_color.rgb), vec3(1)) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3F06249C39F60244, 85E382EB92EE1B2A
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 85E382EB92EE1B2A
// shader: 8B30, 96FED536726DB2A6
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 14B4781C3D0FC3F5, 96FED536726DB2A6
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 96FED536726DB2A6
// shader: 8B30, D31FFC1AD41FA067
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (rounded_primary_color.rgb);
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 01F36D6FD0FC1C7C, D31FFC1AD41FA067
// program: 7145BC773338A58F, 58F5ACF9B36D7DF3, D31FFC1AD41FA067
// shader: 8B30, A40CBEB1DD480945
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) + (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B5C40DD50ECBB98B, A40CBEB1DD480945
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, A40CBEB1DD480945
// shader: 8B30, 619D9CC45EDEE2AA
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5BE8DD329BC5BDB4, 619D9CC45EDEE2AA
// program: 7145BC773338A58F, 58F5ACF9B36D7DF3, 619D9CC45EDEE2AA
// shader: 8B30, 82DA1593931FC290
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (rounded_primary_color.rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 01F36D6FFA7F4366, 82DA1593931FC290
// program: 7145BC773338A58F, 58F5ACF9B36D7DF3, 82DA1593931FC290
// shader: 8B30, B619AF832AB14BAC
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((vec3(1) - secondary_fragment_color.rgb) * (vec3(1) - last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (vec3(1) - last_tex_env_out.rgb);
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 84D5158A5CCDCD47, B619AF832AB14BAC
// program: 7145BC773338A58F, 58F5ACF9B36D7DF3, B619AF832AB14BAC
// shader: 8B30, 23EEED15BA9D9C7C
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = byteround(clamp((1.0 - rounded_primary_color.r) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 40E00ECC72CEA488, 23EEED15BA9D9C7C
// program: 7145BC773338A58F, 58F5ACF9B36D7DF3, 23EEED15BA9D9C7C
// reference: F5951200383FA24D, 9DE9D6F4D4229729
// shader: 8B30, DE5EE790FFAB1C66
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6F47FBFD39F70540, DE5EE790FFAB1C66
// program: 7145BC773338A58F, 58F5ACF9B36D7DF3, DE5EE790FFAB1C66
// reference: A510B0C2AF53A879, 1FBE26CC7E3738F0
// reference: CC69BBA7E8405E82, 1FBE26CC7E3738F0
// reference: 0FD3E9DD3F665088, 491D04EA56D21D39
// reference: 22E3AA2F8B934E83, 1BDA5D975738EF06
// reference: CC69BBA76602EFBC, 1FBE26CC7E3738F0
// reference: 82E0B00E6602EFBC, 1FBE26CC7E3738F0
// reference: 37F924289FEDB5EF, 7DA59F281C4D0829
// reference: 41998EA14BC8CC09, 0DFF3EE50D9F7C67
// reference: 272D0E8EDECEB0EB, 000EC7623C5957F5
// reference: 79702F819FEDB5EF, 7DA59F281C4D0829
// reference: DBC737E03B469742, 9BB58F80D792665B
// reference: 82E0B00E21111947, 1FBE26CC7E3738F0
// reference: 82E0B00EAF53A879, 1FBE26CC7E3738F0
// reference: 2B2BAF9A4BC98EC9, 90CF8BE9928F125F
// reference: 074A22E1BD45D3FA, EE2F81E7863D3CB5
// reference: 6C6AA186CC80B878, 1BDA5D975738EF06
// reference: 415AE2747875A673, 491D04EA56D21D39
// reference: 917B8FA6D2FC22E6, E4EB0A5B1E28C922
// reference: 3F06249C7EE5F4BF, 85E382EB92EE1B2A
// reference: D118A8DE0368F589, DE22ACC13529C97C
// reference: 65A2A4330CDA7832, 90CF8BE9928F125F
// reference: 074A22E16C9AF0DD, 8833B5CFEBD4CC77
// reference: CAEF315C2594BB3E, B0DC1D8544DFAE24
// reference: 7C4497D093BC8E3F, D3E4FA73144AADED
// reference: 0F1085080CDB3AF2, 0DFF3EE50D9F7C67
// reference: B914E1187E6A8D82, 22EEA0B271FA4D18
// reference: 32CD9C79D4AF78C4, D3E4FA73144AADED
// reference: 1DCF09E85D571691, 1F56C1FA06102ADF
// reference: F79DEAB139797B79, 22EEA0B271FA4D18
// reference: 69A40527DECEB0EB, 000EC7623C5957F5
// reference: DBC737E07C5561B9, 9BB58F80D792665B
// reference: 954E3C49EBB9386A, 5898BC84B4CEB3F4
// reference: DBC737E0EBB9386A, 5898BC84B4CEB3F4
// reference: 22E3AA2FCC80B878, 1BDA5D975738EF06
// shader: 8B30, EF3DB1AB3C4847CA
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FD931FA718059053, EF3DB1AB3C4847CA
// program: 6B7C305F63AF4E6E, D9AC2D854F4D2F3B, EF3DB1AB3C4847CA
// program: 9889EDC95D31FFC9, D9AC2D854F4D2F3B, C23151DEE8E28AA2
// reference: D118A8DE447B0372, DE22ACC13529C97C
// reference: 074A22E12B890626, 8833B5CFEBD4CC77
// shader: 8B30, 323CCB4A7C3300A2
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 07FB64C69B235461, 323CCB4A7C3300A2
// program: 6B7C305F63AF4E6E, D9AC2D854F4D2F3B, 323CCB4A7C3300A2
// shader: 8B30, 806D4C81415DF9ED
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 1.0, alpha_output_1 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((vec3(1) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F60FC0A51E878F50, 806D4C81415DF9ED
// program: 9889EDC95D31FFC9, D9AC2D854F4D2F3B, 806D4C81415DF9ED
// program: 174AFEF4CB3DDB9E, D9AC2D854F4D2F3B, 323CCB4A7C3300A2
// reference: E41E19019DA6D9EF, 76FD32B6EF051669
// reference: 49C329482B890626, 8833B5CFEBD4CC77
// reference: 65A2A4334BC98EC9, 90CF8BE9928F125F
// reference: 0F1085084BC8CC09, 0DFF3EE50D9F7C67
// reference: 84663AF562874DC5, B0DC1D8544DFAE24
// reference: 0FD3E9DD7875A673, 491D04EA56D21D39
// reference: DFF2840FD2FC22E6, E4EB0A5B1E28C922
// reference: 69A4052799DD4610, 000EC7623C5957F5
// reference: 79702F81D8FE4314, 7DA59F281C4D0829
// program: 174AFEF4CB3DDB9E, D9AC2D854F4D2F3B, EF3DB1AB3C4847CA
// shader: 8B30, 44007532698940E0
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((secondary_fragment_color.rgb) * (secondary_fragment_color.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp(min((const_color[2].rgb) + (rounded_primary_color.rgb), vec3(1)) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 017FC1ADDAFA2328, 44007532698940E0
// program: A6FB5CB53EA51ED8, C8DF8CC87A4E8CE6, 44007532698940E0
// shader: 8B30, 6B6B59109AAD00C3
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((secondary_fragment_color.rgb) * (secondary_fragment_color.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp(min((const_color[2].rgb) + (rounded_primary_color.rgb), vec3(1)) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5858B21EBB40DDFA, 6B6B59109AAD00C3
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 6B6B59109AAD00C3
// shader: 8B31, EDC7E01CE0E1CD5B

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_20();
bool sub_3();
bool sub_8();
bool sub_1();
bool sub_2();
bool sub_4();
bool sub_6();
bool sub_7();
bool sub_9();
bool sub_19();
bool sub_21();
bool sub_5();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_32();
bool sub_31();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_44();
bool sub_45();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
sub_22();
sub_25();
sub_34();
sub_41();
return true;
}
bool sub_20() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_3() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_8() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_2();
} else {
sub_6();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_2() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_3();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_3();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_3();
}
if (uniforms.b[8]) {
sub_4();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_5();
return false;
}
bool sub_4() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_3();
}
return false;
}
bool sub_6() {
if (all(bool_regs)) {
sub_7();
} else {
sub_19();
}
return false;
}
bool sub_7() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_8();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_8();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_8();
}
if (uniforms.b[8]) {
sub_9();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_10();
return false;
}
bool sub_9() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_8();
}
return false;
}
bool sub_19() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_20();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_20();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_20();
}
if (uniforms.b[8]) {
sub_21();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_21() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_20();
}
return false;
}
bool sub_5() {
uint jmp_to = 139u;
while (true) {
switch (jmp_to) {
case 139u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 155u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 155u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 155u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_10() {
uint jmp_to = 156u;
while (true) {
switch (jmp_to) {
case 156u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[3]) {
jmp_to = 231u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 193u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 231u; break;
}
case 193u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_11();
} else {
sub_16();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 231u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
if (bool_regs.y) {
sub_12();
} else {
sub_13();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_12() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_13() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_14();
} else {
sub_15();
}
return false;
}
bool sub_14() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_15() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_16() {
if (bool_regs.y) {
sub_17();
} else {
sub_18();
}
return false;
}
bool sub_17() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_22() {
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9 = uniforms.f[21];
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (bool_regs.y) {
sub_23();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_23() {
if (uniforms.b[7]) {
sub_24();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_24() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_25() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_26();
} else {
sub_27();
}
return false;
}
bool sub_26() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_27() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_28();
} else {
sub_29();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_28() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_29() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_30();
} else {
sub_32();
}
return false;
}
bool sub_30() {
sub_31();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_32() {
sub_33();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_31() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_33() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_34() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_35();
} else {
sub_36();
}
return false;
}
bool sub_35() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_36() {
if (uniforms.b[13]) {
sub_37();
} else {
sub_40();
}
return false;
}
bool sub_37() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_38();
} else {
sub_39();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_38() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_39() {
sub_33();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_40() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_41() {
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
if (uniforms.b[11]) {
sub_42();
} else {
sub_43();
}
return false;
}
bool sub_42() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_43() {
if (uniforms.b[14]) {
sub_44();
} else {
sub_45();
}
return false;
}
bool sub_44() {
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.zw = (reg_tmp6.zwww).zw;
sub_33();
reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_45() {
vs_out_attr6 = uniforms.f[93].xxxx;
return false;
}
// reference: 086B762321C7A781, EDC7E01CE0E1CD5B
// shader: 8B30, 225230E13EF778A8
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) + (texcolor2.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1) - texcolor0.aaa) + (texcolor0.rgb) * (vec3(1) - (vec3(1) - texcolor0.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((secondary_fragment_color.rgb) * (secondary_fragment_color.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp(min((const_color[4].rgb) + (rounded_primary_color.rgb), vec3(1)) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A95084561793F385, 225230E13EF778A8
// program: EDC7E01CE0E1CD5B, EADA2116091C5E01, 225230E13EF778A8
// shader: 8B30, 49CD2493C74F0135
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) + (texcolor2.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1) - texcolor0.aaa) + (texcolor0.rgb) * (vec3(1) - (vec3(1) - texcolor0.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (const_color[1].a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((secondary_fragment_color.rgb) * (secondary_fragment_color.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp(min((const_color[4].rgb) + (rounded_primary_color.rgb), vec3(1)) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A9508456282217B6, 49CD2493C74F0135
// program: EDC7E01CE0E1CD5B, EADA2116091C5E01, 49CD2493C74F0135
// reference: 017FC1AD9DE9D5D3, 44007532698940E0
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 44007532698940E0
// shader: 8B30, B052B1145999EE92
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((secondary_fragment_color.rgb) * (secondary_fragment_color.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp(min((const_color[2].rgb) + (rounded_primary_color.rgb), vec3(1)) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (texcolor0.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (texcolor0.aaa)), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 22BADBCBA958B20E, B052B1145999EE92
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, B052B1145999EE92
// shader: 8B30, 64102BEF2AA607B3
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < float(scissor_x1) || gl_FragCoord.y < float(scissor_y1) || gl_FragCoord.x >= float(scissor_x2) || gl_FragCoord.y >= float(scissor_y2)) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
depth /= gl_FragCoord.w;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(light_vector, normal))) * light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((secondary_fragment_color.rgb) * (secondary_fragment_color.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp(min((const_color[2].rgb) + (rounded_primary_color.rgb), vec3(1)) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 36EC248CDAFA2328, 64102BEF2AA607B3
// program: 9E00A12FA5BE63C7, C8DF8CC87A4E8CE6, 64102BEF2AA607B3
// reference: A95084565080057E, 225230E13EF778A8
// reference: A95084566F31E14D, 49CD2493C74F0135
// reference: 22BADBCBEE4B44F5, B052B1145999EE92
// reference: 36EC248C9DE9D5D3, 64102BEF2AA607B3
// reference: 4FF6CA049DE9D5D3, 44007532698940E0
// reference: 16D1B9B7FC532B01, 6B6B59109AAD00C3
// reference: 5858B21EFC532B01, 6B6B59109AAD00C3
// reference: 4FF6CA04DAFA2328, 44007532698940E0
// reference: 6C33D062A958B20E, B052B1145999EE92
// reference: DFF2840F95EFD41D, E4EB0A5B1E28C922
