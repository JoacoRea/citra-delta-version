// shader: 8B31, 58DF619408ABA396

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_106_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_106_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_106_4096() {
    uint jmp_to = 106u;
    while (true) {
        switch (jmp_to) {
        case 106u: {
            // 106: call
            {
                sub_9_21();
            }
            // 107: add
            vs_out_attr3 = uniforms.f[12].yxwz + vs_in_reg1.yxyx;
            // 108: add
            vs_out_attr5 = uniforms.f[13].yxwz + vs_in_reg1.yxyx;
            // 109: mov
            vs_out_attr2 = uniforms.f[80];
            // 110: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 111: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 112: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 113: add
            vs_out_attr0 = uniforms.f[13] + vs_in_reg0;
            // 114: mul
            vs_out_attr2 = mul_safe(uniforms.f[12], vs_in_reg3);
            // 115: add
            vs_out_attr3 = uniforms.f[17].xyyy + vs_in_reg1.xyyy;
            // 116: add
            vs_out_attr5.xy = (uniforms.f[17].zwww + vs_in_reg1.zwww).xy;
            // 117: add
            vs_out_attr5.zw = (uniforms.f[18].xyxy + vs_in_reg2.xyxy).zw;
            // 118: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 119: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 120: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 121: mul
            reg_tmp12 = mul_safe(uniforms.f[16], vs_in_reg0.xyxy);
            // 122: add
            reg_tmp12 = uniforms.f[13] + reg_tmp12;
            // 123: mov
            vs_out_attr2 = uniforms.f[12];
            // 124: mul
            reg_tmp14 = mul_safe(uniforms.f[15], vs_in_reg1);
            // 125: add
            reg_tmp13 = uniforms.f[93].yyyy + reg_tmp12.zwww;
            // 126: mul
            reg_tmp13 = mul_safe(uniforms.f[95].zzzz, reg_tmp13);
            // 127: add
            reg_tmp14.y = (uniforms.f[14].wwww + reg_tmp14).y;
            // 128: mul
            reg_tmp13 = mul_safe(uniforms.f[14], reg_tmp13);
            // 129: mov
            vs_out_attr0.xy = (reg_tmp12.xyyy).xy;
            // 130: mov
            vs_out_attr0.zw = (uniforms.f[93].xxxy).zw;
            // 131: add
            vs_out_attr3.xyz = (reg_tmp13 + reg_tmp14).xyz;
            // 132: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 133: call
            {
                sub_9_21();
            }
            // 134: mov
            reg_tmp0 = vs_in_reg1.xyyy;
            // 135: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 136: mov
            reg_tmp1 = vs_in_reg0.xyyy;
            // 137: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 138: mul
            reg_tmp13 = mul_safe(uniforms.f[12], vs_in_reg2);
            // 139: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[13]), vec3(reg_tmp0));
            // 140: dp3
            vs_out_attr3.yz = vec2(dot(vec3(uniforms.f[14]), vec3(reg_tmp0)));
            // 141: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 142: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[16]), vec3(reg_tmp1));
            // 143: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, reg_tmp13);
            // 144: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            // 145: call
            {
                sub_9_21();
            }
            // 146: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 147: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            // 148: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 149: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 150: call
            {
                sub_55_85();
            }
            // 151: call
            {
                sub_45_55();
            }
            // 152: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 153: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 154: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 155: call
            {
                sub_9_21();
            }
            // 156: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg1);
            // 157: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            // 158: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 159: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 160: call
            {
                sub_55_85();
            }
            // 161: call
            {
                sub_45_55();
            }
            // 162: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 163: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 164: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 165: call
            {
                sub_9_21();
            }
            // 166: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 167: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 168: mov
            vs_out_attr5.xy = (uniforms.f[93].xxxx).xy;
            // 169: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            // 170: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 171: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 172: call
            {
                sub_55_85();
            }
            // 173: call
            {
                sub_45_55();
            }
            // 174: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 175: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 176: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 177: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 178: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 179: call
            {
                sub_55_85();
            }
            // 180: call
            {
                sub_45_55();
            }
            // 181: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 182: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 183: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 184: call
            {
                sub_9_21();
            }
            // 185: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 186: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 187: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 188: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 189: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 190: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            // 191: call
            {
                sub_55_85();
            }
            // 192: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            // 193: call
            {
                sub_93_106();
            }
            // 194: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            // 195: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 196: call
            {
                sub_45_55();
            }
            // 197: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 198: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 199: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            // 200: ifu
            if (uniforms.b[0]) {
                sub_201_219();
            }
            // 219: mad
            vs_out_attr5.zw = (fma_safe(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            // 220: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 221: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 222: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 223: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 224: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 225: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 226: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 227: call
            {
                sub_55_85();
            }
            // 228: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 229: call
            {
                sub_93_106();
            }
            // 230: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 231: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 232: call
            {
                sub_45_55();
            }
            // 233: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 234: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 235: mul
            vs_out_attr5 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            // 236: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 237: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 238: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 239: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 240: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 241: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 242: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 243: call
            {
                sub_55_85();
            }
            // 244: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 245: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 246: call
            {
                sub_45_55();
            }
            // 247: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 248: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            // 249: mul
            reg_tmp13 = mul_safe(uniforms.f[95].yyyy, vs_in_reg3);
            // 250: mov
            reg_tmp14 = uniforms.f[71];
            // 251: mad
            reg_tmp13 = fma_safe(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 252: rcp
            reg_tmp12 = vec4(rcp_safe(reg_tmp10.wwww.x));
            // 253: mul
            reg_tmp12 = mul_safe(reg_tmp10, reg_tmp12);
            // 254: mov
            reg_tmp14 = uniforms.f[72];
            // 255: mad
            reg_tmp12 = fma_safe(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 256: add
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            // 257: mad
            vs_out_attr2.xyz = (fma_safe(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 258: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 259: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 260: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 261: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 262: call
            {
                sub_55_85();
            }
            // 263: call
            {
                sub_45_55();
            }
            // 264: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 265: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 266: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 267: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 268: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 269: call
            {
                sub_55_85();
            }
            // 270: dp3
            reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 271: call
            {
                sub_45_55();
            }
            // 272: rsq
            reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
            // 273: dp3
            reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
            // 274: dp3
            reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
            // 275: dp3
            reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
            // 276: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
            // 277: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 278: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 279: dp3
            reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 280: call
            {
                sub_96_106();
            }
            // 281: max
            reg_tmp15 = max(reg_tmp1, -reg_tmp1);
            // 282: mul
            reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            // 283: min
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            // 284: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 285: add
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            // 286: mul
            reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            // 287: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 288: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 289: call
            {
                sub_55_85();
            }
            // 290: call
            {
                sub_93_106();
            }
            // 291: call
            {
                sub_45_55();
            }
            // 292: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 293: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 294: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 295: call
            {
                sub_287_295();
            }
            // 296: mul
            vs_out_attr2 = mul_safe(uniforms.f[95].zzzz, reg_tmp12);
            // 297: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 298: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 299: call
            {
                sub_287_295();
            }
            // 300: max
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            // 301: mul
            vs_out_attr2.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            // 302: max
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            // 303: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 494u: {
            // 494: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 495: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 500u: {
            // 500: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 501: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 502: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 503: mov
            vs_out_attr5.zw = (uniforms.f[93].xxxx).zw;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    // 201: mov
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    // 202: mov
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    // 203: mov
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    // 204: mul
    reg_tmp6.xyz = (mul_safe(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    // 205: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    // 206: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    // 207: add
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    // 208: dp3
    reg_tmp13.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
    // 209: rsq
    reg_tmp13.y = rsq_safe(reg_tmp13.xxxx.x);
    // 210: mul
    reg_tmp4 = mul_safe(reg_tmp12, -reg_tmp13.yyyy);
    // 211: dp3
    reg_tmp14.x = dot(vec3(reg_tmp4), vec3(reg_tmp7));
    // 212: mul
    reg_tmp14.y = (mul_safe(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    // 213: mad
    reg_tmp5 = fma_safe(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    // 214: add
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    // 215: dp3
    reg_tmp12.w = dot(vec3(reg_tmp12.xyzz), vec3(reg_tmp12.xyzz));
    // 216: rsq
    reg_tmp14.z = rsq_safe(reg_tmp12.wwww.x);
    // 217: mul
    reg_tmp12.xy = (mul_safe(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    // 218: mov
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    // 287: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 288: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 289: call
    {
        sub_55_85();
    }
    // 290: call
    {
        sub_93_106();
    }
    // 291: call
    {
        sub_45_55();
    }
    // 292: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 293: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 294: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: DEB911C73D16D094, 58DF619408ABA396
// shader: 8DD9, C6949C8D76FDEB0C

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

 in vec4 vs_out_attr0[];
 in vec4 vs_out_attr1[];
 in vec4 vs_out_attr2[];
 in vec4 vs_out_attr3[];
 in vec4 vs_out_attr4[];
 in vec4 vs_out_attr5[];

struct Vertex {
    vec4 attributes[6];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z, vtx.attributes[2].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[3].x, vtx.attributes[3].y);
    texcoord1 = vec2(vtx.attributes[5].x, vtx.attributes[5].y);

    texcoord0_w = vtx.attributes[3].w;
    view = vec3(vtx.attributes[4].x, vtx.attributes[4].y, vtx.attributes[4].z);

    texcoord2 = vec2(vtx.attributes[5].z, vtx.attributes[5].w);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[6](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0], vs_out_attr5[0]);
    prim_buffer[1].attributes = vec4[6](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1], vs_out_attr5[1]);
    prim_buffer[2].attributes = vec4[6](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2], vs_out_attr5[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: A0CB59480533AF6A, C6949C8D76FDEB0C
// shader: 8B30, 9EAC0097AD9B1EE3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (const_color[2].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9F999D4A0EF7A266, 9EAC0097AD9B1EE3
// program: 58DF619408ABA396, C6949C8D76FDEB0C, 9EAC0097AD9B1EE3
// reference: 5559C66866CB2250, 58DF619408ABA396
// shader: 8B30, 4991753A18E4000E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (const_color[2].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BEB80A3142E4567D, 4991753A18E4000E
// program: 58DF619408ABA396, C6949C8D76FDEB0C, 4991753A18E4000E
// shader: 8B31, 03E74703A3994B36

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_113_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_113_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_113_4096() {
    uint jmp_to = 113u;
    while (true) {
        switch (jmp_to) {
        case 113u: {
            // 113: add
            vs_out_attr0 = uniforms.f[13] + vs_in_reg0;
            // 114: mul
            vs_out_attr2 = mul_safe(uniforms.f[12], vs_in_reg3);
            // 115: add
            vs_out_attr3 = uniforms.f[17].xyyy + vs_in_reg1.xyyy;
            // 116: add
            vs_out_attr5.xy = (uniforms.f[17].zwww + vs_in_reg1.zwww).xy;
            // 117: add
            vs_out_attr5.zw = (uniforms.f[18].xyxy + vs_in_reg2.xyxy).zw;
            // 118: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 119: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 120: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 121: mul
            reg_tmp12 = mul_safe(uniforms.f[16], vs_in_reg0.xyxy);
            // 122: add
            reg_tmp12 = uniforms.f[13] + reg_tmp12;
            // 123: mov
            vs_out_attr2 = uniforms.f[12];
            // 124: mul
            reg_tmp14 = mul_safe(uniforms.f[15], vs_in_reg1);
            // 125: add
            reg_tmp13 = uniforms.f[93].yyyy + reg_tmp12.zwww;
            // 126: mul
            reg_tmp13 = mul_safe(uniforms.f[95].zzzz, reg_tmp13);
            // 127: add
            reg_tmp14.y = (uniforms.f[14].wwww + reg_tmp14).y;
            // 128: mul
            reg_tmp13 = mul_safe(uniforms.f[14], reg_tmp13);
            // 129: mov
            vs_out_attr0.xy = (reg_tmp12.xyyy).xy;
            // 130: mov
            vs_out_attr0.zw = (uniforms.f[93].xxxy).zw;
            // 131: add
            vs_out_attr3.xyz = (reg_tmp13 + reg_tmp14).xyz;
            // 132: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 133: call
            {
                sub_9_21();
            }
            // 134: mov
            reg_tmp0 = vs_in_reg1.xyyy;
            // 135: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 136: mov
            reg_tmp1 = vs_in_reg0.xyyy;
            // 137: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 138: mul
            reg_tmp13 = mul_safe(uniforms.f[12], vs_in_reg2);
            // 139: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[13]), vec3(reg_tmp0));
            // 140: dp3
            vs_out_attr3.yz = vec2(dot(vec3(uniforms.f[14]), vec3(reg_tmp0)));
            // 141: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 142: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[16]), vec3(reg_tmp1));
            // 143: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, reg_tmp13);
            // 144: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            // 145: call
            {
                sub_9_21();
            }
            // 146: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 147: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            // 148: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 149: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 150: call
            {
                sub_55_85();
            }
            // 151: call
            {
                sub_45_55();
            }
            // 152: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 153: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 154: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 155: call
            {
                sub_9_21();
            }
            // 156: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg1);
            // 157: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            // 158: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 159: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 160: call
            {
                sub_55_85();
            }
            // 161: call
            {
                sub_45_55();
            }
            // 162: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 163: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 164: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 165: call
            {
                sub_9_21();
            }
            // 166: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 167: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 168: mov
            vs_out_attr5.xy = (uniforms.f[93].xxxx).xy;
            // 169: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            // 170: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 171: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 172: call
            {
                sub_55_85();
            }
            // 173: call
            {
                sub_45_55();
            }
            // 174: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 175: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 176: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 177: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 178: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 179: call
            {
                sub_55_85();
            }
            // 180: call
            {
                sub_45_55();
            }
            // 181: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 182: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 183: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 184: call
            {
                sub_9_21();
            }
            // 185: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 186: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 187: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 188: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 189: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 190: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            // 191: call
            {
                sub_55_85();
            }
            // 192: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            // 193: call
            {
                sub_93_106();
            }
            // 194: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            // 195: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 196: call
            {
                sub_45_55();
            }
            // 197: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 198: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 199: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            // 200: ifu
            if (uniforms.b[0]) {
                sub_201_219();
            }
            // 219: mad
            vs_out_attr5.zw = (fma_safe(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            // 220: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 221: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 222: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 223: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 224: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 225: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 226: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 227: call
            {
                sub_55_85();
            }
            // 228: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 229: call
            {
                sub_93_106();
            }
            // 230: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 231: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 232: call
            {
                sub_45_55();
            }
            // 233: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 234: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 235: mul
            vs_out_attr5 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            // 236: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 237: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 238: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 239: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 240: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 241: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 242: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 243: call
            {
                sub_55_85();
            }
            // 244: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 245: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 246: call
            {
                sub_45_55();
            }
            // 247: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 248: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            // 249: mul
            reg_tmp13 = mul_safe(uniforms.f[95].yyyy, vs_in_reg3);
            // 250: mov
            reg_tmp14 = uniforms.f[71];
            // 251: mad
            reg_tmp13 = fma_safe(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 252: rcp
            reg_tmp12 = vec4(rcp_safe(reg_tmp10.wwww.x));
            // 253: mul
            reg_tmp12 = mul_safe(reg_tmp10, reg_tmp12);
            // 254: mov
            reg_tmp14 = uniforms.f[72];
            // 255: mad
            reg_tmp12 = fma_safe(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 256: add
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            // 257: mad
            vs_out_attr2.xyz = (fma_safe(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 258: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 259: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 260: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 261: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 262: call
            {
                sub_55_85();
            }
            // 263: call
            {
                sub_45_55();
            }
            // 264: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 265: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 266: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 267: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 268: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 269: call
            {
                sub_55_85();
            }
            // 270: dp3
            reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 271: call
            {
                sub_45_55();
            }
            // 272: rsq
            reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
            // 273: dp3
            reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
            // 274: dp3
            reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
            // 275: dp3
            reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
            // 276: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
            // 277: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 278: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 279: dp3
            reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 280: call
            {
                sub_96_106();
            }
            // 281: max
            reg_tmp15 = max(reg_tmp1, -reg_tmp1);
            // 282: mul
            reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            // 283: min
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            // 284: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 285: add
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            // 286: mul
            reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            // 287: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 288: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 289: call
            {
                sub_55_85();
            }
            // 290: call
            {
                sub_93_106();
            }
            // 291: call
            {
                sub_45_55();
            }
            // 292: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 293: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 294: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 295: call
            {
                sub_287_295();
            }
            // 296: mul
            vs_out_attr2 = mul_safe(uniforms.f[95].zzzz, reg_tmp12);
            // 297: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 298: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 299: call
            {
                sub_287_295();
            }
            // 300: max
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            // 301: mul
            vs_out_attr2.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            // 302: max
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            // 303: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 494u: {
            // 494: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 495: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 500u: {
            // 500: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 501: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 502: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 503: mov
            vs_out_attr5.zw = (uniforms.f[93].xxxx).zw;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    // 201: mov
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    // 202: mov
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    // 203: mov
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    // 204: mul
    reg_tmp6.xyz = (mul_safe(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    // 205: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    // 206: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    // 207: add
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    // 208: dp3
    reg_tmp13.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
    // 209: rsq
    reg_tmp13.y = rsq_safe(reg_tmp13.xxxx.x);
    // 210: mul
    reg_tmp4 = mul_safe(reg_tmp12, -reg_tmp13.yyyy);
    // 211: dp3
    reg_tmp14.x = dot(vec3(reg_tmp4), vec3(reg_tmp7));
    // 212: mul
    reg_tmp14.y = (mul_safe(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    // 213: mad
    reg_tmp5 = fma_safe(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    // 214: add
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    // 215: dp3
    reg_tmp12.w = dot(vec3(reg_tmp12.xyzz), vec3(reg_tmp12.xyzz));
    // 216: rsq
    reg_tmp14.z = rsq_safe(reg_tmp12.wwww.x);
    // 217: mul
    reg_tmp12.xy = (mul_safe(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    // 218: mov
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    // 287: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 288: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 289: call
    {
        sub_55_85();
    }
    // 290: call
    {
        sub_93_106();
    }
    // 291: call
    {
        sub_45_55();
    }
    // 292: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 293: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 294: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: DEB911C7993EE21D, 03E74703A3994B36
// shader: 8B30, 02AD7BCFB15AD22C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF99B38DD3C, 02AD7BCFB15AD22C
// program: 03E74703A3994B36, C6949C8D76FDEB0C, 02AD7BCFB15AD22C
// reference: 5559C668C2E310D9, 03E74703A3994B36
// shader: 8B30, EADFD23362F72552

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1DCC05B766B7FB46, EADFD23362F72552
// program: 03E74703A3994B36, C6949C8D76FDEB0C, EADFD23362F72552
// shader: 8B31, D968087671A07D60

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_133_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_133_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_133_4096() {
    uint jmp_to = 133u;
    while (true) {
        switch (jmp_to) {
        case 133u: {
            // 133: call
            {
                sub_9_21();
            }
            // 134: mov
            reg_tmp0 = vs_in_reg1.xyyy;
            // 135: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 136: mov
            reg_tmp1 = vs_in_reg0.xyyy;
            // 137: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 138: mul
            reg_tmp13 = mul_safe(uniforms.f[12], vs_in_reg2);
            // 139: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[13]), vec3(reg_tmp0));
            // 140: dp3
            vs_out_attr3.yz = vec2(dot(vec3(uniforms.f[14]), vec3(reg_tmp0)));
            // 141: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 142: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[16]), vec3(reg_tmp1));
            // 143: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, reg_tmp13);
            // 144: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            // 145: call
            {
                sub_9_21();
            }
            // 146: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 147: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            // 148: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 149: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 150: call
            {
                sub_55_85();
            }
            // 151: call
            {
                sub_45_55();
            }
            // 152: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 153: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 154: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 155: call
            {
                sub_9_21();
            }
            // 156: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg1);
            // 157: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            // 158: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 159: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 160: call
            {
                sub_55_85();
            }
            // 161: call
            {
                sub_45_55();
            }
            // 162: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 163: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 164: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 165: call
            {
                sub_9_21();
            }
            // 166: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 167: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 168: mov
            vs_out_attr5.xy = (uniforms.f[93].xxxx).xy;
            // 169: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            // 170: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 171: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 172: call
            {
                sub_55_85();
            }
            // 173: call
            {
                sub_45_55();
            }
            // 174: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 175: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 176: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 177: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 178: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 179: call
            {
                sub_55_85();
            }
            // 180: call
            {
                sub_45_55();
            }
            // 181: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 182: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 183: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 184: call
            {
                sub_9_21();
            }
            // 185: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 186: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 187: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 188: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 189: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 190: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            // 191: call
            {
                sub_55_85();
            }
            // 192: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            // 193: call
            {
                sub_93_106();
            }
            // 194: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            // 195: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 196: call
            {
                sub_45_55();
            }
            // 197: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 198: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 199: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            // 200: ifu
            if (uniforms.b[0]) {
                sub_201_219();
            }
            // 219: mad
            vs_out_attr5.zw = (fma_safe(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            // 220: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 221: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 222: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 223: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 224: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 225: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 226: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 227: call
            {
                sub_55_85();
            }
            // 228: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 229: call
            {
                sub_93_106();
            }
            // 230: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 231: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 232: call
            {
                sub_45_55();
            }
            // 233: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 234: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 235: mul
            vs_out_attr5 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            // 236: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 237: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 238: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 239: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 240: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 241: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 242: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 243: call
            {
                sub_55_85();
            }
            // 244: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 245: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 246: call
            {
                sub_45_55();
            }
            // 247: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 248: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            // 249: mul
            reg_tmp13 = mul_safe(uniforms.f[95].yyyy, vs_in_reg3);
            // 250: mov
            reg_tmp14 = uniforms.f[71];
            // 251: mad
            reg_tmp13 = fma_safe(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 252: rcp
            reg_tmp12 = vec4(rcp_safe(reg_tmp10.wwww.x));
            // 253: mul
            reg_tmp12 = mul_safe(reg_tmp10, reg_tmp12);
            // 254: mov
            reg_tmp14 = uniforms.f[72];
            // 255: mad
            reg_tmp12 = fma_safe(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 256: add
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            // 257: mad
            vs_out_attr2.xyz = (fma_safe(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 258: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 259: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 260: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 261: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 262: call
            {
                sub_55_85();
            }
            // 263: call
            {
                sub_45_55();
            }
            // 264: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 265: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 266: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 267: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 268: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 269: call
            {
                sub_55_85();
            }
            // 270: dp3
            reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 271: call
            {
                sub_45_55();
            }
            // 272: rsq
            reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
            // 273: dp3
            reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
            // 274: dp3
            reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
            // 275: dp3
            reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
            // 276: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
            // 277: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 278: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 279: dp3
            reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 280: call
            {
                sub_96_106();
            }
            // 281: max
            reg_tmp15 = max(reg_tmp1, -reg_tmp1);
            // 282: mul
            reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            // 283: min
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            // 284: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 285: add
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            // 286: mul
            reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            // 287: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 288: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 289: call
            {
                sub_55_85();
            }
            // 290: call
            {
                sub_93_106();
            }
            // 291: call
            {
                sub_45_55();
            }
            // 292: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 293: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 294: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 295: call
            {
                sub_287_295();
            }
            // 296: mul
            vs_out_attr2 = mul_safe(uniforms.f[95].zzzz, reg_tmp12);
            // 297: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 298: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 299: call
            {
                sub_287_295();
            }
            // 300: max
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            // 301: mul
            vs_out_attr2.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            // 302: max
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            // 303: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 494u: {
            // 494: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 495: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 500u: {
            // 500: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 501: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 502: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 503: mov
            vs_out_attr5.zw = (uniforms.f[93].xxxx).zw;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    // 201: mov
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    // 202: mov
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    // 203: mov
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    // 204: mul
    reg_tmp6.xyz = (mul_safe(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    // 205: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    // 206: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    // 207: add
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    // 208: dp3
    reg_tmp13.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
    // 209: rsq
    reg_tmp13.y = rsq_safe(reg_tmp13.xxxx.x);
    // 210: mul
    reg_tmp4 = mul_safe(reg_tmp12, -reg_tmp13.yyyy);
    // 211: dp3
    reg_tmp14.x = dot(vec3(reg_tmp4), vec3(reg_tmp7));
    // 212: mul
    reg_tmp14.y = (mul_safe(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    // 213: mad
    reg_tmp5 = fma_safe(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    // 214: add
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    // 215: dp3
    reg_tmp12.w = dot(vec3(reg_tmp12.xyzz), vec3(reg_tmp12.xyzz));
    // 216: rsq
    reg_tmp14.z = rsq_safe(reg_tmp12.wwww.x);
    // 217: mul
    reg_tmp12.xy = (mul_safe(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    // 218: mov
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    // 287: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 288: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 289: call
    {
        sub_55_85();
    }
    // 290: call
    {
        sub_93_106();
    }
    // 291: call
    {
        sub_45_55();
    }
    // 292: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 293: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 294: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 5559C6687BB854CB, D968087671A07D60
// shader: 8B30, 88DFFA1A12BB4ACD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3BD5A2ED9EE199AC, 88DFFA1A12BB4ACD
// program: D968087671A07D60, C6949C8D76FDEB0C, 88DFFA1A12BB4ACD
// shader: 8B30, 9003BF984D8E6760

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E689EE199AC, 9003BF984D8E6760
// program: D968087671A07D60, C6949C8D76FDEB0C, 9003BF984D8E6760
// reference: DEB911C72065A60F, D968087671A07D60
// shader: 8B31, C8A7575AACF62C13

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_21_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_417_4096();

bool exec_shader() {
    sub_417_4096();
    return true;
}

bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_417_4096() {
    uint jmp_to = 417u;
    while (true) {
        switch (jmp_to) {
        case 417u: {
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
// reference: DEB911C78CD2EFC4, C8A7575AACF62C13
// shader: 8B30, 9F6C232006C59C94

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 96F061A71B81AF5D, 9F6C232006C59C94
// program: C8A7575AACF62C13, C6949C8D76FDEB0C, 9F6C232006C59C94
// shader: 8B31, BE4A1B4EC9120F38

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_267_287();
bool sub_304_4096();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_304_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_304_4096() {
    uint jmp_to = 304u;
    while (true) {
        switch (jmp_to) {
        case 304u: {
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 5559C66846508A4D, BE4A1B4EC9120F38
// shader: 8B30, 9BD92F1123674B99

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 383E5917A077DFCF, 9BD92F1123674B99
// program: BE4A1B4EC9120F38, C6949C8D76FDEB0C, 9BD92F1123674B99
// shader: 8B31, 1DD1DE0E0C669DE9

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_21_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_432_4096();

bool exec_shader() {
    sub_432_4096();
    return true;
}

bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_432_4096() {
    uint jmp_to = 432u;
    while (true) {
        switch (jmp_to) {
        case 432u: {
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
// reference: 5559C6688CAC8CB9, 1DD1DE0E0C669DE9
// shader: 8B30, 28614CBDD5F44132

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((combiner_buffer.rgb) * (primary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 2.0, alpha_output_4 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E500DDE4AFC2C10D, 28614CBDD5F44132
// program: 1DD1DE0E0C669DE9, C6949C8D76FDEB0C, 28614CBDD5F44132
// shader: 8B30, 7CA3D348BDE58A2A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: DC01DEC4AF33E650, 7CA3D348BDE58A2A
// program: BE4A1B4EC9120F38, C6949C8D76FDEB0C, 7CA3D348BDE58A2A
// shader: 8B30, 6F0B19F4376C93CB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((combiner_buffer.rgb) * (primary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 2.0, alpha_output_4 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 013F5A37A086F892, 6F0B19F4376C93CB
// program: 1DD1DE0E0C669DE9, C6949C8D76FDEB0C, 6F0B19F4376C93CB
// shader: 8B31, CEC65C588F867703

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_148_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_148_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_148_4096() {
    uint jmp_to = 148u;
    while (true) {
        switch (jmp_to) {
        case 148u: {
            // 148: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 149: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 150: call
            {
                sub_55_85();
            }
            // 151: call
            {
                sub_45_55();
            }
            // 152: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 153: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 154: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 155: call
            {
                sub_9_21();
            }
            // 156: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg1);
            // 157: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            // 158: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 159: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 160: call
            {
                sub_55_85();
            }
            // 161: call
            {
                sub_45_55();
            }
            // 162: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 163: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 164: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 165: call
            {
                sub_9_21();
            }
            // 166: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 167: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 168: mov
            vs_out_attr5.xy = (uniforms.f[93].xxxx).xy;
            // 169: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            // 170: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 171: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 172: call
            {
                sub_55_85();
            }
            // 173: call
            {
                sub_45_55();
            }
            // 174: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 175: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 176: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 177: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 178: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 179: call
            {
                sub_55_85();
            }
            // 180: call
            {
                sub_45_55();
            }
            // 181: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 182: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 183: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 184: call
            {
                sub_9_21();
            }
            // 185: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 186: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 187: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 188: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 189: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 190: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            // 191: call
            {
                sub_55_85();
            }
            // 192: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            // 193: call
            {
                sub_93_106();
            }
            // 194: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            // 195: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 196: call
            {
                sub_45_55();
            }
            // 197: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 198: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 199: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            // 200: ifu
            if (uniforms.b[0]) {
                sub_201_219();
            }
            // 219: mad
            vs_out_attr5.zw = (fma_safe(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            // 220: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 221: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 222: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 223: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 224: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 225: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 226: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 227: call
            {
                sub_55_85();
            }
            // 228: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 229: call
            {
                sub_93_106();
            }
            // 230: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 231: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 232: call
            {
                sub_45_55();
            }
            // 233: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 234: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 235: mul
            vs_out_attr5 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            // 236: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 237: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 238: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 239: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 240: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 241: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 242: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 243: call
            {
                sub_55_85();
            }
            // 244: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 245: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 246: call
            {
                sub_45_55();
            }
            // 247: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 248: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            // 249: mul
            reg_tmp13 = mul_safe(uniforms.f[95].yyyy, vs_in_reg3);
            // 250: mov
            reg_tmp14 = uniforms.f[71];
            // 251: mad
            reg_tmp13 = fma_safe(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 252: rcp
            reg_tmp12 = vec4(rcp_safe(reg_tmp10.wwww.x));
            // 253: mul
            reg_tmp12 = mul_safe(reg_tmp10, reg_tmp12);
            // 254: mov
            reg_tmp14 = uniforms.f[72];
            // 255: mad
            reg_tmp12 = fma_safe(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 256: add
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            // 257: mad
            vs_out_attr2.xyz = (fma_safe(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 258: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 259: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 260: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 261: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 262: call
            {
                sub_55_85();
            }
            // 263: call
            {
                sub_45_55();
            }
            // 264: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 265: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 266: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 267: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 268: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 269: call
            {
                sub_55_85();
            }
            // 270: dp3
            reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 271: call
            {
                sub_45_55();
            }
            // 272: rsq
            reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
            // 273: dp3
            reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
            // 274: dp3
            reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
            // 275: dp3
            reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
            // 276: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
            // 277: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 278: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 279: dp3
            reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 280: call
            {
                sub_96_106();
            }
            // 281: max
            reg_tmp15 = max(reg_tmp1, -reg_tmp1);
            // 282: mul
            reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            // 283: min
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            // 284: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 285: add
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            // 286: mul
            reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            // 287: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 288: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 289: call
            {
                sub_55_85();
            }
            // 290: call
            {
                sub_93_106();
            }
            // 291: call
            {
                sub_45_55();
            }
            // 292: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 293: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 294: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 295: call
            {
                sub_287_295();
            }
            // 296: mul
            vs_out_attr2 = mul_safe(uniforms.f[95].zzzz, reg_tmp12);
            // 297: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 298: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 299: call
            {
                sub_287_295();
            }
            // 300: max
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            // 301: mul
            vs_out_attr2.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            // 302: max
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            // 303: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 494u: {
            // 494: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 495: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 500u: {
            // 500: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 501: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 502: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 503: mov
            vs_out_attr5.zw = (uniforms.f[93].xxxx).zw;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    // 201: mov
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    // 202: mov
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    // 203: mov
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    // 204: mul
    reg_tmp6.xyz = (mul_safe(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    // 205: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    // 206: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    // 207: add
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    // 208: dp3
    reg_tmp13.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
    // 209: rsq
    reg_tmp13.y = rsq_safe(reg_tmp13.xxxx.x);
    // 210: mul
    reg_tmp4 = mul_safe(reg_tmp12, -reg_tmp13.yyyy);
    // 211: dp3
    reg_tmp14.x = dot(vec3(reg_tmp4), vec3(reg_tmp7));
    // 212: mul
    reg_tmp14.y = (mul_safe(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    // 213: mad
    reg_tmp5 = fma_safe(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    // 214: add
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    // 215: dp3
    reg_tmp12.w = dot(vec3(reg_tmp12.xyzz), vec3(reg_tmp12.xyzz));
    // 216: rsq
    reg_tmp14.z = rsq_safe(reg_tmp12.wwww.x);
    // 217: mul
    reg_tmp12.xy = (mul_safe(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    // 218: mov
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    // 287: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 288: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 289: call
    {
        sub_55_85();
    }
    // 290: call
    {
        sub_93_106();
    }
    // 291: call
    {
        sub_45_55();
    }
    // 292: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 293: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 294: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 5559C668201BC572, CEC65C588F867703
// shader: 8B30, 7C8E99BE201BA77B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 87752AE8286857DC, 7C8E99BE201BA77B
// program: CEC65C588F867703, C6949C8D76FDEB0C, 7C8E99BE201BA77B
// reference: DEB911C71D8D7889, BE4A1B4EC9120F38
// reference: 5559C668D70F1D00, C8A7575AACF62C13
// shader: 8B30, 0658FB0906870C59

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C571F5B61B81AF5D, 0658FB0906870C59
// program: C8A7575AACF62C13, C6949C8D76FDEB0C, 0658FB0906870C59
// shader: 8B30, B7CD9648C64B084B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D7AD957473ED4C18, B7CD9648C64B084B
// program: C8A7575AACF62C13, C6949C8D76FDEB0C, B7CD9648C64B084B
// shader: 8B31, F68537DD3A9B4EE5

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_165_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_165_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_165_4096() {
    uint jmp_to = 165u;
    while (true) {
        switch (jmp_to) {
        case 165u: {
            // 165: call
            {
                sub_9_21();
            }
            // 166: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 167: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 168: mov
            vs_out_attr5.xy = (uniforms.f[93].xxxx).xy;
            // 169: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            // 170: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 171: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 172: call
            {
                sub_55_85();
            }
            // 173: call
            {
                sub_45_55();
            }
            // 174: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 175: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 176: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 177: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 178: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 179: call
            {
                sub_55_85();
            }
            // 180: call
            {
                sub_45_55();
            }
            // 181: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 182: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 183: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 184: call
            {
                sub_9_21();
            }
            // 185: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 186: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 187: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 188: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 189: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 190: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            // 191: call
            {
                sub_55_85();
            }
            // 192: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            // 193: call
            {
                sub_93_106();
            }
            // 194: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            // 195: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 196: call
            {
                sub_45_55();
            }
            // 197: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 198: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 199: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            // 200: ifu
            if (uniforms.b[0]) {
                sub_201_219();
            }
            // 219: mad
            vs_out_attr5.zw = (fma_safe(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            // 220: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 221: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 222: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 223: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 224: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 225: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 226: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 227: call
            {
                sub_55_85();
            }
            // 228: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 229: call
            {
                sub_93_106();
            }
            // 230: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 231: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 232: call
            {
                sub_45_55();
            }
            // 233: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 234: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 235: mul
            vs_out_attr5 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            // 236: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 237: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 238: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 239: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 240: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 241: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 242: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 243: call
            {
                sub_55_85();
            }
            // 244: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 245: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 246: call
            {
                sub_45_55();
            }
            // 247: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 248: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            // 249: mul
            reg_tmp13 = mul_safe(uniforms.f[95].yyyy, vs_in_reg3);
            // 250: mov
            reg_tmp14 = uniforms.f[71];
            // 251: mad
            reg_tmp13 = fma_safe(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 252: rcp
            reg_tmp12 = vec4(rcp_safe(reg_tmp10.wwww.x));
            // 253: mul
            reg_tmp12 = mul_safe(reg_tmp10, reg_tmp12);
            // 254: mov
            reg_tmp14 = uniforms.f[72];
            // 255: mad
            reg_tmp12 = fma_safe(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 256: add
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            // 257: mad
            vs_out_attr2.xyz = (fma_safe(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 258: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 259: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 260: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 261: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 262: call
            {
                sub_55_85();
            }
            // 263: call
            {
                sub_45_55();
            }
            // 264: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 265: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 266: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 267: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 268: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 269: call
            {
                sub_55_85();
            }
            // 270: dp3
            reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 271: call
            {
                sub_45_55();
            }
            // 272: rsq
            reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
            // 273: dp3
            reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
            // 274: dp3
            reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
            // 275: dp3
            reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
            // 276: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
            // 277: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 278: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 279: dp3
            reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 280: call
            {
                sub_96_106();
            }
            // 281: max
            reg_tmp15 = max(reg_tmp1, -reg_tmp1);
            // 282: mul
            reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            // 283: min
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            // 284: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 285: add
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            // 286: mul
            reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            // 287: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 288: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 289: call
            {
                sub_55_85();
            }
            // 290: call
            {
                sub_93_106();
            }
            // 291: call
            {
                sub_45_55();
            }
            // 292: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 293: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 294: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 295: call
            {
                sub_287_295();
            }
            // 296: mul
            vs_out_attr2 = mul_safe(uniforms.f[95].zzzz, reg_tmp12);
            // 297: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 298: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 299: call
            {
                sub_287_295();
            }
            // 300: max
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            // 301: mul
            vs_out_attr2.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            // 302: max
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            // 303: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 500u: {
            // 500: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 501: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 502: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 503: mov
            vs_out_attr5.zw = (uniforms.f[93].xxxx).zw;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    // 201: mov
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    // 202: mov
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    // 203: mov
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    // 204: mul
    reg_tmp6.xyz = (mul_safe(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    // 205: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    // 206: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    // 207: add
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    // 208: dp3
    reg_tmp13.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
    // 209: rsq
    reg_tmp13.y = rsq_safe(reg_tmp13.xxxx.x);
    // 210: mul
    reg_tmp4 = mul_safe(reg_tmp12, -reg_tmp13.yyyy);
    // 211: dp3
    reg_tmp14.x = dot(vec3(reg_tmp4), vec3(reg_tmp7));
    // 212: mul
    reg_tmp14.y = (mul_safe(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    // 213: mad
    reg_tmp5 = fma_safe(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    // 214: add
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    // 215: dp3
    reg_tmp12.w = dot(vec3(reg_tmp12.xyzz), vec3(reg_tmp12.xyzz));
    // 216: rsq
    reg_tmp14.z = rsq_safe(reg_tmp12.wwww.x);
    // 217: mul
    reg_tmp12.xy = (mul_safe(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    // 218: mov
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    // 287: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 288: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 289: call
    {
        sub_55_85();
    }
    // 290: call
    {
        sub_93_106();
    }
    // 291: call
    {
        sub_45_55();
    }
    // 292: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 293: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 294: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 5559C66849075576, F68537DD3A9B4EE5
// shader: 8B30, DDE2415583ED54AA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA798554C19C, DDE2415583ED54AA
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, DDE2415583ED54AA
// shader: 8B30, CA0B9DE837FAB3A6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA7969E32A9F, CA0B9DE837FAB3A6
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, CA0B9DE837FAB3A6
// shader: 8B30, A101E82587A1788B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C1AD58BD16309078, A101E82587A1788B
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, A101E82587A1788B
// shader: 8B30, 8E399109E342A8CD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (const_color[2].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CC18095B0EF7A266, 8E399109E342A8CD
// program: 58DF619408ABA396, C6949C8D76FDEB0C, 8E399109E342A8CD
// shader: 8B30, EE8CD77F7E5E3EFF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (const_color[2].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: ED399E2042E4567D, EE8CD77F7E5E3EFF
// program: 58DF619408ABA396, C6949C8D76FDEB0C, EE8CD77F7E5E3EFF
// shader: 8B30, 82F8D2D2409D8782

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 96B91E4855436F24, 82F8D2D2409D8782
// program: 03E74703A3994B36, C6949C8D76FDEB0C, 82F8D2D2409D8782
// reference: 5559C6682065A60F, D968087671A07D60
// reference: 5559C6681D8D7889, BE4A1B4EC9120F38
// reference: 5559C668D7717E7D, 1DD1DE0E0C669DE9
// reference: 5559C6687BC637B6, CEC65C588F867703
// reference: 5559C6688CD2EFC4, C8A7575AACF62C13
// reference: 5559C66812DAA7B2, F68537DD3A9B4EE5
// shader: 8B30, 2AC8FF79650CE12C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 50B5A3E75AC631EC, 2AC8FF79650CE12C
// program: BE4A1B4EC9120F38, C6949C8D76FDEB0C, 2AC8FF79650CE12C
// shader: 8B31, E0291A49851DDE8E

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_177_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_177_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_177_4096() {
    uint jmp_to = 177u;
    while (true) {
        switch (jmp_to) {
        case 177u: {
            // 177: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 178: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 179: call
            {
                sub_55_85();
            }
            // 180: call
            {
                sub_45_55();
            }
            // 181: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 182: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 183: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 184: call
            {
                sub_9_21();
            }
            // 185: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 186: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 187: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 188: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 189: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 190: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            // 191: call
            {
                sub_55_85();
            }
            // 192: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            // 193: call
            {
                sub_93_106();
            }
            // 194: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            // 195: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 196: call
            {
                sub_45_55();
            }
            // 197: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 198: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 199: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            // 200: ifu
            if (uniforms.b[0]) {
                sub_201_219();
            }
            // 219: mad
            vs_out_attr5.zw = (fma_safe(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            // 220: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 221: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 222: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 223: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 224: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 225: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 226: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 227: call
            {
                sub_55_85();
            }
            // 228: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 229: call
            {
                sub_93_106();
            }
            // 230: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 231: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 232: call
            {
                sub_45_55();
            }
            // 233: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 234: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 235: mul
            vs_out_attr5 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            // 236: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 237: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 238: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 239: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 240: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 241: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 242: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 243: call
            {
                sub_55_85();
            }
            // 244: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 245: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 246: call
            {
                sub_45_55();
            }
            // 247: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 248: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            // 249: mul
            reg_tmp13 = mul_safe(uniforms.f[95].yyyy, vs_in_reg3);
            // 250: mov
            reg_tmp14 = uniforms.f[71];
            // 251: mad
            reg_tmp13 = fma_safe(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 252: rcp
            reg_tmp12 = vec4(rcp_safe(reg_tmp10.wwww.x));
            // 253: mul
            reg_tmp12 = mul_safe(reg_tmp10, reg_tmp12);
            // 254: mov
            reg_tmp14 = uniforms.f[72];
            // 255: mad
            reg_tmp12 = fma_safe(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 256: add
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            // 257: mad
            vs_out_attr2.xyz = (fma_safe(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 258: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 259: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 260: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 261: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 262: call
            {
                sub_55_85();
            }
            // 263: call
            {
                sub_45_55();
            }
            // 264: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 265: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 266: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 267: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 268: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 269: call
            {
                sub_55_85();
            }
            // 270: dp3
            reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 271: call
            {
                sub_45_55();
            }
            // 272: rsq
            reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
            // 273: dp3
            reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
            // 274: dp3
            reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
            // 275: dp3
            reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
            // 276: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
            // 277: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 278: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 279: dp3
            reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 280: call
            {
                sub_96_106();
            }
            // 281: max
            reg_tmp15 = max(reg_tmp1, -reg_tmp1);
            // 282: mul
            reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            // 283: min
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            // 284: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 285: add
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            // 286: mul
            reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            // 287: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 288: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 289: call
            {
                sub_55_85();
            }
            // 290: call
            {
                sub_93_106();
            }
            // 291: call
            {
                sub_45_55();
            }
            // 292: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 293: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 294: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 295: call
            {
                sub_287_295();
            }
            // 296: mul
            vs_out_attr2 = mul_safe(uniforms.f[95].zzzz, reg_tmp12);
            // 297: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 298: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 299: call
            {
                sub_287_295();
            }
            // 300: max
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            // 301: mul
            vs_out_attr2.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            // 302: max
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            // 303: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    // 201: mov
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    // 202: mov
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    // 203: mov
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    // 204: mul
    reg_tmp6.xyz = (mul_safe(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    // 205: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    // 206: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    // 207: add
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    // 208: dp3
    reg_tmp13.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
    // 209: rsq
    reg_tmp13.y = rsq_safe(reg_tmp13.xxxx.x);
    // 210: mul
    reg_tmp4 = mul_safe(reg_tmp12, -reg_tmp13.yyyy);
    // 211: dp3
    reg_tmp14.x = dot(vec3(reg_tmp4), vec3(reg_tmp7));
    // 212: mul
    reg_tmp14.y = (mul_safe(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    // 213: mad
    reg_tmp5 = fma_safe(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    // 214: add
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    // 215: dp3
    reg_tmp12.w = dot(vec3(reg_tmp12.xyzz), vec3(reg_tmp12.xyzz));
    // 216: rsq
    reg_tmp14.z = rsq_safe(reg_tmp12.wwww.x);
    // 217: mul
    reg_tmp12.xy = (mul_safe(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    // 218: mov
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    // 287: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 288: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 289: call
    {
        sub_55_85();
    }
    // 290: call
    {
        sub_93_106();
    }
    // 291: call
    {
        sub_45_55();
    }
    // 292: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 293: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 294: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 5559C6686D611557, E0291A49851DDE8E
// shader: 8B30, 8158F54198661505

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A7F51560AC526D5C, 8158F54198661505
// program: E0291A49851DDE8E, C6949C8D76FDEB0C, 8158F54198661505
// shader: 8B30, 96270BA2BC65C52C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A382C82A152AB604, 96270BA2BC65C52C
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 96270BA2BC65C52C
// reference: 5559C66836BCE793, E0291A49851DDE8E
// shader: 8B30, A947272D3D17DCE6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.r) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5CE2A6821F22301D, A947272D3D17DCE6
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, A947272D3D17DCE6
// shader: 8B30, 39FFD7AC58378EC3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 87752AE804B7BF8C, 39FFD7AC58378EC3
// program: CEC65C588F867703, C6949C8D76FDEB0C, 39FFD7AC58378EC3
// shader: 8B31, ADF51D558C5C687C

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_267_287();
bool sub_287_295();
bool sub_295_4096();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_295_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    // 287: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 288: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 289: call
    {
        sub_55_85();
    }
    // 290: call
    {
        sub_93_106();
    }
    // 291: call
    {
        sub_45_55();
    }
    // 292: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 293: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 294: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_295_4096() {
    uint jmp_to = 295u;
    while (true) {
        switch (jmp_to) {
        case 295u: {
            // 295: call
            {
                sub_287_295();
            }
            // 296: mul
            vs_out_attr2 = mul_safe(uniforms.f[95].zzzz, reg_tmp12);
            // 297: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 298: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 299: call
            {
                sub_287_295();
            }
            // 300: max
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            // 301: mul
            vs_out_attr2.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            // 302: max
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            // 303: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 5559C668488A7AE4, ADF51D558C5C687C
// shader: 8B30, F8E3F85C32F82C39

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) + (primary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((secondary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb) + (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 4.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor1.g), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 18948A72698A4277, F8E3F85C32F82C39
// program: ADF51D558C5C687C, C6949C8D76FDEB0C, F8E3F85C32F82C39
// shader: 8B30, FAD9BA2087038FE2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 87752AE83E07A3F4, FAD9BA2087038FE2
// program: CEC65C588F867703, C6949C8D76FDEB0C, FAD9BA2087038FE2
// shader: 8B30, F15ED2A62316DD23

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA797F8CDEB7, F15ED2A62316DD23
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, F15ED2A62316DD23
// reference: 5559C66813578820, ADF51D558C5C687C
// shader: 8B30, BB79207F3D69CB32

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 87752AE89B38DD3C, BB79207F3D69CB32
// program: 03E74703A3994B36, C6949C8D76FDEB0C, BB79207F3D69CB32
// shader: 8B30, 797842CE1438428B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4E4D91A666B7FB46, 797842CE1438428B
// program: 03E74703A3994B36, C6949C8D76FDEB0C, 797842CE1438428B
// shader: 8B30, 346D4FE30C619F85

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 685436FC9EE199AC, 346D4FE30C619F85
// program: D968087671A07D60, C6949C8D76FDEB0C, 346D4FE30C619F85
// shader: 8B30, 6FC8A92998A1A3BC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA799EE199AC, 6FC8A92998A1A3BC
// program: D968087671A07D60, C6949C8D76FDEB0C, 6FC8A92998A1A3BC
// shader: 8B30, 667740C20FA58712

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E68725672AF, 667740C20FA58712
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 667740C20FA58712
// shader: 8B30, 04B5665391DF0B1A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C5388A5955436F24, 04B5665391DF0B1A
// program: 03E74703A3994B36, C6949C8D76FDEB0C, 04B5665391DF0B1A
// shader: 8B31, C22CA707D64481B9

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_223_4096();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_223_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_223_4096() {
    uint jmp_to = 223u;
    while (true) {
        switch (jmp_to) {
        case 223u: {
            // 223: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 224: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 225: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 226: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 227: call
            {
                sub_55_85();
            }
            // 228: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 229: call
            {
                sub_93_106();
            }
            // 230: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 231: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 232: call
            {
                sub_45_55();
            }
            // 233: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 234: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 235: mul
            vs_out_attr5 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            // 236: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 237: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 238: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 239: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 240: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 241: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 242: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 243: call
            {
                sub_55_85();
            }
            // 244: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 245: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 246: call
            {
                sub_45_55();
            }
            // 247: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 248: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            // 249: mul
            reg_tmp13 = mul_safe(uniforms.f[95].yyyy, vs_in_reg3);
            // 250: mov
            reg_tmp14 = uniforms.f[71];
            // 251: mad
            reg_tmp13 = fma_safe(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 252: rcp
            reg_tmp12 = vec4(rcp_safe(reg_tmp10.wwww.x));
            // 253: mul
            reg_tmp12 = mul_safe(reg_tmp10, reg_tmp12);
            // 254: mov
            reg_tmp14 = uniforms.f[72];
            // 255: mad
            reg_tmp12 = fma_safe(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 256: add
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            // 257: mad
            vs_out_attr2.xyz = (fma_safe(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 258: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 259: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 260: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 261: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 262: call
            {
                sub_55_85();
            }
            // 263: call
            {
                sub_45_55();
            }
            // 264: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 265: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 266: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 267: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 268: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 269: call
            {
                sub_55_85();
            }
            // 270: dp3
            reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 271: call
            {
                sub_45_55();
            }
            // 272: rsq
            reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
            // 273: dp3
            reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
            // 274: dp3
            reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
            // 275: dp3
            reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
            // 276: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
            // 277: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 278: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 279: dp3
            reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 280: call
            {
                sub_96_106();
            }
            // 281: max
            reg_tmp15 = max(reg_tmp1, -reg_tmp1);
            // 282: mul
            reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            // 283: min
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            // 284: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 285: add
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            // 286: mul
            reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            // 287: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 288: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 289: call
            {
                sub_55_85();
            }
            // 290: call
            {
                sub_93_106();
            }
            // 291: call
            {
                sub_45_55();
            }
            // 292: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 293: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 294: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 295: call
            {
                sub_287_295();
            }
            // 296: mul
            vs_out_attr2 = mul_safe(uniforms.f[95].zzzz, reg_tmp12);
            // 297: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 298: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 299: call
            {
                sub_287_295();
            }
            // 300: max
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            // 301: mul
            vs_out_attr2.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            // 302: max
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            // 303: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    // 287: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 288: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 289: call
    {
        sub_55_85();
    }
    // 290: call
    {
        sub_93_106();
    }
    // 291: call
    {
        sub_45_55();
    }
    // 292: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 293: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 294: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: DEB911C74E7705BB, C22CA707D64481B9
// shader: 8B30, 55FB9A494F8F5095

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 08EDF29AFAA695EB, 55FB9A494F8F5095
// program: C22CA707D64481B9, C6949C8D76FDEB0C, 55FB9A494F8F5095
// reference: 5559C66815AAF77F, C22CA707D64481B9
// shader: 8B31, F7B82B8F38E3FD2F

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_239_4096();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_239_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_239_4096() {
    uint jmp_to = 239u;
    while (true) {
        switch (jmp_to) {
        case 239u: {
            // 239: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 240: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 241: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 242: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 243: call
            {
                sub_55_85();
            }
            // 244: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 245: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 246: call
            {
                sub_45_55();
            }
            // 247: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 248: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            // 249: mul
            reg_tmp13 = mul_safe(uniforms.f[95].yyyy, vs_in_reg3);
            // 250: mov
            reg_tmp14 = uniforms.f[71];
            // 251: mad
            reg_tmp13 = fma_safe(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 252: rcp
            reg_tmp12 = vec4(rcp_safe(reg_tmp10.wwww.x));
            // 253: mul
            reg_tmp12 = mul_safe(reg_tmp10, reg_tmp12);
            // 254: mov
            reg_tmp14 = uniforms.f[72];
            // 255: mad
            reg_tmp12 = fma_safe(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 256: add
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            // 257: mad
            vs_out_attr2.xyz = (fma_safe(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 258: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 259: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 260: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 261: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 262: call
            {
                sub_55_85();
            }
            // 263: call
            {
                sub_45_55();
            }
            // 264: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 265: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 266: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 267: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 268: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 269: call
            {
                sub_55_85();
            }
            // 270: dp3
            reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 271: call
            {
                sub_45_55();
            }
            // 272: rsq
            reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
            // 273: dp3
            reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
            // 274: dp3
            reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
            // 275: dp3
            reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
            // 276: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
            // 277: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 278: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 279: dp3
            reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 280: call
            {
                sub_96_106();
            }
            // 281: max
            reg_tmp15 = max(reg_tmp1, -reg_tmp1);
            // 282: mul
            reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            // 283: min
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            // 284: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 285: add
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            // 286: mul
            reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            // 287: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 288: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 289: call
            {
                sub_55_85();
            }
            // 290: call
            {
                sub_93_106();
            }
            // 291: call
            {
                sub_45_55();
            }
            // 292: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 293: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 294: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 295: call
            {
                sub_287_295();
            }
            // 296: mul
            vs_out_attr2 = mul_safe(uniforms.f[95].zzzz, reg_tmp12);
            // 297: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 298: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 299: call
            {
                sub_287_295();
            }
            // 300: max
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            // 301: mul
            vs_out_attr2.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            // 302: max
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            // 303: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    // 287: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 288: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 289: call
    {
        sub_55_85();
    }
    // 290: call
    {
        sub_93_106();
    }
    // 291: call
    {
        sub_45_55();
    }
    // 292: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 293: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 294: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 5559C668D3F2F53C, F7B82B8F38E3FD2F
// shader: 8B30, 0434BB9A902225D3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.g) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (combiner_buffer.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (texcolor0.g), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3DC61B7B4C43A19B, 0434BB9A902225D3
// program: F7B82B8F38E3FD2F, C6949C8D76FDEB0C, 0434BB9A902225D3
// reference: 5559C6684E7705BB, C22CA707D64481B9
// shader: 8B30, 4F8A51C11CDDB164

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 08EDF29A9193C73E, 4F8A51C11CDDB164
// program: C22CA707D64481B9, C6949C8D76FDEB0C, 4F8A51C11CDDB164
// shader: 8B30, 71D7A546D765E63F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3BD5A2EDF5D4CB79, 71D7A546D765E63F
// program: D968087671A07D60, C6949C8D76FDEB0C, 71D7A546D765E63F
// shader: 8B30, C5F5DC4B5355F4C7

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF9F00D8FE9, C5F5DC4B5355F4C7
// program: 03E74703A3994B36, C6949C8D76FDEB0C, C5F5DC4B5355F4C7
// shader: 8B30, 08350101C113266A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1DCC05B70D82A993, 08350101C113266A
// program: 03E74703A3994B36, C6949C8D76FDEB0C, 08350101C113266A
// shader: 8B30, 66883CA31BB02E0B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E68F5D4CB79, 66883CA31BB02E0B
// program: D968087671A07D60, C6949C8D76FDEB0C, 66883CA31BB02E0B
// shader: 8B30, 273EAA6A4B493CFD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6841F96C8BB01523, 273EAA6A4B493CFD
// program: C22CA707D64481B9, C6949C8D76FDEB0C, 273EAA6A4B493CFD
// shader: 8B30, 3EC4D27C89E4DCFE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.g) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (combiner_buffer.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (texcolor0.g), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5D6A108D3D552153, 3EC4D27C89E4DCFE
// program: F7B82B8F38E3FD2F, C6949C8D76FDEB0C, 3EC4D27C89E4DCFE
// shader: 8B30, 549FC625802F3389

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6841F96CE08547F6, 549FC625802F3389
// program: C22CA707D64481B9, C6949C8D76FDEB0C, 549FC625802F3389
// shader: 8B30, 2D569BB5141E378A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E681963207A, 2D569BB5141E378A
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 2D569BB5141E378A
// shader: 8B30, 38543B667FD5395F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E5871A9F7BD079A5, 38543B667FD5395F
// program: C22CA707D64481B9, C6949C8D76FDEB0C, 38543B667FD5395F
// shader: 8B30, 5CFAFADD53F6510F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.g) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (combiner_buffer.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (texcolor0.g), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D0ACF37ECD354DD5, 5CFAFADD53F6510F
// program: F7B82B8F38E3FD2F, C6949C8D76FDEB0C, 5CFAFADD53F6510F
// shader: 8B30, 06B58CED2DC5C404

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E5871A9F10E52B70, 06B58CED2DC5C404
// program: C22CA707D64481B9, C6949C8D76FDEB0C, 06B58CED2DC5C404
// shader: 8B30, 588DE01846301D8C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B6933CA02B727532, 588DE01846301D8C
// program: D968087671A07D60, C6949C8D76FDEB0C, 588DE01846301D8C
// reference: DEB911C712DAA7B2, F68537DD3A9B4EE5
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 66883CA31BB02E0B
// reference: DEB911C736BCE793, E0291A49851DDE8E
// shader: 8B30, CE5B8240AB9BB90D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F4748171F00D8FE9, CE5B8240AB9BB90D
// program: E0291A49851DDE8E, C6949C8D76FDEB0C, CE5B8240AB9BB90D
// shader: 8B30, 14765274BC93D938

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8D450D8EFFCB62AA, 14765274BC93D938
// program: BE4A1B4EC9120F38, C6949C8D76FDEB0C, 14765274BC93D938
// shader: 8B30, C95D55909A0671D9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E68A98B29CC, C95D55909A0671D9
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, C95D55909A0671D9
// shader: 8B30, 7DAD979F23BFC653

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F4748171AC526D5C, 7DAD979F23BFC653
// program: E0291A49851DDE8E, C6949C8D76FDEB0C, 7DAD979F23BFC653
// shader: 8B30, 8F9312CFE9452B50

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E68453CC2CF, 8F9312CFE9452B50
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 8F9312CFE9452B50
// shader: 8B30, 44694177B00C6213

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: EE1B2FAC4E2340EE, 44694177B00C6213
// program: BE4A1B4EC9120F38, C6949C8D76FDEB0C, 44694177B00C6213
// shader: 8B30, 7D2B195E2C58F619

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B6933CA0772D9787, 7D2B195E2C58F619
// program: D968087671A07D60, C6949C8D76FDEB0C, 7D2B195E2C58F619
// shader: 8B30, 9536826188CC1F19

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3BD5A2EDA98B29CC, 9536826188CC1F19
// program: D968087671A07D60, C6949C8D76FDEB0C, 9536826188CC1F19
// shader: 8B30, 5861C2FC9B04FF5F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF9AC526D5C, 5861C2FC9B04FF5F
// program: 03E74703A3994B36, C6949C8D76FDEB0C, 5861C2FC9B04FF5F
// shader: 8B30, 40DCF16B0B94138B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1DCC05B751DD4B26, 40DCF16B0B94138B
// program: 03E74703A3994B36, C6949C8D76FDEB0C, 40DCF16B0B94138B
// program: D968087671A07D60, C6949C8D76FDEB0C, C95D55909A0671D9
// shader: 8B30, 9181688AE3A5D689

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 038E7DB1FFCB62AA, 9181688AE3A5D689
// program: BE4A1B4EC9120F38, C6949C8D76FDEB0C, 9181688AE3A5D689
// shader: 8B30, 9594D15CAD44A3A5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) + (primary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((secondary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb) + (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 4.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor1.g), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4BAF5424CC871131, 9594D15CAD44A3A5
// program: ADF51D558C5C687C, C6949C8D76FDEB0C, 9594D15CAD44A3A5
// shader: 8B30, CEA8B21231FC2428

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF93E07A3F4, CEA8B21231FC2428
// program: CEC65C588F867703, C6949C8D76FDEB0C, CEA8B21231FC2428
// shader: 8B30, 4A8A014214673BAC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E687F8CDEB7, 4A8A014214673BAC
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 4A8A014214673BAC
// shader: 8B30, 7D03C725FB5FD6D4

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E68933B35B4, 7D03C725FB5FD6D4
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 7D03C725FB5FD6D4
// shader: 8B30, 94FDF13C1E6459FC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B6933CA04D9D8BFF, 94FDF13C1E6459FC
// program: D968087671A07D60, C6949C8D76FDEB0C, 94FDF13C1E6459FC
// shader: 8B30, E150E5D8139F30F9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3BD5A2ED933B35B4, E150E5D8139F30F9
// program: D968087671A07D60, C6949C8D76FDEB0C, E150E5D8139F30F9
// shader: 8B30, 40DB92ED36589F1F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF996E27124, 40DB92ED36589F1F
// program: 03E74703A3994B36, C6949C8D76FDEB0C, 40DB92ED36589F1F
// shader: 8B30, 70DB418519673C8B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1DCC05B76B6D575E, 70DB418519673C8B
// program: 03E74703A3994B36, C6949C8D76FDEB0C, 70DB418519673C8B
// program: D968087671A07D60, C6949C8D76FDEB0C, 7D03C725FB5FD6D4
// shader: 8B31, E87BAF26AB4FA2AA

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_392_400();
bool sub_400_4096();

bool exec_shader() {
    sub_400_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
bool sub_400_4096() {
    uint jmp_to = 400u;
    while (true) {
        switch (jmp_to) {
        case 400u: {
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
// reference: 5559C668BE138D04, E87BAF26AB4FA2AA
// shader: 8B30, C89DF03B25396EB3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 91CA33AE963E09B8, C89DF03B25396EB3
// program: E87BAF26AB4FA2AA, C6949C8D76FDEB0C, C89DF03B25396EB3
// reference: 5559C668E5CE7FC0, E87BAF26AB4FA2AA
// shader: 8B30, E1E54D13454F8BB8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1588FC1DCE0D59BE, E1E54D13454F8BB8
// program: E87BAF26AB4FA2AA, C6949C8D76FDEB0C, E1E54D13454F8BB8
// shader: 8B30, 38730DF15C45AF38

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp(min((texcolor2.rgb) + (last_tex_env_out.aaa), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor2.a) + (last_tex_env_out.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5EF0D5E9C44B4BAE, 38730DF15C45AF38
// program: E87BAF26AB4FA2AA, C6949C8D76FDEB0C, 38730DF15C45AF38
// shader: 8B31, 4EE01C8FDC7FEA38

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_21_55();
bool sub_51_53();
bool sub_53_54();
bool sub_450_4096();

bool exec_shader() {
    sub_450_4096();
    return true;
}

bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_450_4096() {
    uint jmp_to = 450u;
    while (true) {
        switch (jmp_to) {
        case 450u: {
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
// reference: 5559C668F1AF5D8B, 4EE01C8FDC7FEA38
// shader: 8B30, BB31383921E6597C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C19772B4E2CF9AF9, BB31383921E6597C
// program: 4EE01C8FDC7FEA38, C6949C8D76FDEB0C, BB31383921E6597C
// shader: 8B30, F594E44C03CCF198

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb) + (const_color[3].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[4].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.r) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6412DCB7151EB849, F594E44C03CCF198
// program: C8A7575AACF62C13, C6949C8D76FDEB0C, F594E44C03CCF198
// shader: 8B31, AA6A2F790F23E221

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_21_55();
bool sub_51_53();
bool sub_53_54();
bool sub_466_4096();

bool exec_shader() {
    sub_466_4096();
    return true;
}

bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_466_4096() {
    uint jmp_to = 466u;
    while (true) {
        switch (jmp_to) {
        case 466u: {
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
// reference: 5559C66805485E75, AA6A2F790F23E221
// shader: 8B30, AA46D9713A965BA8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(min((primary_fragment_color.rgb) + (texcolor1.rgb), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3F7A3161B1A9BC5F, AA46D9713A965BA8
// program: AA6A2F790F23E221, C6949C8D76FDEB0C, AA46D9713A965BA8
// shader: 8B30, 063F9247102E4622

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0E13E2D35AC631EC, 063F9247102E4622
// program: BE4A1B4EC9120F38, C6949C8D76FDEB0C, 063F9247102E4622
// shader: 8B30, D0B30521A9BE563F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7EC669E37ACCF570, D0B30521A9BE563F
// program: E87BAF26AB4FA2AA, C6949C8D76FDEB0C, D0B30521A9BE563F
// reference: DEB911C7882F07F8, F7B82B8F38E3FD2F
// shader: 8B30, C1CAAC79239FC0FE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4377B0252B727532, C1CAAC79239FC0FE
// program: D968087671A07D60, C6949C8D76FDEB0C, C1CAAC79239FC0FE
// reference: 5559C668882F07F8, F7B82B8F38E3FD2F
// shader: 8B31, 48E424E9C9E4608E

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_187_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_187_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_187_4096() {
    uint jmp_to = 187u;
    while (true) {
        switch (jmp_to) {
        case 187u: {
            // 187: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 188: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 189: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 190: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            // 191: call
            {
                sub_55_85();
            }
            // 192: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            // 193: call
            {
                sub_93_106();
            }
            // 194: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            // 195: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 196: call
            {
                sub_45_55();
            }
            // 197: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 198: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 199: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            // 200: ifu
            if (uniforms.b[0]) {
                sub_201_219();
            }
            // 219: mad
            vs_out_attr5.zw = (fma_safe(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            // 220: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 221: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 222: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 223: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 224: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 225: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 226: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 227: call
            {
                sub_55_85();
            }
            // 228: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 229: call
            {
                sub_93_106();
            }
            // 230: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 231: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 232: call
            {
                sub_45_55();
            }
            // 233: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 234: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 235: mul
            vs_out_attr5 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            // 236: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 237: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 238: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 239: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 240: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 241: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 242: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 243: call
            {
                sub_55_85();
            }
            // 244: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 245: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 246: call
            {
                sub_45_55();
            }
            // 247: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 248: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            // 249: mul
            reg_tmp13 = mul_safe(uniforms.f[95].yyyy, vs_in_reg3);
            // 250: mov
            reg_tmp14 = uniforms.f[71];
            // 251: mad
            reg_tmp13 = fma_safe(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 252: rcp
            reg_tmp12 = vec4(rcp_safe(reg_tmp10.wwww.x));
            // 253: mul
            reg_tmp12 = mul_safe(reg_tmp10, reg_tmp12);
            // 254: mov
            reg_tmp14 = uniforms.f[72];
            // 255: mad
            reg_tmp12 = fma_safe(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 256: add
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            // 257: mad
            vs_out_attr2.xyz = (fma_safe(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 258: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 259: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 260: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 261: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 262: call
            {
                sub_55_85();
            }
            // 263: call
            {
                sub_45_55();
            }
            // 264: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 265: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 266: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 267: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 268: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 269: call
            {
                sub_55_85();
            }
            // 270: dp3
            reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 271: call
            {
                sub_45_55();
            }
            // 272: rsq
            reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
            // 273: dp3
            reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
            // 274: dp3
            reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
            // 275: dp3
            reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
            // 276: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
            // 277: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 278: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 279: dp3
            reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 280: call
            {
                sub_96_106();
            }
            // 281: max
            reg_tmp15 = max(reg_tmp1, -reg_tmp1);
            // 282: mul
            reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            // 283: min
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            // 284: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 285: add
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            // 286: mul
            reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            // 287: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 288: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 289: call
            {
                sub_55_85();
            }
            // 290: call
            {
                sub_93_106();
            }
            // 291: call
            {
                sub_45_55();
            }
            // 292: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 293: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 294: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 295: call
            {
                sub_287_295();
            }
            // 296: mul
            vs_out_attr2 = mul_safe(uniforms.f[95].zzzz, reg_tmp12);
            // 297: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 298: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 299: call
            {
                sub_287_295();
            }
            // 300: max
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            // 301: mul
            vs_out_attr2.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            // 302: max
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            // 303: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    // 201: mov
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    // 202: mov
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    // 203: mov
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    // 204: mul
    reg_tmp6.xyz = (mul_safe(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    // 205: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    // 206: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    // 207: add
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    // 208: dp3
    reg_tmp13.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
    // 209: rsq
    reg_tmp13.y = rsq_safe(reg_tmp13.xxxx.x);
    // 210: mul
    reg_tmp4 = mul_safe(reg_tmp12, -reg_tmp13.yyyy);
    // 211: dp3
    reg_tmp14.x = dot(vec3(reg_tmp4), vec3(reg_tmp7));
    // 212: mul
    reg_tmp14.y = (mul_safe(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    // 213: mad
    reg_tmp5 = fma_safe(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    // 214: add
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    // 215: dp3
    reg_tmp12.w = dot(vec3(reg_tmp12.xyzz), vec3(reg_tmp12.xyzz));
    // 216: rsq
    reg_tmp14.z = rsq_safe(reg_tmp12.wwww.x);
    // 217: mul
    reg_tmp12.xy = (mul_safe(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    // 218: mov
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    // 287: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 288: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 289: call
    {
        sub_55_85();
    }
    // 290: call
    {
        sub_93_106();
    }
    // 291: call
    {
        sub_45_55();
    }
    // 292: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 293: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 294: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 5559C668C93744A3, 48E424E9C9E4608E
// shader: 8B30, C2E3B313833D1012

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.r) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 2.0, alpha_output_4 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor2.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 282CA6CB83AEF8DC, C2E3B313833D1012
// program: 48E424E9C9E4608E, C6949C8D76FDEB0C, C2E3B313833D1012
// shader: 8B30, F988643EBC846807

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E68D61B57B7, F988643EBC846807
// program: 48E424E9C9E4608E, C6949C8D76FDEB0C, F988643EBC846807
// shader: 8B31, 28CB11CBFFCE91DF

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_121_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_121_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_121_4096() {
    uint jmp_to = 121u;
    while (true) {
        switch (jmp_to) {
        case 121u: {
            // 121: mul
            reg_tmp12 = mul_safe(uniforms.f[16], vs_in_reg0.xyxy);
            // 122: add
            reg_tmp12 = uniforms.f[13] + reg_tmp12;
            // 123: mov
            vs_out_attr2 = uniforms.f[12];
            // 124: mul
            reg_tmp14 = mul_safe(uniforms.f[15], vs_in_reg1);
            // 125: add
            reg_tmp13 = uniforms.f[93].yyyy + reg_tmp12.zwww;
            // 126: mul
            reg_tmp13 = mul_safe(uniforms.f[95].zzzz, reg_tmp13);
            // 127: add
            reg_tmp14.y = (uniforms.f[14].wwww + reg_tmp14).y;
            // 128: mul
            reg_tmp13 = mul_safe(uniforms.f[14], reg_tmp13);
            // 129: mov
            vs_out_attr0.xy = (reg_tmp12.xyyy).xy;
            // 130: mov
            vs_out_attr0.zw = (uniforms.f[93].xxxy).zw;
            // 131: add
            vs_out_attr3.xyz = (reg_tmp13 + reg_tmp14).xyz;
            // 132: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 133: call
            {
                sub_9_21();
            }
            // 134: mov
            reg_tmp0 = vs_in_reg1.xyyy;
            // 135: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 136: mov
            reg_tmp1 = vs_in_reg0.xyyy;
            // 137: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 138: mul
            reg_tmp13 = mul_safe(uniforms.f[12], vs_in_reg2);
            // 139: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[13]), vec3(reg_tmp0));
            // 140: dp3
            vs_out_attr3.yz = vec2(dot(vec3(uniforms.f[14]), vec3(reg_tmp0)));
            // 141: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 142: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[16]), vec3(reg_tmp1));
            // 143: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, reg_tmp13);
            // 144: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            // 145: call
            {
                sub_9_21();
            }
            // 146: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 147: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            // 148: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 149: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 150: call
            {
                sub_55_85();
            }
            // 151: call
            {
                sub_45_55();
            }
            // 152: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 153: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 154: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 155: call
            {
                sub_9_21();
            }
            // 156: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg1);
            // 157: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            // 158: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 159: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 160: call
            {
                sub_55_85();
            }
            // 161: call
            {
                sub_45_55();
            }
            // 162: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 163: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 164: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 165: call
            {
                sub_9_21();
            }
            // 166: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 167: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 168: mov
            vs_out_attr5.xy = (uniforms.f[93].xxxx).xy;
            // 169: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            // 170: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 171: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 172: call
            {
                sub_55_85();
            }
            // 173: call
            {
                sub_45_55();
            }
            // 174: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 175: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 176: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 177: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 178: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 179: call
            {
                sub_55_85();
            }
            // 180: call
            {
                sub_45_55();
            }
            // 181: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 182: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 183: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 184: call
            {
                sub_9_21();
            }
            // 185: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 186: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 187: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 188: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 189: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 190: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            // 191: call
            {
                sub_55_85();
            }
            // 192: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            // 193: call
            {
                sub_93_106();
            }
            // 194: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            // 195: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 196: call
            {
                sub_45_55();
            }
            // 197: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 198: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 199: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            // 200: ifu
            if (uniforms.b[0]) {
                sub_201_219();
            }
            // 219: mad
            vs_out_attr5.zw = (fma_safe(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            // 220: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 221: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 222: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 223: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 224: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 225: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 226: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 227: call
            {
                sub_55_85();
            }
            // 228: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 229: call
            {
                sub_93_106();
            }
            // 230: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 231: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 232: call
            {
                sub_45_55();
            }
            // 233: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 234: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 235: mul
            vs_out_attr5 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            // 236: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 237: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 238: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 239: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 240: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 241: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 242: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 243: call
            {
                sub_55_85();
            }
            // 244: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 245: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 246: call
            {
                sub_45_55();
            }
            // 247: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 248: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            // 249: mul
            reg_tmp13 = mul_safe(uniforms.f[95].yyyy, vs_in_reg3);
            // 250: mov
            reg_tmp14 = uniforms.f[71];
            // 251: mad
            reg_tmp13 = fma_safe(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 252: rcp
            reg_tmp12 = vec4(rcp_safe(reg_tmp10.wwww.x));
            // 253: mul
            reg_tmp12 = mul_safe(reg_tmp10, reg_tmp12);
            // 254: mov
            reg_tmp14 = uniforms.f[72];
            // 255: mad
            reg_tmp12 = fma_safe(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 256: add
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            // 257: mad
            vs_out_attr2.xyz = (fma_safe(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 258: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 259: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 260: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 261: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 262: call
            {
                sub_55_85();
            }
            // 263: call
            {
                sub_45_55();
            }
            // 264: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 265: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 266: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 267: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 268: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 269: call
            {
                sub_55_85();
            }
            // 270: dp3
            reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 271: call
            {
                sub_45_55();
            }
            // 272: rsq
            reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
            // 273: dp3
            reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
            // 274: dp3
            reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
            // 275: dp3
            reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
            // 276: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
            // 277: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 278: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 279: dp3
            reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 280: call
            {
                sub_96_106();
            }
            // 281: max
            reg_tmp15 = max(reg_tmp1, -reg_tmp1);
            // 282: mul
            reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            // 283: min
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            // 284: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 285: add
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            // 286: mul
            reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            // 287: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 288: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 289: call
            {
                sub_55_85();
            }
            // 290: call
            {
                sub_93_106();
            }
            // 291: call
            {
                sub_45_55();
            }
            // 292: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 293: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 294: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 295: call
            {
                sub_287_295();
            }
            // 296: mul
            vs_out_attr2 = mul_safe(uniforms.f[95].zzzz, reg_tmp12);
            // 297: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 298: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 299: call
            {
                sub_287_295();
            }
            // 300: max
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            // 301: mul
            vs_out_attr2.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            // 302: max
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            // 303: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 494u: {
            // 494: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 495: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 500u: {
            // 500: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 501: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 502: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 503: mov
            vs_out_attr5.zw = (uniforms.f[93].xxxx).zw;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    // 201: mov
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    // 202: mov
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    // 203: mov
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    // 204: mul
    reg_tmp6.xyz = (mul_safe(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    // 205: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    // 206: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    // 207: add
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    // 208: dp3
    reg_tmp13.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
    // 209: rsq
    reg_tmp13.y = rsq_safe(reg_tmp13.xxxx.x);
    // 210: mul
    reg_tmp4 = mul_safe(reg_tmp12, -reg_tmp13.yyyy);
    // 211: dp3
    reg_tmp14.x = dot(vec3(reg_tmp4), vec3(reg_tmp7));
    // 212: mul
    reg_tmp14.y = (mul_safe(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    // 213: mad
    reg_tmp5 = fma_safe(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    // 214: add
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    // 215: dp3
    reg_tmp12.w = dot(vec3(reg_tmp12.xyzz), vec3(reg_tmp12.xyzz));
    // 216: rsq
    reg_tmp14.z = rsq_safe(reg_tmp12.wwww.x);
    // 217: mul
    reg_tmp12.xy = (mul_safe(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    // 218: mov
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    // 287: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 288: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 289: call
    {
        sub_55_85();
    }
    // 290: call
    {
        sub_93_106();
    }
    // 291: call
    {
        sub_45_55();
    }
    // 292: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 293: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 294: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 5559C668B8909126, 28CB11CBFFCE91DF
// shader: 8B30, 2D09DC48104EC2A5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((vec3(1.0) - last_tex_env_out.rgb) * (const_color[1].rrr) + (const_color[1].ggg), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a) + (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[2].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(0.0, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb) * (vec3(1.0) - (rounded_primary_color.bbb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((combiner_buffer.a) * (rounded_primary_color.a) + (last_tex_env_out.a) * (1.0 - (rounded_primary_color.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rrr) + (const_color[5].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.g), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4A6C58B94B836D0B, 2D09DC48104EC2A5
// program: 28CB11CBFFCE91DF, C6949C8D76FDEB0C, 2D09DC48104EC2A5
// reference: 5559C66838F4C2A5, 28CB11CBFFCE91DF
// reference: 5559C6684287435A, 03E74703A3994B36
// shader: 8B30, 99D126037AD58054

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1DCC05B7B0200DAC, 99D126037AD58054
// program: 03E74703A3994B36, C6949C8D76FDEB0C, 99D126037AD58054
// shader: 8B30, A405FBFC2AD8C6CC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FB6475BF11F6CD3E, A405FBFC2AD8C6CC
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, A405FBFC2AD8C6CC
// shader: 8B31, B43D121DECBD9E98

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_145_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_145_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_145_4096() {
    uint jmp_to = 145u;
    while (true) {
        switch (jmp_to) {
        case 145u: {
            // 145: call
            {
                sub_9_21();
            }
            // 146: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 147: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            // 148: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 149: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 150: call
            {
                sub_55_85();
            }
            // 151: call
            {
                sub_45_55();
            }
            // 152: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 153: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 154: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 155: call
            {
                sub_9_21();
            }
            // 156: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg1);
            // 157: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            // 158: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 159: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 160: call
            {
                sub_55_85();
            }
            // 161: call
            {
                sub_45_55();
            }
            // 162: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 163: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 164: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 165: call
            {
                sub_9_21();
            }
            // 166: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 167: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 168: mov
            vs_out_attr5.xy = (uniforms.f[93].xxxx).xy;
            // 169: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            // 170: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 171: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 172: call
            {
                sub_55_85();
            }
            // 173: call
            {
                sub_45_55();
            }
            // 174: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 175: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 176: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 177: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 178: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 179: call
            {
                sub_55_85();
            }
            // 180: call
            {
                sub_45_55();
            }
            // 181: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 182: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 183: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 184: call
            {
                sub_9_21();
            }
            // 185: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 186: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 187: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 188: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 189: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 190: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            // 191: call
            {
                sub_55_85();
            }
            // 192: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            // 193: call
            {
                sub_93_106();
            }
            // 194: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            // 195: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 196: call
            {
                sub_45_55();
            }
            // 197: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 198: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 199: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            // 200: ifu
            if (uniforms.b[0]) {
                sub_201_219();
            }
            // 219: mad
            vs_out_attr5.zw = (fma_safe(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            // 220: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 221: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 222: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 223: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 224: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 225: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 226: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 227: call
            {
                sub_55_85();
            }
            // 228: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 229: call
            {
                sub_93_106();
            }
            // 230: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 231: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 232: call
            {
                sub_45_55();
            }
            // 233: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 234: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 235: mul
            vs_out_attr5 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            // 236: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 237: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 238: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 239: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 240: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 241: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 242: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 243: call
            {
                sub_55_85();
            }
            // 244: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 245: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 246: call
            {
                sub_45_55();
            }
            // 247: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 248: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            // 249: mul
            reg_tmp13 = mul_safe(uniforms.f[95].yyyy, vs_in_reg3);
            // 250: mov
            reg_tmp14 = uniforms.f[71];
            // 251: mad
            reg_tmp13 = fma_safe(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 252: rcp
            reg_tmp12 = vec4(rcp_safe(reg_tmp10.wwww.x));
            // 253: mul
            reg_tmp12 = mul_safe(reg_tmp10, reg_tmp12);
            // 254: mov
            reg_tmp14 = uniforms.f[72];
            // 255: mad
            reg_tmp12 = fma_safe(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 256: add
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            // 257: mad
            vs_out_attr2.xyz = (fma_safe(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 258: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 259: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 260: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 261: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 262: call
            {
                sub_55_85();
            }
            // 263: call
            {
                sub_45_55();
            }
            // 264: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 265: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 266: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 267: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 268: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 269: call
            {
                sub_55_85();
            }
            // 270: dp3
            reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 271: call
            {
                sub_45_55();
            }
            // 272: rsq
            reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
            // 273: dp3
            reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
            // 274: dp3
            reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
            // 275: dp3
            reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
            // 276: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
            // 277: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 278: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 279: dp3
            reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 280: call
            {
                sub_96_106();
            }
            // 281: max
            reg_tmp15 = max(reg_tmp1, -reg_tmp1);
            // 282: mul
            reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            // 283: min
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            // 284: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 285: add
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            // 286: mul
            reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            // 287: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 288: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 289: call
            {
                sub_55_85();
            }
            // 290: call
            {
                sub_93_106();
            }
            // 291: call
            {
                sub_45_55();
            }
            // 292: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 293: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 294: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 295: call
            {
                sub_287_295();
            }
            // 296: mul
            vs_out_attr2 = mul_safe(uniforms.f[95].zzzz, reg_tmp12);
            // 297: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 298: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 299: call
            {
                sub_287_295();
            }
            // 300: max
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            // 301: mul
            vs_out_attr2.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            // 302: max
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            // 303: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 494u: {
            // 494: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 495: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 500u: {
            // 500: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 501: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 502: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 503: mov
            vs_out_attr5.zw = (uniforms.f[93].xxxx).zw;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    // 201: mov
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    // 202: mov
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    // 203: mov
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    // 204: mul
    reg_tmp6.xyz = (mul_safe(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    // 205: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    // 206: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    // 207: add
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    // 208: dp3
    reg_tmp13.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
    // 209: rsq
    reg_tmp13.y = rsq_safe(reg_tmp13.xxxx.x);
    // 210: mul
    reg_tmp4 = mul_safe(reg_tmp12, -reg_tmp13.yyyy);
    // 211: dp3
    reg_tmp14.x = dot(vec3(reg_tmp4), vec3(reg_tmp7));
    // 212: mul
    reg_tmp14.y = (mul_safe(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    // 213: mad
    reg_tmp5 = fma_safe(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    // 214: add
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    // 215: dp3
    reg_tmp12.w = dot(vec3(reg_tmp12.xyzz), vec3(reg_tmp12.xyzz));
    // 216: rsq
    reg_tmp14.z = rsq_safe(reg_tmp12.wwww.x);
    // 217: mul
    reg_tmp12.xy = (mul_safe(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    // 218: mov
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    // 287: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 288: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 289: call
    {
        sub_55_85();
    }
    // 290: call
    {
        sub_93_106();
    }
    // 291: call
    {
        sub_45_55();
    }
    // 292: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 293: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 294: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 5559C6685FDE14EA, B43D121DECBD9E98
// shader: 8B30, FA98806259EEFEB3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF958E85D39, FA98806259EEFEB3
// program: B43D121DECBD9E98, C6949C8D76FDEB0C, FA98806259EEFEB3
// reference: DEB911C7E5CE7FC0, E87BAF26AB4FA2AA
// shader: 8B30, 7EEF4287B00F7B7F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.g) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (combiner_buffer.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (texcolor0.g), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5D6A108D9F3D52B8, 7EEF4287B00F7B7F
// program: F7B82B8F38E3FD2F, C6949C8D76FDEB0C, 7EEF4287B00F7B7F
// shader: 8B30, 5A3829E94FFD4303

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6841F96C42ED341D, 5A3829E94FFD4303
// program: C22CA707D64481B9, C6949C8D76FDEB0C, 5A3829E94FFD4303
// shader: 8B31, 0EFB9F7F95A55908

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_170_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_170_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_170_4096() {
    uint jmp_to = 170u;
    while (true) {
        switch (jmp_to) {
        case 170u: {
            // 170: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 171: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 172: call
            {
                sub_55_85();
            }
            // 173: call
            {
                sub_45_55();
            }
            // 174: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 175: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 176: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 177: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 178: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 179: call
            {
                sub_55_85();
            }
            // 180: call
            {
                sub_45_55();
            }
            // 181: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 182: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 183: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 184: call
            {
                sub_9_21();
            }
            // 185: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 186: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 187: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 188: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 189: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 190: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            // 191: call
            {
                sub_55_85();
            }
            // 192: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            // 193: call
            {
                sub_93_106();
            }
            // 194: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            // 195: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 196: call
            {
                sub_45_55();
            }
            // 197: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 198: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 199: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            // 200: ifu
            if (uniforms.b[0]) {
                sub_201_219();
            }
            // 219: mad
            vs_out_attr5.zw = (fma_safe(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            // 220: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 221: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 222: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 223: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 224: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 225: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 226: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 227: call
            {
                sub_55_85();
            }
            // 228: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 229: call
            {
                sub_93_106();
            }
            // 230: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 231: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 232: call
            {
                sub_45_55();
            }
            // 233: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 234: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 235: mul
            vs_out_attr5 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            // 236: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 237: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 238: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 239: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 240: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 241: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 242: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 243: call
            {
                sub_55_85();
            }
            // 244: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 245: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 246: call
            {
                sub_45_55();
            }
            // 247: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 248: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            // 249: mul
            reg_tmp13 = mul_safe(uniforms.f[95].yyyy, vs_in_reg3);
            // 250: mov
            reg_tmp14 = uniforms.f[71];
            // 251: mad
            reg_tmp13 = fma_safe(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 252: rcp
            reg_tmp12 = vec4(rcp_safe(reg_tmp10.wwww.x));
            // 253: mul
            reg_tmp12 = mul_safe(reg_tmp10, reg_tmp12);
            // 254: mov
            reg_tmp14 = uniforms.f[72];
            // 255: mad
            reg_tmp12 = fma_safe(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 256: add
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            // 257: mad
            vs_out_attr2.xyz = (fma_safe(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 258: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 259: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 260: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 261: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 262: call
            {
                sub_55_85();
            }
            // 263: call
            {
                sub_45_55();
            }
            // 264: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 265: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 266: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 267: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 268: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 269: call
            {
                sub_55_85();
            }
            // 270: dp3
            reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 271: call
            {
                sub_45_55();
            }
            // 272: rsq
            reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
            // 273: dp3
            reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
            // 274: dp3
            reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
            // 275: dp3
            reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
            // 276: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
            // 277: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 278: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 279: dp3
            reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 280: call
            {
                sub_96_106();
            }
            // 281: max
            reg_tmp15 = max(reg_tmp1, -reg_tmp1);
            // 282: mul
            reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            // 283: min
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            // 284: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 285: add
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            // 286: mul
            reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            // 287: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 288: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 289: call
            {
                sub_55_85();
            }
            // 290: call
            {
                sub_93_106();
            }
            // 291: call
            {
                sub_45_55();
            }
            // 292: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 293: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 294: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 295: call
            {
                sub_287_295();
            }
            // 296: mul
            vs_out_attr2 = mul_safe(uniforms.f[95].zzzz, reg_tmp12);
            // 297: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 298: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 299: call
            {
                sub_287_295();
            }
            // 300: max
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            // 301: mul
            vs_out_attr2.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            // 302: max
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            // 303: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    // 201: mov
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    // 202: mov
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    // 203: mov
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    // 204: mul
    reg_tmp6.xyz = (mul_safe(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    // 205: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    // 206: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    // 207: add
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    // 208: dp3
    reg_tmp13.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
    // 209: rsq
    reg_tmp13.y = rsq_safe(reg_tmp13.xxxx.x);
    // 210: mul
    reg_tmp4 = mul_safe(reg_tmp12, -reg_tmp13.yyyy);
    // 211: dp3
    reg_tmp14.x = dot(vec3(reg_tmp4), vec3(reg_tmp7));
    // 212: mul
    reg_tmp14.y = (mul_safe(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    // 213: mad
    reg_tmp5 = fma_safe(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    // 214: add
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    // 215: dp3
    reg_tmp12.w = dot(vec3(reg_tmp12.xyzz), vec3(reg_tmp12.xyzz));
    // 216: rsq
    reg_tmp14.z = rsq_safe(reg_tmp12.wwww.x);
    // 217: mul
    reg_tmp12.xy = (mul_safe(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    // 218: mov
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    // 287: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 288: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 289: call
    {
        sub_55_85();
    }
    // 290: call
    {
        sub_93_106();
    }
    // 291: call
    {
        sub_45_55();
    }
    // 292: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 293: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 294: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 5559C6689294D51A, 0EFB9F7F95A55908
// shader: 8B30, 8EFA7376D27B3344

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0A45E4E68931B8A2, 8EFA7376D27B3344
// program: 0EFB9F7F95A55908, C6949C8D76FDEB0C, 8EFA7376D27B3344
// shader: 8B30, EB68CA2577823050

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FB6475BFFD41263D, EB68CA2577823050
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, EB68CA2577823050
// shader: 8B30, 69FEFCD90406EC2A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F0035C3B497554B1, 69FEFCD90406EC2A
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 69FEFCD90406EC2A
// shader: 8B30, 45BA782E9567FFAD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 922CCCAC66B09A9D, 45BA782E9567FFAD
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 45BA782E9567FFAD
// shader: 8B30, 53D819ED48EEDDF6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6992FC83F7605585, 53D819ED48EEDDF6
// program: E87BAF26AB4FA2AA, C6949C8D76FDEB0C, 53D819ED48EEDDF6
// shader: 8B30, 45FF0A3AD392A517

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 194777B3D76A9119, 45FF0A3AD392A517
// program: BE4A1B4EC9120F38, C6949C8D76FDEB0C, 45FF0A3AD392A517
// shader: 8B30, 8701E52551968231

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.r) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 2.0, alpha_output_4 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor2.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A958C6730E025829, 8701E52551968231
// program: 48E424E9C9E4608E, C6949C8D76FDEB0C, 8701E52551968231
// shader: 8B30, FAC1F16B057B3F4A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C0DD4210F562C607, FAC1F16B057B3F4A
// program: E87BAF26AB4FA2AA, C6949C8D76FDEB0C, FAC1F16B057B3F4A
// shader: 8B30, 7C3FB840DC5EFA1F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23,clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B008C920D568029B, 7C3FB840DC5EFA1F
// program: BE4A1B4EC9120F38, C6949C8D76FDEB0C, 7C3FB840DC5EFA1F
// shader: 8B30, 939333F0C0406E9D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17,clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.r) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 2.0, alpha_output_4 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor2.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3834EE921370FBED, 939333F0C0406E9D
// program: 48E424E9C9E4608E, C6949C8D76FDEB0C, 939333F0C0406E9D
// shader: 8B30, 9CE0B727B0939B0B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A382C82A39F55E54, 9CE0B727B0939B0B
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 9CE0B727B0939B0B
// shader: 8B30, CE6C87CA40D5022F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A8E5E1AE6176C7DB, CE6C87CA40D5022F
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, CE6C87CA40D5022F
// shader: 8B30, ABDEA722D7BFD102

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E6869E32A9F, ABDEA722D7BFD102
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, ABDEA722D7BFD102
// shader: 8B30, 293FFBD1A8830450

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FB6475BF1522F59C, 293FFBD1A8830450
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 293FFBD1A8830450
// shader: 8B30, 3636D902AC79A76B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F0035C3B39F55E54, 3636D902AC79A76B
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 3636D902AC79A76B
// reference: 5559C668E34D63E2, 28CB11CBFFCE91DF
// program: 28CB11CBFFCE91DF, C6949C8D76FDEB0C, 04B5665391DF0B1A
// shader: 8B30, 877AC00306FE7F67

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0C144701FDA77672, 877AC00306FE7F67
// program: C8A7575AACF62C13, C6949C8D76FDEB0C, 877AC00306FE7F67
// shader: 8B31, 31FA3CAC082DD8CC

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_184_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_184_4096();
    return true;
}

bool sub_9_21() {
    // 9: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 10: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 11: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 12: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 13: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 14: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 15: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 16: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 17: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 18: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 19: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 20: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    // 21: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 22: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 23: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 24: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 25: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    // 26: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 27: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 28: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 29: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 30: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 31: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 32: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 33: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 34: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 35: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 36: mov
    vs_out_attr4 = -reg_tmp9;
    // 37: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 38: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 39: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 40: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 41: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 42: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 43: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 44: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    // 45: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 46: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 47: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 48: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 49: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 50: ifc
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    // 54: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    // 51: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 52: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    // 53: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp8.xxxx)).x;
    // 56: dp4
    reg_tmp8.z = dot(uniforms.f[10 + address_registers.x], vs_in_reg0);
    // 57: dp4
    reg_tmp8.y = dot(uniforms.f[9 + address_registers.x], vs_in_reg0);
    // 58: dp4
    reg_tmp8.x = dot(uniforms.f[8 + address_registers.x], vs_in_reg0);
    // 59: mov
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    // 60: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10 + address_registers.x]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9 + address_registers.x]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8 + address_registers.x]), vec3(reg_tmp12));
    // 63: dphi
    reg_tmp9.z = dot(reg_tmp8, uniforms.f[6]);
    // 64: dphi
    reg_tmp9.y = dot(reg_tmp8, uniforms.f[5]);
    // 65: dphi
    reg_tmp9.x = dot(reg_tmp8, uniforms.f[4]);
    // 66: mov
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    // 67: dp3
    reg_tmp12.x = dot(vec3(reg_tmp7), vec3(reg_tmp7));
    // 68: dphi
    reg_tmp13.z = dot(reg_tmp9, uniforms.f[3]);
    // 69: dphi
    reg_tmp10.z = dot(reg_tmp9, uniforms.f[2]);
    // 70: dphi
    reg_tmp10.y = dot(reg_tmp9, uniforms.f[1]);
    // 71: dphi
    reg_tmp10.x = dot(reg_tmp9, uniforms.f[0]);
    // 72: mul
    reg_tmp13.xy = (mul_safe(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    // 73: rsq
    reg_tmp12.x = rsq_safe(reg_tmp12.xxxx.x);
    // 74: mov
    vs_out_attr4 = -reg_tmp9;
    // 75: cmp
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    // 76: mov
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    // 77: ifc
    if (all(conditional_code)) {
        sub_78_79();
    }
    // 79: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12.xxxx);
    // 80: mov
    vs_out_attr0 = reg_tmp10;
    // 81: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 82: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 83: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 84: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    return false;
}
bool sub_78_79() {
    // 78: mov
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    // 93: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 94: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 95: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    // 96: max
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    // 97: max
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    // 98: mul
    reg_tmp15 = mul_safe(reg_tmp15, reg_tmp15);
    // 99: mul
    reg_tmp14 = mul_safe(reg_tmp14, reg_tmp14);
    // 100: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    // 101: mul
    reg_tmp12.xyz = (mul_safe(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    // 102: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    // 103: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    // 104: mad
    reg_tmp13.xyz = (fma_safe(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    // 105: mad
    reg_tmp12.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_184_4096() {
    uint jmp_to = 184u;
    while (true) {
        switch (jmp_to) {
        case 184u: {
            // 184: call
            {
                sub_9_21();
            }
            // 185: mov
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            // 186: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 187: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 188: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 189: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 190: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            // 191: call
            {
                sub_55_85();
            }
            // 192: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            // 193: call
            {
                sub_93_106();
            }
            // 194: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            // 195: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 196: call
            {
                sub_45_55();
            }
            // 197: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 198: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 199: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            // 200: ifu
            if (uniforms.b[0]) {
                sub_201_219();
            }
            // 219: mad
            vs_out_attr5.zw = (fma_safe(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            // 220: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 221: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 222: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 223: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 224: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 225: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 226: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 227: call
            {
                sub_55_85();
            }
            // 228: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 229: call
            {
                sub_93_106();
            }
            // 230: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 231: add
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            // 232: call
            {
                sub_45_55();
            }
            // 233: add
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            // 234: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 235: mul
            vs_out_attr5 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            // 236: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 237: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 238: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 239: mul
            reg_tmp0 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 240: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 241: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 242: mul
            reg_tmp1.xyz = (mul_safe(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            // 243: call
            {
                sub_55_85();
            }
            // 244: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            // 245: mad
            reg_tmp1.xyz = (fma_safe(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            // 246: call
            {
                sub_45_55();
            }
            // 247: mul
            vs_out_attr3 = mul_safe(uniforms.f[95].yyyy, vs_in_reg2);
            // 248: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            // 249: mul
            reg_tmp13 = mul_safe(uniforms.f[95].yyyy, vs_in_reg3);
            // 250: mov
            reg_tmp14 = uniforms.f[71];
            // 251: mad
            reg_tmp13 = fma_safe(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 252: rcp
            reg_tmp12 = vec4(rcp_safe(reg_tmp10.wwww.x));
            // 253: mul
            reg_tmp12 = mul_safe(reg_tmp10, reg_tmp12);
            // 254: mov
            reg_tmp14 = uniforms.f[72];
            // 255: mad
            reg_tmp12 = fma_safe(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            // 256: add
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            // 257: mad
            vs_out_attr2.xyz = (fma_safe(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            // 258: mov
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            // 259: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 260: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 261: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 262: call
            {
                sub_55_85();
            }
            // 263: call
            {
                sub_45_55();
            }
            // 264: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            // 265: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 266: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 267: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 268: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 269: call
            {
                sub_55_85();
            }
            // 270: dp3
            reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 271: call
            {
                sub_45_55();
            }
            // 272: rsq
            reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
            // 273: dp3
            reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
            // 274: dp3
            reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
            // 275: dp3
            reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
            // 276: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
            // 277: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 278: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 279: dp3
            reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 280: call
            {
                sub_96_106();
            }
            // 281: max
            reg_tmp15 = max(reg_tmp1, -reg_tmp1);
            // 282: mul
            reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            // 283: min
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            // 284: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 285: add
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            // 286: mul
            reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            // 287: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 288: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 289: call
            {
                sub_55_85();
            }
            // 290: call
            {
                sub_93_106();
            }
            // 291: call
            {
                sub_45_55();
            }
            // 292: add
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            // 293: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 294: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 295: call
            {
                sub_287_295();
            }
            // 296: mul
            vs_out_attr2 = mul_safe(uniforms.f[95].zzzz, reg_tmp12);
            // 297: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 298: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 299: call
            {
                sub_287_295();
            }
            // 300: max
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            // 301: mul
            vs_out_attr2.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            // 302: max
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            // 303: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 304: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 305: call
            {
                sub_267_287();
            }
            // 306: mul
            vs_out_attr2.xyz = (mul_safe(reg_tmp12, reg_tmp2)).xyz;
            // 307: mov
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            // 308: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 309: mul
            reg_tmp2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 310: call
            {
                sub_267_287();
            }
            // 311: mul
            reg_tmp13.xyz = (mul_safe(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            // 312: mov
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            // 313: mad
            vs_out_attr2.xyz = (fma_safe(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            // 314: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 315: call
            {
                sub_21_55();
            }
            // 316: call
            {
                sub_93_106();
            }
            // 317: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 318: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 319: add
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            // 320: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 321: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 322: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 323: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 324: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 325: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 326: dp3
            reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
            // 327: dp3
            reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
            // 328: dp3
            reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
            // 329: dp4
            reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
            // 330: dp4
            reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
            // 331: dp4
            reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
            // 332: mov
            reg_tmp9.w = (reg_tmp8.wwww).w;
            // 333: dp3
            reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
            // 334: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
            // 335: rsq
            reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
            // 336: rsq
            reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
            // 337: mov
            vs_out_attr4 = -reg_tmp9;
            // 338: mul
            reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
            // 339: mov
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            // 340: mul
            reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
            // 341: dp3
            reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
            // 342: dp3
            reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
            // 343: dp3
            reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
            // 344: dp4
            vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
            // 345: dp4
            vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
            // 346: dp4
            vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
            // 347: dp4
            vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
            // 348: dp3
            reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
            // 349: add
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            // 350: mul
            reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
            // 351: cmp
            conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
            // 352: mul
            reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
            // 353: max
            reg_tmp0 = max(reg_tmp0, -reg_tmp0);
            // 354: rsq
            reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
            // 355: mul
            reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            // 356: ifc
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            // 360: min
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            // 361: mov
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            // 362: add
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            // 363: mul
            reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            // 364: call
            {
                sub_321_364();
            }
            // 365: mul
            reg_tmp15 = mul_safe(uniforms.f[94].zzzz, vs_in_reg3);
            // 366: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 367: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 368: mad
            vs_out_attr2 = fma_safe(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            // 369: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 370: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 371: call
            {
                sub_321_364();
            }
            // 372: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 373: mul
            vs_out_attr2 = mul_safe(uniforms.f[83], reg_tmp0.wwww);
            // 374: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            // 375: dp4
            vs_out_attr0.x = dot(uniforms.f[8], vs_in_reg0);
            // 376: dp4
            vs_out_attr0.y = dot(uniforms.f[9], vs_in_reg0);
            // 377: dp4
            vs_out_attr0.z = dot(uniforms.f[10], vs_in_reg0);
            // 378: dp4
            vs_out_attr0.w = dot(uniforms.f[11], vs_in_reg0);
            // 379: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 380: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
            // 381: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 382: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg1);
            // 383: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 384: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 385: call
            {
                sub_21_55();
            }
            // 386: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 387: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 388: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            // 389: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 390: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 391: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 392: mov
            reg_tmp0 = uniforms.f[13];
            // 393: mad
            reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            // 394: max
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            // 395: log
            reg_tmp12.x = log2(reg_tmp12.xxxx.x);
            // 396: mad
            reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            // 397: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 398: min
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            // 399: mad
            reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            // 400: dp4
            reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
            // 401: dp4
            reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
            // 402: dp4
            reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
            // 403: dp4
            reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
            // 404: callu
            if (uniforms.b[0]) {
                sub_392_400();
            }
            // 405: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
            // 406: call
            {
                sub_26_55();
            }
            // 407: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            // 408: mul
            vs_out_attr5.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 409: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 410: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg3);
            // 411: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 412: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 413: call
            {
                sub_9_21();
            }
            // 414: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg2);
            // 415: mul
            vs_out_attr3.xyz = (mul_safe(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            // 416: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            // 417: call
            {
                sub_21_55();
            }
            // 418: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 419: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 420: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 421: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 422: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 423: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 424: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 425: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 426: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 427: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 428: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 429: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[15]), vec3(reg_tmp1)));
            // 430: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 431: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 432: mov
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            // 433: mul
            reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
            // 434: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 435: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 436: call
            {
                sub_55_85();
            }
            // 437: call
            {
                sub_45_55();
            }
            // 438: add
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            // 439: add
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            // 440: add
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            // 441: add
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            // 442: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 443: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 444: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[83]), vec3(reg_tmp0));
            // 445: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[84]), vec3(reg_tmp0)));
            // 446: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[85]), vec3(reg_tmp1));
            // 447: dp3
            vs_out_attr5.yzw = vec3(dot(vec3(uniforms.f[86]), vec3(reg_tmp1)));
            // 448: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg4);
            // 449: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 450: call
            {
                sub_21_55();
            }
            // 451: mul
            reg_tmp0.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            // 452: mul
            reg_tmp1.xy = (mul_safe(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            // 453: mul
            vs_out_attr5.zw = (mul_safe(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            // 454: add
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            // 455: add
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            // 456: add
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            // 457: add
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            // 458: mov
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            // 459: mov
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            // 460: dp3
            vs_out_attr3.x = dot(vec3(uniforms.f[12]), vec3(reg_tmp0));
            // 461: dp3
            vs_out_attr3.yzw = vec3(dot(vec3(uniforms.f[13]), vec3(reg_tmp0)));
            // 462: dp3
            vs_out_attr5.x = dot(vec3(uniforms.f[14]), vec3(reg_tmp1));
            // 463: dp3
            vs_out_attr5.y = dot(vec3(uniforms.f[15]), vec3(reg_tmp1));
            // 464: mul
            vs_out_attr2 = mul_safe(uniforms.f[94].yyyy, vs_in_reg5);
            // 465: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 466: call
            {
                sub_21_55();
            }
            // 467: mul
            vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
            // 468: mul
            vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg3);
            // 469: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
            // 470: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            // 471: mov
            vs_out_attr0 = vs_in_reg0;
            // 472: mov
            vs_out_attr1 = vs_in_reg1;
            // 473: mov
            vs_out_attr2 = uniforms.f[93].yyyy;
            // 474: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 475: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            // 476: dphi
            reg_tmp9.z = dot(vs_in_reg0, uniforms.f[6]);
            // 477: mov
            vs_out_attr0 = vs_in_reg0;
            // 478: mov
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            // 479: add
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            // 480: add
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            // 481: max
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            // 482: min
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            // 483: mov
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            // 484: jmpu
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            // 485: mov
            vs_out_attr0 = uniforms.f[93].xxxx;
            // 486: mov
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            // 487: mov
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            // 488: mov
            vs_out_attr4 = uniforms.f[93].xxxx;
            // 489: mov
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            // 490: mov
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            // 491: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 492: end
            return true;
        }
        case 496u: {
            // 496: mov
            vs_out_attr3 = uniforms.f[93].xxxx;
            // 497: mov
            vs_out_attr5 = uniforms.f[93].xxxx;
            // 498: end
            return true;
        }
        case 504u: {
            // 504: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    // 201: mov
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    // 202: mov
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    // 203: mov
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    // 204: mul
    reg_tmp6.xyz = (mul_safe(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    // 205: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    // 206: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    // 207: add
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    // 208: dp3
    reg_tmp13.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
    // 209: rsq
    reg_tmp13.y = rsq_safe(reg_tmp13.xxxx.x);
    // 210: mul
    reg_tmp4 = mul_safe(reg_tmp12, -reg_tmp13.yyyy);
    // 211: dp3
    reg_tmp14.x = dot(vec3(reg_tmp4), vec3(reg_tmp7));
    // 212: mul
    reg_tmp14.y = (mul_safe(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    // 213: mad
    reg_tmp5 = fma_safe(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    // 214: add
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    // 215: dp3
    reg_tmp12.w = dot(vec3(reg_tmp12.xyzz), vec3(reg_tmp12.xyzz));
    // 216: rsq
    reg_tmp14.z = rsq_safe(reg_tmp12.wwww.x);
    // 217: mul
    reg_tmp12.xy = (mul_safe(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    // 218: mov
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    // 267: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 268: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 269: call
    {
        sub_55_85();
    }
    // 270: dp3
    reg_tmp13 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 271: call
    {
        sub_45_55();
    }
    // 272: rsq
    reg_tmp13 = vec4(rsq_safe(reg_tmp13.xxxx.x));
    // 273: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp7));
    // 274: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp7));
    // 275: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp7));
    // 276: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp13);
    // 277: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 278: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 279: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 280: call
    {
        sub_96_106();
    }
    // 281: max
    reg_tmp15 = max(reg_tmp1, -reg_tmp1);
    // 282: mul
    reg_tmp14.w = (mul_safe(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    // 283: min
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    // 284: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 285: add
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    // 286: mul
    reg_tmp12.w = (mul_safe(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    // 287: mov
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    // 288: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwwy, vs_in_reg1);
    // 289: call
    {
        sub_55_85();
    }
    // 290: call
    {
        sub_93_106();
    }
    // 291: call
    {
        sub_45_55();
    }
    // 292: add
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    // 293: mul
    vs_out_attr3 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    // 294: mul
    vs_out_attr5 = mul_safe(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    // 321: mul
    reg_tmp12 = mul_safe(uniforms.f[93].wwww, vs_in_reg1);
    // 322: dp4
    reg_tmp8.x = dot(uniforms.f[8], vs_in_reg0);
    // 323: dp4
    reg_tmp8.y = dot(uniforms.f[9], vs_in_reg0);
    // 324: dp4
    reg_tmp8.z = dot(uniforms.f[10], vs_in_reg0);
    // 325: dp4
    reg_tmp8.w = dot(uniforms.f[11], vs_in_reg0);
    // 326: dp3
    reg_tmp7.x = dot(vec3(uniforms.f[8]), vec3(reg_tmp12));
    // 327: dp3
    reg_tmp7.y = dot(vec3(uniforms.f[9]), vec3(reg_tmp12));
    // 328: dp3
    reg_tmp7.z = dot(vec3(uniforms.f[10]), vec3(reg_tmp12));
    // 329: dp4
    reg_tmp9.x = dot(uniforms.f[4], reg_tmp8);
    // 330: dp4
    reg_tmp9.y = dot(uniforms.f[5], reg_tmp8);
    // 331: dp4
    reg_tmp9.z = dot(uniforms.f[6], reg_tmp8);
    // 332: mov
    reg_tmp9.w = (reg_tmp8.wwww).w;
    // 333: dp3
    reg_tmp12 = vec4(dot(vec3(reg_tmp7), vec3(reg_tmp7)));
    // 334: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp9), vec3(reg_tmp9)));
    // 335: rsq
    reg_tmp12 = vec4(rsq_safe(reg_tmp12.xxxx.x));
    // 336: rsq
    reg_tmp0 = vec4(rsq_safe(reg_tmp0.xxxx.x));
    // 337: mov
    vs_out_attr4 = -reg_tmp9;
    // 338: mul
    reg_tmp7 = mul_safe(reg_tmp7, reg_tmp12);
    // 339: mov
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    // 340: mul
    reg_tmp0 = mul_safe(reg_tmp9, reg_tmp0);
    // 341: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[4]), vec3(reg_tmp7));
    // 342: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[5]), vec3(reg_tmp7));
    // 343: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[6]), vec3(reg_tmp7));
    // 344: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp9);
    // 345: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp9);
    // 346: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp9);
    // 347: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp9);
    // 348: dp3
    reg_tmp0 = vec4(dot(vec3(reg_tmp0), vec3(reg_tmp11)));
    // 349: add
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    // 350: mul
    reg_tmp15 = mul_safe(uniforms.f[95].zzzz, reg_tmp11);
    // 351: cmp
    conditional_code = equal(vec2(-uniforms.f[93].yyyy), vec2(reg_tmp11.zzzz));
    // 352: mul
    reg_tmp14 = mul_safe(uniforms.f[95].zzzz, reg_tmp14);
    // 353: max
    reg_tmp0 = max(reg_tmp0, -reg_tmp0);
    // 354: rsq
    reg_tmp14 = vec4(rsq_safe(reg_tmp14.xxxx.x));
    // 355: mul
    reg_tmp0.w = (mul_safe(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    // 356: ifc
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    // 360: min
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    // 361: mov
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    // 362: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    // 363: mul
    reg_tmp0.w = (mul_safe(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    // 357: rcp
    vs_out_attr1.z = rcp_safe(reg_tmp14.xxxx.x);
    // 358: mul
    vs_out_attr1.xy = (mul_safe(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    // 359: mov
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    // 392: mov
    reg_tmp0 = uniforms.f[13];
    // 393: mad
    reg_tmp12.xy = (fma_safe(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    // 394: max
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    // 395: log
    reg_tmp12.x = log2(reg_tmp12.xxxx.x);
    // 396: mad
    reg_tmp12.x = (fma_safe(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    // 397: max
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    // 398: min
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    // 399: mad
    reg_tmp8.z = (fma_safe(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 5559C668E38BF42B, 31FA3CAC082DD8CC
// shader: 8B30, 3700E3B9B691414A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA79808D850C, 3700E3B9B691414A
// program: 31FA3CAC082DD8CC, C6949C8D76FDEB0C, 3700E3B9B691414A
// shader: 8B30, 23AE548C19A012D0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E11FB89EB634CD24, 23AE548C19A012D0
// program: BE4A1B4EC9120F38, C6949C8D76FDEB0C, 23AE548C19A012D0
// shader: 8B30, 9A6BC7EFF1CA9E0D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA79AABF3B50, 9A6BC7EFF1CA9E0D
// program: 31FA3CAC082DD8CC, C6949C8D76FDEB0C, 9A6BC7EFF1CA9E0D
// shader: 8B30, 0351924729B6B224

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A8E5E1AE8DC12CD8, 0351924729B6B224
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 0351924729B6B224
// shader: 8B30, BA69A9E277823050

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FB6475BF65A2FF79, BA69A9E277823050
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, BA69A9E277823050
// shader: 8B30, E8BF5F544B593C65

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4D96F2E48B25128A, E8BF5F544B593C65
// program: E87BAF26AB4FA2AA, C6949C8D76FDEB0C, E8BF5F544B593C65
// shader: 8B30, 0A69A73EFFB2ABDD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp(min((texcolor2.rgb) + (last_tex_env_out.aaa), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor2.a) + (last_tex_env_out.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 82AC14A3D950509C, 0A69A73EFFB2ABDD
// program: E87BAF26AB4FA2AA, C6949C8D76FDEB0C, 0A69A73EFFB2ABDD
// shader: 8B30, BB4907D3482AF0E5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3D4379D4AB2FD616, BB4907D3482AF0E5
// program: BE4A1B4EC9120F38, C6949C8D76FDEB0C, BB4907D3482AF0E5
// shader: 8B30, 7A0AA9B04B808A2B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(min((primary_fragment_color.rgb) + (texcolor1.rgb), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E326F02BACB2A76D, 7A0AA9B04B808A2B
// program: AA6A2F790F23E221, C6949C8D76FDEB0C, 7A0AA9B04B808A2B
// shader: 8B30, F8B14EDCD12D4DD5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5F95D310FDA77672, F8B14EDCD12D4DD5
// program: C8A7575AACF62C13, C6949C8D76FDEB0C, F8B14EDCD12D4DD5
// shader: 8B30, 73A63255D5ACDCF1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb) + (const_color[3].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[4].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.r) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 76CEBC757D725B0C, 73A63255D5ACDCF1
// program: C8A7575AACF62C13, C6949C8D76FDEB0C, 73A63255D5ACDCF1
// shader: 8B30, 68187EA9BD479E65

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16,clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.r) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 2.0, alpha_output_4 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor2.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A958C6734C2056CD, 68187EA9BD479E65
// program: 48E424E9C9E4608E, C6949C8D76FDEB0C, 68187EA9BD479E65
// shader: 8B30, 34CE6510907A5611

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.r) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 2.0, alpha_output_4 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor2.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A83DC7FA6F5C0414, 34CE6510907A5611
// program: 48E424E9C9E4608E, C6949C8D76FDEB0C, 34CE6510907A5611
// shader: 8B30, F457C261152A0A82

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(min((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(1.0)) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((last_tex_env_out.a) + (last_tex_env_out.a), 1.0) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((const_color[4].rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D99EFA32F235B561, F457C261152A0A82
// program: BE4A1B4EC9120F38, C6949C8D76FDEB0C, F457C261152A0A82
// shader: 8B30, 12E8A009AB66D1A5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(min((primary_fragment_color.rgb) + (texcolor1.rgb), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3F7A31619B9B0203, 12E8A009AB66D1A5
// program: AA6A2F790F23E221, C6949C8D76FDEB0C, 12E8A009AB66D1A5
// shader: 8B30, 9AE49650A7114CD8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA79AF667FC0, 9AE49650A7114CD8
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 9AE49650A7114CD8
// shader: 8B30, 03062F6B5EC249F7

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A7F51560F00D8FE9, 03062F6B5EC249F7
// program: E0291A49851DDE8E, C6949C8D76FDEB0C, 03062F6B5EC249F7
// shader: 8B30, 45F8B4F1094AB356

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E11FB89E18E43F08, 45F8B4F1094AB356
// program: BE4A1B4EC9120F38, C6949C8D76FDEB0C, 45F8B4F1094AB356
// shader: 8B30, 6582C25E1E64387C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 91CA33AE38EEFB94, 6582C25E1E64387C
// program: E87BAF26AB4FA2AA, C6949C8D76FDEB0C, 6582C25E1E64387C
// shader: 8B30, 162CA17392B0A4D9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A7F51560AABF3B50, 162CA17392B0A4D9
// program: E0291A49851DDE8E, C6949C8D76FDEB0C, 162CA17392B0A4D9
// shader: 8B30, B30233D3F54712D7

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(min((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(1.0)) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((last_tex_env_out.a) + (last_tex_env_out.a), 1.0) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((const_color[4].rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D99EFA325CE5474D, B30233D3F54712D7
// program: BE4A1B4EC9120F38, C6949C8D76FDEB0C, B30233D3F54712D7
// shader: 8B30, A85E1D4B5DEC5B17

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20,clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21,clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22,clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.r) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 2.0, alpha_output_4 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor2.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A83DC7FAC18CF638, A85E1D4B5DEC5B17
// program: 48E424E9C9E4608E, C6949C8D76FDEB0C, A85E1D4B5DEC5B17
// shader: 8B30, D517444B8FCB7DD3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA79A98B29CC, D517444B8FCB7DD3
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, D517444B8FCB7DD3
// shader: 8B30, 69C118EE991006E3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA79453CC2CF, 69C118EE991006E3
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 69C118EE991006E3
// shader: 8B30, B10DD93042183A7A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA7943D194C3, B10DD93042183A7A
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, B10DD93042183A7A
// shader: 8B30, 723D41F0242C95FB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C1AD58BD3AEF7828, 723D41F0242C95FB
// program: F68537DD3A9B4EE5, C6949C8D76FDEB0C, 723D41F0242C95FB
