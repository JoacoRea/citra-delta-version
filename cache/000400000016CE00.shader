// shader: 8B31, DF4B86DFCB80860C

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_106_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_106_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_106_4096() {
    uint jmp_to = 106u;
    while (true) {
        switch (jmp_to) {
        case 106u: {
            {
                sub_9_21();
            }
            vs_out_attr3 = uniforms.f[12].yxwz + vs_in_reg1.yxyx;
            vs_out_attr5 = uniforms.f[13].yxwz + vs_in_reg1.yxyx;
            vs_out_attr2 = uniforms.f[80];
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = uniforms.f[13] + vs_in_reg0;
            vs_out_attr2 = mul_s(uniforms.f[12], vs_in_reg3);
            vs_out_attr3 = uniforms.f[17].xyyy + vs_in_reg1.xyyy;
            vs_out_attr5.xy = (uniforms.f[17].zwww + vs_in_reg1.zwww).xy;
            vs_out_attr5.zw = (uniforms.f[18].xyxy + vs_in_reg2.xyxy).zw;
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[16], vs_in_reg0.xyxy);
            reg_tmp12 = uniforms.f[13] + reg_tmp12;
            vs_out_attr2 = uniforms.f[12];
            reg_tmp14 = mul_s(uniforms.f[15], vs_in_reg1);
            reg_tmp13 = uniforms.f[93].yyyy + reg_tmp12.zwww;
            reg_tmp13 = mul_s(uniforms.f[95].zzzz, reg_tmp13);
            reg_tmp14.y = (uniforms.f[14].wwww + reg_tmp14).y;
            reg_tmp13 = mul_s(uniforms.f[14], reg_tmp13);
            vs_out_attr0.xy = (reg_tmp12.xyyy).xy;
            vs_out_attr0.zw = (uniforms.f[93].xxxy).zw;
            vs_out_attr3.xyz = (reg_tmp13 + reg_tmp14).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_9_21();
            }
            reg_tmp0 = vs_in_reg1.xyyy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1 = vs_in_reg0.xyyy;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp13 = mul_s(uniforms.f[12], vs_in_reg2);
            vs_out_attr3.x = dot_3(uniforms.f[13].xyz, reg_tmp0.xyz);
            vs_out_attr3.yz = vec2(dot_3(uniforms.f[14].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[16].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, reg_tmp13);
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg1);
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            vs_out_attr5.xy = (uniforms.f[93].xxxx).xy;
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            if (uniforms.b[0]) {
                sub_201_219();
            }
            vs_out_attr5.zw = (fma_s(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            {
                sub_45_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            reg_tmp13 = mul_s(uniforms.f[95].yyyy, vs_in_reg3);
            reg_tmp14 = uniforms.f[71];
            reg_tmp13 = fma_s(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            reg_tmp12 = vec4(rcp_s(reg_tmp10.w));
            reg_tmp12 = mul_s(reg_tmp10, reg_tmp12);
            reg_tmp14 = uniforms.f[72];
            reg_tmp12 = fma_s(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            vs_out_attr2.xyz = (fma_s(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            {
                sub_45_55();
            }
            reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
            reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
            reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
            reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            {
                sub_96_106();
            }
            reg_tmp15 = abs(reg_tmp1);
            reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_93_106();
            }
            {
                sub_45_55();
            }
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            {
                sub_287_295();
            }
            vs_out_attr2 = mul_s(uniforms.f[95].zzzz, reg_tmp12);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_287_295();
            }
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            vs_out_attr2.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 494u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 500u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5.zw = (uniforms.f[93].xxxx).zw;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    reg_tmp6.xyz = (mul_s(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    reg_tmp13.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp13.y = rsq_s(reg_tmp13.x);
    reg_tmp4 = mul_s(reg_tmp12, -reg_tmp13.yyyy);
    reg_tmp14.x = dot_3(reg_tmp4.xyz, reg_tmp7.xyz);
    reg_tmp14.y = (mul_s(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    reg_tmp5 = fma_s(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    reg_tmp12.w = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp14.z = rsq_s(reg_tmp12.w);
    reg_tmp12.xy = (mul_s(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    {
        sub_93_106();
    }
    {
        sub_45_55();
    }
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: DEB911C7BEE3B6E6, DF4B86DFCB80860C
// shader: 8DD9, AEA07E6271EAC2AC

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

in vec4 vs_out_attr0[];
in vec4 vs_out_attr1[];
in vec4 vs_out_attr2[];
in vec4 vs_out_attr3[];
in vec4 vs_out_attr4[];
in vec4 vs_out_attr5[];
struct Vertex {
    vec4 attributes[6];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z, vtx.attributes[2].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[3].x, vtx.attributes[3].y);
    texcoord1 = vec2(vtx.attributes[5].x, vtx.attributes[5].y);

    texcoord0_w = vtx.attributes[3].w;
    view = vec3(vtx.attributes[4].x, vtx.attributes[4].y, vtx.attributes[4].z);
    texcoord2 = vec2(vtx.attributes[5].z, vtx.attributes[5].w);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[6](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0], vs_out_attr5[0]);
    prim_buffer[1].attributes = vec4[6](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1], vs_out_attr5[1]);
    prim_buffer[2].attributes = vec4[6](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2], vs_out_attr5[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: A0CB59480533AF6A, AEA07E6271EAC2AC
// shader: 8B30, 7F73C7A8D6CFE3C5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (const_color[2].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9F999D4A0EF7A266, 7F73C7A8D6CFE3C5
// program: DF4B86DFCB80860C, AEA07E6271EAC2AC, 7F73C7A8D6CFE3C5
// reference: 90EDEE8766CB2250, DF4B86DFCB80860C
// shader: 8B30, 52E0E5A9CC931315

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (const_color[2].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (const_color[4].a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BEB80A3142E4567D, 52E0E5A9CC931315
// program: DF4B86DFCB80860C, AEA07E6271EAC2AC, 52E0E5A9CC931315
// shader: 8B31, E976850DD5B08ED7

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_113_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_113_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_113_4096() {
    uint jmp_to = 113u;
    while (true) {
        switch (jmp_to) {
        case 113u: {
            vs_out_attr0 = uniforms.f[13] + vs_in_reg0;
            vs_out_attr2 = mul_s(uniforms.f[12], vs_in_reg3);
            vs_out_attr3 = uniforms.f[17].xyyy + vs_in_reg1.xyyy;
            vs_out_attr5.xy = (uniforms.f[17].zwww + vs_in_reg1.zwww).xy;
            vs_out_attr5.zw = (uniforms.f[18].xyxy + vs_in_reg2.xyxy).zw;
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[16], vs_in_reg0.xyxy);
            reg_tmp12 = uniforms.f[13] + reg_tmp12;
            vs_out_attr2 = uniforms.f[12];
            reg_tmp14 = mul_s(uniforms.f[15], vs_in_reg1);
            reg_tmp13 = uniforms.f[93].yyyy + reg_tmp12.zwww;
            reg_tmp13 = mul_s(uniforms.f[95].zzzz, reg_tmp13);
            reg_tmp14.y = (uniforms.f[14].wwww + reg_tmp14).y;
            reg_tmp13 = mul_s(uniforms.f[14], reg_tmp13);
            vs_out_attr0.xy = (reg_tmp12.xyyy).xy;
            vs_out_attr0.zw = (uniforms.f[93].xxxy).zw;
            vs_out_attr3.xyz = (reg_tmp13 + reg_tmp14).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_9_21();
            }
            reg_tmp0 = vs_in_reg1.xyyy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1 = vs_in_reg0.xyyy;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp13 = mul_s(uniforms.f[12], vs_in_reg2);
            vs_out_attr3.x = dot_3(uniforms.f[13].xyz, reg_tmp0.xyz);
            vs_out_attr3.yz = vec2(dot_3(uniforms.f[14].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[16].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, reg_tmp13);
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg1);
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            vs_out_attr5.xy = (uniforms.f[93].xxxx).xy;
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            if (uniforms.b[0]) {
                sub_201_219();
            }
            vs_out_attr5.zw = (fma_s(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            {
                sub_45_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            reg_tmp13 = mul_s(uniforms.f[95].yyyy, vs_in_reg3);
            reg_tmp14 = uniforms.f[71];
            reg_tmp13 = fma_s(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            reg_tmp12 = vec4(rcp_s(reg_tmp10.w));
            reg_tmp12 = mul_s(reg_tmp10, reg_tmp12);
            reg_tmp14 = uniforms.f[72];
            reg_tmp12 = fma_s(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            vs_out_attr2.xyz = (fma_s(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            {
                sub_45_55();
            }
            reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
            reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
            reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
            reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            {
                sub_96_106();
            }
            reg_tmp15 = abs(reg_tmp1);
            reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_93_106();
            }
            {
                sub_45_55();
            }
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            {
                sub_287_295();
            }
            vs_out_attr2 = mul_s(uniforms.f[95].zzzz, reg_tmp12);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_287_295();
            }
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            vs_out_attr2.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 494u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 500u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5.zw = (uniforms.f[93].xxxx).zw;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    reg_tmp6.xyz = (mul_s(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    reg_tmp13.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp13.y = rsq_s(reg_tmp13.x);
    reg_tmp4 = mul_s(reg_tmp12, -reg_tmp13.yyyy);
    reg_tmp14.x = dot_3(reg_tmp4.xyz, reg_tmp7.xyz);
    reg_tmp14.y = (mul_s(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    reg_tmp5 = fma_s(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    reg_tmp12.w = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp14.z = rsq_s(reg_tmp12.w);
    reg_tmp12.xy = (mul_s(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    {
        sub_93_106();
    }
    {
        sub_45_55();
    }
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: DEB911C71ACB846F, E976850DD5B08ED7
// shader: 8B30, 736DFFBAB2E2A72A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF99B38DD3C, 736DFFBAB2E2A72A
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, 736DFFBAB2E2A72A
// reference: 90EDEE87C2E310D9, E976850DD5B08ED7
// shader: 8B30, 0CF09B57706EE136

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1DCC05B766B7FB46, 0CF09B57706EE136
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, 0CF09B57706EE136
// shader: 8B31, D86A087FD303196A

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_133_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_133_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_133_4096() {
    uint jmp_to = 133u;
    while (true) {
        switch (jmp_to) {
        case 133u: {
            {
                sub_9_21();
            }
            reg_tmp0 = vs_in_reg1.xyyy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1 = vs_in_reg0.xyyy;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp13 = mul_s(uniforms.f[12], vs_in_reg2);
            vs_out_attr3.x = dot_3(uniforms.f[13].xyz, reg_tmp0.xyz);
            vs_out_attr3.yz = vec2(dot_3(uniforms.f[14].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[16].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, reg_tmp13);
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg1);
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            vs_out_attr5.xy = (uniforms.f[93].xxxx).xy;
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            if (uniforms.b[0]) {
                sub_201_219();
            }
            vs_out_attr5.zw = (fma_s(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            {
                sub_45_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            reg_tmp13 = mul_s(uniforms.f[95].yyyy, vs_in_reg3);
            reg_tmp14 = uniforms.f[71];
            reg_tmp13 = fma_s(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            reg_tmp12 = vec4(rcp_s(reg_tmp10.w));
            reg_tmp12 = mul_s(reg_tmp10, reg_tmp12);
            reg_tmp14 = uniforms.f[72];
            reg_tmp12 = fma_s(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            vs_out_attr2.xyz = (fma_s(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            {
                sub_45_55();
            }
            reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
            reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
            reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
            reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            {
                sub_96_106();
            }
            reg_tmp15 = abs(reg_tmp1);
            reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_93_106();
            }
            {
                sub_45_55();
            }
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            {
                sub_287_295();
            }
            vs_out_attr2 = mul_s(uniforms.f[95].zzzz, reg_tmp12);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_287_295();
            }
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            vs_out_attr2.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 494u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 500u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5.zw = (uniforms.f[93].xxxx).zw;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    reg_tmp6.xyz = (mul_s(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    reg_tmp13.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp13.y = rsq_s(reg_tmp13.x);
    reg_tmp4 = mul_s(reg_tmp12, -reg_tmp13.yyyy);
    reg_tmp14.x = dot_3(reg_tmp4.xyz, reg_tmp7.xyz);
    reg_tmp14.y = (mul_s(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    reg_tmp5 = fma_s(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    reg_tmp12.w = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp14.z = rsq_s(reg_tmp12.w);
    reg_tmp12.xy = (mul_s(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    {
        sub_93_106();
    }
    {
        sub_45_55();
    }
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 90EDEE877BB854CB, D86A087FD303196A
// shader: 8B30, C9A6B567BF8FC76B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3BD5A2ED9EE199AC, C9A6B567BF8FC76B
// program: D86A087FD303196A, AEA07E6271EAC2AC, C9A6B567BF8FC76B
// shader: 8B30, 886326305217700F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E689EE199AC, 886326305217700F
// program: D86A087FD303196A, AEA07E6271EAC2AC, 886326305217700F
// reference: DEB911C7A390C07D, D86A087FD303196A
// shader: 8B31, 6A898B3A503366C0

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_21_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_417_4096();

bool exec_shader() {
    sub_417_4096();
    return true;
}

bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_417_4096() {
    uint jmp_to = 417u;
    while (true) {
        switch (jmp_to) {
        case 417u: {
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
// reference: DEB911C70F2789B6, 6A898B3A503366C0
// shader: 8B30, CC86C1290417BD54

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 96F061A71B81AF5D, CC86C1290417BD54
// program: 6A898B3A503366C0, AEA07E6271EAC2AC, CC86C1290417BD54
// shader: 8B31, A62C212E4E3A0D30

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_267_287();
bool sub_304_4096();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_304_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_304_4096() {
    uint jmp_to = 304u;
    while (true) {
        switch (jmp_to) {
        case 304u: {
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 90EDEE8746508A4D, A62C212E4E3A0D30
// shader: 8B30, 99002ABDB944F784

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (const_color[4].a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 383E5917A077DFCF, 99002ABDB944F784
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, 99002ABDB944F784
// shader: 8B31, 61D52BB702BDA513

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_21_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_432_4096();

bool exec_shader() {
    sub_432_4096();
    return true;
}

bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_432_4096() {
    uint jmp_to = 432u;
    while (true) {
        switch (jmp_to) {
        case 432u: {
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
// reference: 90EDEE878CAC8CB9, 61D52BB702BDA513
// shader: 8B30, C0490FE572F263CB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((combiner_buffer.rgb) * (primary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E500DDE4AFC2C10D, C0490FE572F263CB
// program: 61D52BB702BDA513, AEA07E6271EAC2AC, C0490FE572F263CB
// shader: 8B30, C575194A3DF5BA8F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (const_color[4].a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: DC01DEC4AF33E650, C575194A3DF5BA8F
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, C575194A3DF5BA8F
// shader: 8B30, 76BD2E17C3A1D5E8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((combiner_buffer.rgb) * (primary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 013F5A37A086F892, 76BD2E17C3A1D5E8
// program: 61D52BB702BDA513, AEA07E6271EAC2AC, 76BD2E17C3A1D5E8
// shader: 8B31, C5779815375CB1F0

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_148_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_148_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_148_4096() {
    uint jmp_to = 148u;
    while (true) {
        switch (jmp_to) {
        case 148u: {
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg1);
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            vs_out_attr5.xy = (uniforms.f[93].xxxx).xy;
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            if (uniforms.b[0]) {
                sub_201_219();
            }
            vs_out_attr5.zw = (fma_s(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            {
                sub_45_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            reg_tmp13 = mul_s(uniforms.f[95].yyyy, vs_in_reg3);
            reg_tmp14 = uniforms.f[71];
            reg_tmp13 = fma_s(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            reg_tmp12 = vec4(rcp_s(reg_tmp10.w));
            reg_tmp12 = mul_s(reg_tmp10, reg_tmp12);
            reg_tmp14 = uniforms.f[72];
            reg_tmp12 = fma_s(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            vs_out_attr2.xyz = (fma_s(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            {
                sub_45_55();
            }
            reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
            reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
            reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
            reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            {
                sub_96_106();
            }
            reg_tmp15 = abs(reg_tmp1);
            reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_93_106();
            }
            {
                sub_45_55();
            }
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            {
                sub_287_295();
            }
            vs_out_attr2 = mul_s(uniforms.f[95].zzzz, reg_tmp12);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_287_295();
            }
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            vs_out_attr2.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 494u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 500u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5.zw = (uniforms.f[93].xxxx).zw;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    reg_tmp6.xyz = (mul_s(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    reg_tmp13.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp13.y = rsq_s(reg_tmp13.x);
    reg_tmp4 = mul_s(reg_tmp12, -reg_tmp13.yyyy);
    reg_tmp14.x = dot_3(reg_tmp4.xyz, reg_tmp7.xyz);
    reg_tmp14.y = (mul_s(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    reg_tmp5 = fma_s(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    reg_tmp12.w = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp14.z = rsq_s(reg_tmp12.w);
    reg_tmp12.xy = (mul_s(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    {
        sub_93_106();
    }
    {
        sub_45_55();
    }
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 90EDEE87201BC572, C5779815375CB1F0
// shader: 8B30, 6932857FE200E2E2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 87752AE8286857DC, 6932857FE200E2E2
// program: C5779815375CB1F0, AEA07E6271EAC2AC, 6932857FE200E2E2
// reference: DEB911C79E781EFB, A62C212E4E3A0D30
// reference: 90EDEE87D70F1D00, 6A898B3A503366C0
// shader: 8B30, C2599BE7E8E95313

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C571F5B61B81AF5D, C2599BE7E8E95313
// program: 6A898B3A503366C0, AEA07E6271EAC2AC, C2599BE7E8E95313
// shader: 8B30, C1E3A3FAA42E46F1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D7AD957473ED4C18, C1E3A3FAA42E46F1
// program: 6A898B3A503366C0, AEA07E6271EAC2AC, C1E3A3FAA42E46F1
// shader: 8B31, 494C9A653BABAB04

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_165_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_165_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_165_4096() {
    uint jmp_to = 165u;
    while (true) {
        switch (jmp_to) {
        case 165u: {
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            vs_out_attr5.xy = (uniforms.f[93].xxxx).xy;
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            if (uniforms.b[0]) {
                sub_201_219();
            }
            vs_out_attr5.zw = (fma_s(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            {
                sub_45_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            reg_tmp13 = mul_s(uniforms.f[95].yyyy, vs_in_reg3);
            reg_tmp14 = uniforms.f[71];
            reg_tmp13 = fma_s(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            reg_tmp12 = vec4(rcp_s(reg_tmp10.w));
            reg_tmp12 = mul_s(reg_tmp10, reg_tmp12);
            reg_tmp14 = uniforms.f[72];
            reg_tmp12 = fma_s(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            vs_out_attr2.xyz = (fma_s(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            {
                sub_45_55();
            }
            reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
            reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
            reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
            reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            {
                sub_96_106();
            }
            reg_tmp15 = abs(reg_tmp1);
            reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_93_106();
            }
            {
                sub_45_55();
            }
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            {
                sub_287_295();
            }
            vs_out_attr2 = mul_s(uniforms.f[95].zzzz, reg_tmp12);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_287_295();
            }
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            vs_out_attr2.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 500u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5.zw = (uniforms.f[93].xxxx).zw;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    reg_tmp6.xyz = (mul_s(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    reg_tmp13.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp13.y = rsq_s(reg_tmp13.x);
    reg_tmp4 = mul_s(reg_tmp12, -reg_tmp13.yyyy);
    reg_tmp14.x = dot_3(reg_tmp4.xyz, reg_tmp7.xyz);
    reg_tmp14.y = (mul_s(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    reg_tmp5 = fma_s(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    reg_tmp12.w = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp14.z = rsq_s(reg_tmp12.w);
    reg_tmp12.xy = (mul_s(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    {
        sub_93_106();
    }
    {
        sub_45_55();
    }
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 90EDEE8749075576, 494C9A653BABAB04
// shader: 8B30, A95C3FE881A83086

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA798554C19C, A95C3FE881A83086
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, A95C3FE881A83086
// shader: 8B30, EC9D5166B0737658

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA7969E32A9F, EC9D5166B0737658
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, EC9D5166B0737658
// shader: 8B30, DAEEBBD1A9B37F29

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C1AD58BD16309078, DAEEBBD1A9B37F29
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, DAEEBBD1A9B37F29
// shader: 8B30, 99B7E16B3E9F1072

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (const_color[2].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CC18095B0EF7A266, 99B7E16B3E9F1072
// program: DF4B86DFCB80860C, AEA07E6271EAC2AC, 99B7E16B3E9F1072
// shader: 8B30, D9F536B964863E75

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (const_color[2].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (const_color[4].a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: ED399E2042E4567D, D9F536B964863E75
// program: DF4B86DFCB80860C, AEA07E6271EAC2AC, D9F536B964863E75
// shader: 8B30, F5148DDAACFDD502

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = (vec3(1.0) - last_tex_env_out.rgb);
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (const_color[2].a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 96B91E4855436F24, F5148DDAACFDD502
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, F5148DDAACFDD502
// reference: 90EDEE872065A60F, D86A087FD303196A
// reference: 90EDEE871D8D7889, A62C212E4E3A0D30
// reference: 90EDEE87D7717E7D, 61D52BB702BDA513
// reference: 90EDEE877BC637B6, C5779815375CB1F0
// reference: 90EDEE878CD2EFC4, 6A898B3A503366C0
// reference: 90EDEE8712DAA7B2, 494C9A653BABAB04
// shader: 8B30, 5A0A9A011883426E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (const_color[4].a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 50B5A3E75AC631EC, 5A0A9A011883426E
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, 5A0A9A011883426E
// shader: 8B31, B8666980F2837050

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_177_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_177_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_177_4096() {
    uint jmp_to = 177u;
    while (true) {
        switch (jmp_to) {
        case 177u: {
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            if (uniforms.b[0]) {
                sub_201_219();
            }
            vs_out_attr5.zw = (fma_s(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            {
                sub_45_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            reg_tmp13 = mul_s(uniforms.f[95].yyyy, vs_in_reg3);
            reg_tmp14 = uniforms.f[71];
            reg_tmp13 = fma_s(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            reg_tmp12 = vec4(rcp_s(reg_tmp10.w));
            reg_tmp12 = mul_s(reg_tmp10, reg_tmp12);
            reg_tmp14 = uniforms.f[72];
            reg_tmp12 = fma_s(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            vs_out_attr2.xyz = (fma_s(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            {
                sub_45_55();
            }
            reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
            reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
            reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
            reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            {
                sub_96_106();
            }
            reg_tmp15 = abs(reg_tmp1);
            reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_93_106();
            }
            {
                sub_45_55();
            }
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            {
                sub_287_295();
            }
            vs_out_attr2 = mul_s(uniforms.f[95].zzzz, reg_tmp12);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_287_295();
            }
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            vs_out_attr2.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    reg_tmp6.xyz = (mul_s(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    reg_tmp13.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp13.y = rsq_s(reg_tmp13.x);
    reg_tmp4 = mul_s(reg_tmp12, -reg_tmp13.yyyy);
    reg_tmp14.x = dot_3(reg_tmp4.xyz, reg_tmp7.xyz);
    reg_tmp14.y = (mul_s(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    reg_tmp5 = fma_s(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    reg_tmp12.w = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp14.z = rsq_s(reg_tmp12.w);
    reg_tmp12.xy = (mul_s(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    {
        sub_93_106();
    }
    {
        sub_45_55();
    }
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 90EDEE876D611557, B8666980F2837050
// shader: 8B30, 3E93F7BC0225433D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A7F51560AC526D5C, 3E93F7BC0225433D
// program: B8666980F2837050, AEA07E6271EAC2AC, 3E93F7BC0225433D
// shader: 8B30, BB01CE9E8168CEC9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A382C82A152AB604, BB01CE9E8168CEC9
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, BB01CE9E8168CEC9
// reference: 90EDEE8736BCE793, B8666980F2837050
// shader: 8B30, ACCCAE2F5B559D39

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.r) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 1.0, alpha_output_4 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5CE2A6821F22301D, ACCCAE2F5B559D39
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, ACCCAE2F5B559D39
// shader: 8B30, 573D209AC27C302F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 87752AE804B7BF8C, 573D209AC27C302F
// program: C5779815375CB1F0, AEA07E6271EAC2AC, 573D209AC27C302F
// shader: 8B31, 85E4C1AF77F83609

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_267_287();
bool sub_287_295();
bool sub_295_4096();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_295_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    {
        sub_93_106();
    }
    {
        sub_45_55();
    }
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_295_4096() {
    uint jmp_to = 295u;
    while (true) {
        switch (jmp_to) {
        case 295u: {
            {
                sub_287_295();
            }
            vs_out_attr2 = mul_s(uniforms.f[95].zzzz, reg_tmp12);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_287_295();
            }
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            vs_out_attr2.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 90EDEE87488A7AE4, 85E4C1AF77F83609
// shader: 8B30, 71BFC84226322252

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) + (primary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (secondary_fragment_color.a);
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb) + (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3 * 4.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor1.g), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 18948A72698A4277, 71BFC84226322252
// program: 85E4C1AF77F83609, AEA07E6271EAC2AC, 71BFC84226322252
// shader: 8B30, E1870CC598C7D3CD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 87752AE83E07A3F4, E1870CC598C7D3CD
// program: C5779815375CB1F0, AEA07E6271EAC2AC, E1870CC598C7D3CD
// shader: 8B30, 6C21028D53776C2B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA797F8CDEB7, 6C21028D53776C2B
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 6C21028D53776C2B
// reference: 90EDEE8713578820, 85E4C1AF77F83609
// shader: 8B30, 81100749EC496976

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 87752AE89B38DD3C, 81100749EC496976
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, 81100749EC496976
// shader: 8B30, B73E11B06EA4F1E9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4E4D91A666B7FB46, B73E11B06EA4F1E9
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, B73E11B06EA4F1E9
// shader: 8B30, 94CF1772F17A1F62

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 685436FC9EE199AC, 94CF1772F17A1F62
// program: D86A087FD303196A, AEA07E6271EAC2AC, 94CF1772F17A1F62
// shader: 8B30, ACB0CA8D897AB815

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA799EE199AC, ACB0CA8D897AB815
// program: D86A087FD303196A, AEA07E6271EAC2AC, ACB0CA8D897AB815
// shader: 8B30, BD6C66D4B559CD44

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E68725672AF, BD6C66D4B559CD44
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, BD6C66D4B559CD44
// shader: 8B30, D976A111FE567578

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = (vec3(1.0) - last_tex_env_out.rgb);
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (const_color[2].a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C5388A5955436F24, D976A111FE567578
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, D976A111FE567578
// shader: 8B31, 9E0C4EDBA04AF31D

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_223_4096();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_223_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_223_4096() {
    uint jmp_to = 223u;
    while (true) {
        switch (jmp_to) {
        case 223u: {
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            {
                sub_45_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            reg_tmp13 = mul_s(uniforms.f[95].yyyy, vs_in_reg3);
            reg_tmp14 = uniforms.f[71];
            reg_tmp13 = fma_s(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            reg_tmp12 = vec4(rcp_s(reg_tmp10.w));
            reg_tmp12 = mul_s(reg_tmp10, reg_tmp12);
            reg_tmp14 = uniforms.f[72];
            reg_tmp12 = fma_s(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            vs_out_attr2.xyz = (fma_s(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            {
                sub_45_55();
            }
            reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
            reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
            reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
            reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            {
                sub_96_106();
            }
            reg_tmp15 = abs(reg_tmp1);
            reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_93_106();
            }
            {
                sub_45_55();
            }
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            {
                sub_287_295();
            }
            vs_out_attr2 = mul_s(uniforms.f[95].zzzz, reg_tmp12);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_287_295();
            }
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            vs_out_attr2.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    {
        sub_93_106();
    }
    {
        sub_45_55();
    }
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: DEB911C7CD8263C9, 9E0C4EDBA04AF31D
// shader: 8B30, 8AAF0E186384CAC2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 08EDF29AFAA695EB, 8AAF0E186384CAC2
// program: 9E0C4EDBA04AF31D, AEA07E6271EAC2AC, 8AAF0E186384CAC2
// reference: 90EDEE8715AAF77F, 9E0C4EDBA04AF31D
// shader: 8B31, 19DE2B390CB8E9EA

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_239_4096();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_239_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_239_4096() {
    uint jmp_to = 239u;
    while (true) {
        switch (jmp_to) {
        case 239u: {
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            {
                sub_45_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            reg_tmp13 = mul_s(uniforms.f[95].yyyy, vs_in_reg3);
            reg_tmp14 = uniforms.f[71];
            reg_tmp13 = fma_s(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            reg_tmp12 = vec4(rcp_s(reg_tmp10.w));
            reg_tmp12 = mul_s(reg_tmp10, reg_tmp12);
            reg_tmp14 = uniforms.f[72];
            reg_tmp12 = fma_s(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            vs_out_attr2.xyz = (fma_s(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            {
                sub_45_55();
            }
            reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
            reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
            reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
            reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            {
                sub_96_106();
            }
            reg_tmp15 = abs(reg_tmp1);
            reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_93_106();
            }
            {
                sub_45_55();
            }
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            {
                sub_287_295();
            }
            vs_out_attr2 = mul_s(uniforms.f[95].zzzz, reg_tmp12);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_287_295();
            }
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            vs_out_attr2.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    {
        sub_93_106();
    }
    {
        sub_45_55();
    }
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 90EDEE87D3F2F53C, 19DE2B390CB8E9EA
// shader: 8B30, 49173472DE69F89A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.g) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (combiner_buffer.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (texcolor0.g), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3DC61B7B4C43A19B, 49173472DE69F89A
// program: 19DE2B390CB8E9EA, AEA07E6271EAC2AC, 49173472DE69F89A
// reference: 90EDEE874E7705BB, 9E0C4EDBA04AF31D
// shader: 8B30, E12E9921D8EC0CE3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 08EDF29A9193C73E, E12E9921D8EC0CE3
// program: 9E0C4EDBA04AF31D, AEA07E6271EAC2AC, E12E9921D8EC0CE3
// shader: 8B30, 527E2F2AF7039DB8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3BD5A2EDF5D4CB79, 527E2F2AF7039DB8
// program: D86A087FD303196A, AEA07E6271EAC2AC, 527E2F2AF7039DB8
// shader: 8B30, B9C756CCE3FCCF16

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF9F00D8FE9, B9C756CCE3FCCF16
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, B9C756CCE3FCCF16
// shader: 8B30, 60311184EC7109ED

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1DCC05B70D82A993, 60311184EC7109ED
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, 60311184EC7109ED
// shader: 8B30, 64E1DC17EA49441D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E68F5D4CB79, 64E1DC17EA49441D
// program: D86A087FD303196A, AEA07E6271EAC2AC, 64E1DC17EA49441D
// shader: 8B30, B1626B699E58B5F0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6841F96C8BB01523, B1626B699E58B5F0
// program: 9E0C4EDBA04AF31D, AEA07E6271EAC2AC, B1626B699E58B5F0
// shader: 8B30, 8CAA876AE60FD30F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.g) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (combiner_buffer.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (texcolor0.g), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5D6A108D3D552153, 8CAA876AE60FD30F
// program: 19DE2B390CB8E9EA, AEA07E6271EAC2AC, 8CAA876AE60FD30F
// shader: 8B30, AC83E2F1C73BBA81

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6841F96CE08547F6, AC83E2F1C73BBA81
// program: 9E0C4EDBA04AF31D, AEA07E6271EAC2AC, AC83E2F1C73BBA81
// shader: 8B30, 015E75540DD34BB2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E681963207A, 015E75540DD34BB2
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 015E75540DD34BB2
// shader: 8B30, 84515DBB5C82728B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E5871A9F7BD079A5, 84515DBB5C82728B
// program: 9E0C4EDBA04AF31D, AEA07E6271EAC2AC, 84515DBB5C82728B
// shader: 8B30, 361C75374F85FE92

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.g) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (combiner_buffer.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (texcolor0.g), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D0ACF37ECD354DD5, 361C75374F85FE92
// program: 19DE2B390CB8E9EA, AEA07E6271EAC2AC, 361C75374F85FE92
// shader: 8B30, 5CE60634BC9AF45F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E5871A9F10E52B70, 5CE60634BC9AF45F
// program: 9E0C4EDBA04AF31D, AEA07E6271EAC2AC, 5CE60634BC9AF45F
// shader: 8B30, 15DF5B6C0C94493A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B6933CA02B727532, 15DF5B6C0C94493A
// program: D86A087FD303196A, AEA07E6271EAC2AC, 15DF5B6C0C94493A
// reference: DEB911C7912FC1C0, 494C9A653BABAB04
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 64E1DC17EA49441D
// reference: DEB911C7B54981E1, B8666980F2837050
// shader: 8B30, 967BCBD707EB39AB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F4748171F00D8FE9, 967BCBD707EB39AB
// program: B8666980F2837050, AEA07E6271EAC2AC, 967BCBD707EB39AB
// shader: 8B30, AF531333720F27FF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (const_color[4].a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8D450D8EFFCB62AA, AF531333720F27FF
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, AF531333720F27FF
// shader: 8B30, 161AEED51CE5526F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E68A98B29CC, 161AEED51CE5526F
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 161AEED51CE5526F
// shader: 8B30, ADBFF0B5DEDA0A6E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F4748171AC526D5C, ADBFF0B5DEDA0A6E
// program: B8666980F2837050, AEA07E6271EAC2AC, ADBFF0B5DEDA0A6E
// shader: 8B30, 9EEF351F2F3BAB51

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E68453CC2CF, 9EEF351F2F3BAB51
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 9EEF351F2F3BAB51
// shader: 8B30, D38BE52DD60D9D39

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: EE1B2FAC4E2340EE, D38BE52DD60D9D39
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, D38BE52DD60D9D39
// shader: 8B30, 1FCF973F9EC8F39C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B6933CA0772D9787, 1FCF973F9EC8F39C
// program: D86A087FD303196A, AEA07E6271EAC2AC, 1FCF973F9EC8F39C
// shader: 8B30, 5A1DE251FBA01FAF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3BD5A2EDA98B29CC, 5A1DE251FBA01FAF
// program: D86A087FD303196A, AEA07E6271EAC2AC, 5A1DE251FBA01FAF
// shader: 8B30, 8E0C20574D0ED30B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF9AC526D5C, 8E0C20574D0ED30B
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, 8E0C20574D0ED30B
// shader: 8B30, 87F2F3D16DF4686F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1DCC05B751DD4B26, 87F2F3D16DF4686F
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, 87F2F3D16DF4686F
// program: D86A087FD303196A, AEA07E6271EAC2AC, 161AEED51CE5526F
// shader: 8B30, 47EB3C74B1768AEE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (const_color[4].a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 038E7DB1FFCB62AA, 47EB3C74B1768AEE
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, 47EB3C74B1768AEE
// shader: 8B30, E6D17D4779455D55

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(11, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) + (primary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (secondary_fragment_color.a);
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb) + (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3 * 4.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor1.g), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4BAF5424CC871131, E6D17D4779455D55
// program: 85E4C1AF77F83609, AEA07E6271EAC2AC, E6D17D4779455D55
// shader: 8B30, 4CB0E57D646B56C0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF93E07A3F4, 4CB0E57D646B56C0
// program: C5779815375CB1F0, AEA07E6271EAC2AC, 4CB0E57D646B56C0
// shader: 8B30, 96475741C80C557D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E687F8CDEB7, 96475741C80C557D
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 96475741C80C557D
// shader: 8B30, 41F146754BD6ADC3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E68933B35B4, 41F146754BD6ADC3
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 41F146754BD6ADC3
// shader: 8B30, 48243F9FC9FB0C30

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B6933CA04D9D8BFF, 48243F9FC9FB0C30
// program: D86A087FD303196A, AEA07E6271EAC2AC, 48243F9FC9FB0C30
// shader: 8B30, DB052B801EF3D62D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3BD5A2ED933B35B4, DB052B801EF3D62D
// program: D86A087FD303196A, AEA07E6271EAC2AC, DB052B801EF3D62D
// shader: 8B30, 72296B545D54609E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF996E27124, 72296B545D54609E
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, 72296B545D54609E
// shader: 8B30, DF18A815D6776034

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1DCC05B76B6D575E, DF18A815D6776034
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, DF18A815D6776034
// program: D86A087FD303196A, AEA07E6271EAC2AC, 41F146754BD6ADC3
// shader: 8B31, 7C3FFF32EC4540E3

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_392_400();
bool sub_400_4096();

bool exec_shader() {
    sub_400_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
bool sub_400_4096() {
    uint jmp_to = 400u;
    while (true) {
        switch (jmp_to) {
        case 400u: {
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
// reference: 90EDEE87BE138D04, 7C3FFF32EC4540E3
// shader: 8B30, F4DF8C7470D9FAC0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 91CA33AE963E09B8, F4DF8C7470D9FAC0
// program: 7C3FFF32EC4540E3, AEA07E6271EAC2AC, F4DF8C7470D9FAC0
// reference: 90EDEE87E5CE7FC0, 7C3FFF32EC4540E3
// shader: 8B30, 85F8389F31E3F3EE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1588FC1DCE0D59BE, 85F8389F31E3F3EE
// program: 7C3FFF32EC4540E3, AEA07E6271EAC2AC, 85F8389F31E3F3EE
// shader: 8B30, B75CF484D7B7F73B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp(min((texcolor2.rgb) + (last_tex_env_out.aaa), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor2.a) + (last_tex_env_out.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (texcolor1.r);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5EF0D5E9C44B4BAE, B75CF484D7B7F73B
// program: 7C3FFF32EC4540E3, AEA07E6271EAC2AC, B75CF484D7B7F73B
// shader: 8B31, 7B583060472E2AEA

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_21_55();
bool sub_51_53();
bool sub_53_54();
bool sub_450_4096();

bool exec_shader() {
    sub_450_4096();
    return true;
}

bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_450_4096() {
    uint jmp_to = 450u;
    while (true) {
        switch (jmp_to) {
        case 450u: {
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
// reference: 90EDEE87F1AF5D8B, 7B583060472E2AEA
// shader: 8B30, 2B6A9BCAB67878E3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C19772B4E2CF9AF9, 2B6A9BCAB67878E3
// program: 7B583060472E2AEA, AEA07E6271EAC2AC, 2B6A9BCAB67878E3
// shader: 8B30, ADB33C6CE857EDA4

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb) + (const_color[3].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[4].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = (combiner_buffer.rgb);
float alpha_output_5 = byteround(clamp((last_tex_env_out.r) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6412DCB7151EB849, ADB33C6CE857EDA4
// program: 6A898B3A503366C0, AEA07E6271EAC2AC, ADB33C6CE857EDA4
// shader: 8B31, 69421A64BED706FA

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_21_55();
bool sub_51_53();
bool sub_53_54();
bool sub_466_4096();

bool exec_shader() {
    sub_466_4096();
    return true;
}

bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_466_4096() {
    uint jmp_to = 466u;
    while (true) {
        switch (jmp_to) {
        case 466u: {
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
// reference: 90EDEE8705485E75, 69421A64BED706FA
// shader: 8B30, 95A2B5ED015766FE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(min((primary_fragment_color.rgb) + (texcolor1.rgb), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3F7A3161B1A9BC5F, 95A2B5ED015766FE
// program: 69421A64BED706FA, AEA07E6271EAC2AC, 95A2B5ED015766FE
// shader: 8B30, 49BA253CC09B6D18

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (const_color[4].a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0E13E2D35AC631EC, 49BA253CC09B6D18
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, 49BA253CC09B6D18
// shader: 8B30, 7F9334D5BB0C4688

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7EC669E37ACCF570, 7F9334D5BB0C4688
// program: 7C3FFF32EC4540E3, AEA07E6271EAC2AC, 7F9334D5BB0C4688
// reference: DEB911C70BDA618A, 19DE2B390CB8E9EA
// shader: 8B30, 88F0F2F10D24AAFC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4377B0252B727532, 88F0F2F10D24AAFC
// program: D86A087FD303196A, AEA07E6271EAC2AC, 88F0F2F10D24AAFC
// reference: 90EDEE87882F07F8, 19DE2B390CB8E9EA
// shader: 8B31, EF7C518C09192E40

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_187_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_187_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_187_4096() {
    uint jmp_to = 187u;
    while (true) {
        switch (jmp_to) {
        case 187u: {
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            if (uniforms.b[0]) {
                sub_201_219();
            }
            vs_out_attr5.zw = (fma_s(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            {
                sub_45_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            reg_tmp13 = mul_s(uniforms.f[95].yyyy, vs_in_reg3);
            reg_tmp14 = uniforms.f[71];
            reg_tmp13 = fma_s(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            reg_tmp12 = vec4(rcp_s(reg_tmp10.w));
            reg_tmp12 = mul_s(reg_tmp10, reg_tmp12);
            reg_tmp14 = uniforms.f[72];
            reg_tmp12 = fma_s(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            vs_out_attr2.xyz = (fma_s(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            {
                sub_45_55();
            }
            reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
            reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
            reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
            reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            {
                sub_96_106();
            }
            reg_tmp15 = abs(reg_tmp1);
            reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_93_106();
            }
            {
                sub_45_55();
            }
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            {
                sub_287_295();
            }
            vs_out_attr2 = mul_s(uniforms.f[95].zzzz, reg_tmp12);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_287_295();
            }
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            vs_out_attr2.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    reg_tmp6.xyz = (mul_s(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    reg_tmp13.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp13.y = rsq_s(reg_tmp13.x);
    reg_tmp4 = mul_s(reg_tmp12, -reg_tmp13.yyyy);
    reg_tmp14.x = dot_3(reg_tmp4.xyz, reg_tmp7.xyz);
    reg_tmp14.y = (mul_s(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    reg_tmp5 = fma_s(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    reg_tmp12.w = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp14.z = rsq_s(reg_tmp12.w);
    reg_tmp12.xy = (mul_s(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    {
        sub_93_106();
    }
    {
        sub_45_55();
    }
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 90EDEE87C93744A3, EF7C518C09192E40
// shader: 8B30, 3C412B5D382307A6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.r) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor2.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 282CA6CB83AEF8DC, 3C412B5D382307A6
// program: EF7C518C09192E40, AEA07E6271EAC2AC, 3C412B5D382307A6
// shader: 8B30, 92901863CFE92C8F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E68D61B57B7, 92901863CFE92C8F
// program: EF7C518C09192E40, AEA07E6271EAC2AC, 92901863CFE92C8F
// shader: 8B31, 409E719D94562862

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_121_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_121_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_121_4096() {
    uint jmp_to = 121u;
    while (true) {
        switch (jmp_to) {
        case 121u: {
            reg_tmp12 = mul_s(uniforms.f[16], vs_in_reg0.xyxy);
            reg_tmp12 = uniforms.f[13] + reg_tmp12;
            vs_out_attr2 = uniforms.f[12];
            reg_tmp14 = mul_s(uniforms.f[15], vs_in_reg1);
            reg_tmp13 = uniforms.f[93].yyyy + reg_tmp12.zwww;
            reg_tmp13 = mul_s(uniforms.f[95].zzzz, reg_tmp13);
            reg_tmp14.y = (uniforms.f[14].wwww + reg_tmp14).y;
            reg_tmp13 = mul_s(uniforms.f[14], reg_tmp13);
            vs_out_attr0.xy = (reg_tmp12.xyyy).xy;
            vs_out_attr0.zw = (uniforms.f[93].xxxy).zw;
            vs_out_attr3.xyz = (reg_tmp13 + reg_tmp14).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_9_21();
            }
            reg_tmp0 = vs_in_reg1.xyyy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1 = vs_in_reg0.xyyy;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp13 = mul_s(uniforms.f[12], vs_in_reg2);
            vs_out_attr3.x = dot_3(uniforms.f[13].xyz, reg_tmp0.xyz);
            vs_out_attr3.yz = vec2(dot_3(uniforms.f[14].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[16].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, reg_tmp13);
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg1);
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            vs_out_attr5.xy = (uniforms.f[93].xxxx).xy;
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            if (uniforms.b[0]) {
                sub_201_219();
            }
            vs_out_attr5.zw = (fma_s(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            {
                sub_45_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            reg_tmp13 = mul_s(uniforms.f[95].yyyy, vs_in_reg3);
            reg_tmp14 = uniforms.f[71];
            reg_tmp13 = fma_s(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            reg_tmp12 = vec4(rcp_s(reg_tmp10.w));
            reg_tmp12 = mul_s(reg_tmp10, reg_tmp12);
            reg_tmp14 = uniforms.f[72];
            reg_tmp12 = fma_s(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            vs_out_attr2.xyz = (fma_s(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            {
                sub_45_55();
            }
            reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
            reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
            reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
            reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            {
                sub_96_106();
            }
            reg_tmp15 = abs(reg_tmp1);
            reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_93_106();
            }
            {
                sub_45_55();
            }
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            {
                sub_287_295();
            }
            vs_out_attr2 = mul_s(uniforms.f[95].zzzz, reg_tmp12);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_287_295();
            }
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            vs_out_attr2.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 494u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 500u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5.zw = (uniforms.f[93].xxxx).zw;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    reg_tmp6.xyz = (mul_s(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    reg_tmp13.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp13.y = rsq_s(reg_tmp13.x);
    reg_tmp4 = mul_s(reg_tmp12, -reg_tmp13.yyyy);
    reg_tmp14.x = dot_3(reg_tmp4.xyz, reg_tmp7.xyz);
    reg_tmp14.y = (mul_s(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    reg_tmp5 = fma_s(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    reg_tmp12.w = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp14.z = rsq_s(reg_tmp12.w);
    reg_tmp12.xy = (mul_s(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    {
        sub_93_106();
    }
    {
        sub_45_55();
    }
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 90EDEE87B8909126, 409E719D94562862
// shader: 8B30, 07AB54532856B481

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((vec3(1.0) - last_tex_env_out.rgb) * (const_color[1].rrr) + (const_color[1].ggg), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a) + (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[2].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_2 = 0.0;
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb) * (vec3(1.0) - (rounded_primary_color.bbb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((combiner_buffer.a) * (rounded_primary_color.a) + (last_tex_env_out.a) * (1.0 - (rounded_primary_color.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rrr) + (const_color[5].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (rounded_primary_color.g);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4A6C58B94B836D0B, 07AB54532856B481
// program: 409E719D94562862, AEA07E6271EAC2AC, 07AB54532856B481
// reference: 90EDEE8738F4C2A5, 409E719D94562862
// reference: 90EDEE874287435A, E976850DD5B08ED7
// shader: 8B30, 376A345B910A4BD3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (const_color[2].a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1DCC05B7B0200DAC, 376A345B910A4BD3
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, 376A345B910A4BD3
// shader: 8B30, AD202664F10B6535

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 1.0, alpha_output_4 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FB6475BF11F6CD3E, AD202664F10B6535
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, AD202664F10B6535
// shader: 8B31, 740C53E4FCBE97EC

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_145_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_145_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_145_4096() {
    uint jmp_to = 145u;
    while (true) {
        switch (jmp_to) {
        case 145u: {
            {
                sub_9_21();
            }
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg1);
            if (uniforms.b[14]) {
                { jmp_to = 494u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            vs_out_attr5.xy = (uniforms.f[93].xxxx).xy;
            if (uniforms.b[14]) {
                { jmp_to = 500u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            if (uniforms.b[0]) {
                sub_201_219();
            }
            vs_out_attr5.zw = (fma_s(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            {
                sub_45_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            reg_tmp13 = mul_s(uniforms.f[95].yyyy, vs_in_reg3);
            reg_tmp14 = uniforms.f[71];
            reg_tmp13 = fma_s(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            reg_tmp12 = vec4(rcp_s(reg_tmp10.w));
            reg_tmp12 = mul_s(reg_tmp10, reg_tmp12);
            reg_tmp14 = uniforms.f[72];
            reg_tmp12 = fma_s(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            vs_out_attr2.xyz = (fma_s(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            {
                sub_45_55();
            }
            reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
            reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
            reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
            reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            {
                sub_96_106();
            }
            reg_tmp15 = abs(reg_tmp1);
            reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_93_106();
            }
            {
                sub_45_55();
            }
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            {
                sub_287_295();
            }
            vs_out_attr2 = mul_s(uniforms.f[95].zzzz, reg_tmp12);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_287_295();
            }
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            vs_out_attr2.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 494u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 500u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5.zw = (uniforms.f[93].xxxx).zw;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    reg_tmp6.xyz = (mul_s(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    reg_tmp13.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp13.y = rsq_s(reg_tmp13.x);
    reg_tmp4 = mul_s(reg_tmp12, -reg_tmp13.yyyy);
    reg_tmp14.x = dot_3(reg_tmp4.xyz, reg_tmp7.xyz);
    reg_tmp14.y = (mul_s(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    reg_tmp5 = fma_s(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    reg_tmp12.w = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp14.z = rsq_s(reg_tmp12.w);
    reg_tmp12.xy = (mul_s(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    {
        sub_93_106();
    }
    {
        sub_45_55();
    }
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 90EDEE875FDE14EA, 740C53E4FCBE97EC
// shader: 8B30, C434504F88EE1D9D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF958E85D39, C434504F88EE1D9D
// program: 740C53E4FCBE97EC, AEA07E6271EAC2AC, C434504F88EE1D9D
// reference: DEB911C7663B19B2, 7C3FFF32EC4540E3
// shader: 8B30, 101AADE8E6105F95

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.g) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (combiner_buffer.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (texcolor0.g), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5D6A108D9F3D52B8, 101AADE8E6105F95
// program: 19DE2B390CB8E9EA, AEA07E6271EAC2AC, 101AADE8E6105F95
// shader: 8B30, B870C06331B214D2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[1].position + view);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-view - light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6841F96C42ED341D, B870C06331B214D2
// program: 9E0C4EDBA04AF31D, AEA07E6271EAC2AC, B870C06331B214D2
// shader: 8B31, 467A1A42436F227B

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_170_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_170_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_170_4096() {
    uint jmp_to = 170u;
    while (true) {
        switch (jmp_to) {
        case 170u: {
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = uniforms.f[93].yyyy;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            if (uniforms.b[0]) {
                sub_201_219();
            }
            vs_out_attr5.zw = (fma_s(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            {
                sub_45_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            reg_tmp13 = mul_s(uniforms.f[95].yyyy, vs_in_reg3);
            reg_tmp14 = uniforms.f[71];
            reg_tmp13 = fma_s(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            reg_tmp12 = vec4(rcp_s(reg_tmp10.w));
            reg_tmp12 = mul_s(reg_tmp10, reg_tmp12);
            reg_tmp14 = uniforms.f[72];
            reg_tmp12 = fma_s(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            vs_out_attr2.xyz = (fma_s(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            {
                sub_45_55();
            }
            reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
            reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
            reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
            reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            {
                sub_96_106();
            }
            reg_tmp15 = abs(reg_tmp1);
            reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_93_106();
            }
            {
                sub_45_55();
            }
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            {
                sub_287_295();
            }
            vs_out_attr2 = mul_s(uniforms.f[95].zzzz, reg_tmp12);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_287_295();
            }
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            vs_out_attr2.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    reg_tmp6.xyz = (mul_s(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    reg_tmp13.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp13.y = rsq_s(reg_tmp13.x);
    reg_tmp4 = mul_s(reg_tmp12, -reg_tmp13.yyyy);
    reg_tmp14.x = dot_3(reg_tmp4.xyz, reg_tmp7.xyz);
    reg_tmp14.y = (mul_s(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    reg_tmp5 = fma_s(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    reg_tmp12.w = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp14.z = rsq_s(reg_tmp12.w);
    reg_tmp12.xy = (mul_s(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    {
        sub_93_106();
    }
    {
        sub_45_55();
    }
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 90EDEE879294D51A, 467A1A42436F227B
// shader: 8B30, C306097EDA73D7D0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0A45E4E68931B8A2, C306097EDA73D7D0
// program: 467A1A42436F227B, AEA07E6271EAC2AC, C306097EDA73D7D0
// shader: 8B31, 559C5391498D90D5

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_9_21();
bool sub_21_55();
bool sub_26_55();
bool sub_45_55();
bool sub_51_53();
bool sub_53_54();
bool sub_55_85();
bool sub_78_79();
bool sub_93_106();
bool sub_96_106();
bool sub_184_4096();
bool sub_201_219();
bool sub_267_287();
bool sub_287_295();
bool sub_321_364();
bool sub_357_359();
bool sub_359_360();
bool sub_392_400();

bool exec_shader() {
    sub_184_4096();
    return true;
}

bool sub_9_21() {
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    return false;
}
bool sub_21_55() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_26_55() {
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    vs_out_attr4 = -reg_tmp9;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_45_55() {
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    if (!conditional_code.x) {
        sub_51_53();
    } else {
        sub_53_54();
    }
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    return false;
}
bool sub_51_53() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_53_54() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_55_85() {
    address_registers.x = (ivec2(reg_tmp8.xx)).x;
    reg_tmp8.z = dot_s(uniforms.f[10 + address_registers.x], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9 + address_registers.x], vs_in_reg0);
    reg_tmp8.x = dot_s(uniforms.f[8 + address_registers.x], vs_in_reg0);
    reg_tmp8.w = (uniforms.f[93].yyyy).w;
    reg_tmp7.z = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp7.x = dot_3(uniforms.f[8 + address_registers.x].xyz, reg_tmp12.xyz);
    reg_tmp9.z = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[6]);
    reg_tmp9.y = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[5]);
    reg_tmp9.x = dot_s(vec4(reg_tmp8.xyz, 1.0), uniforms.f[4]);
    reg_tmp9.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(reg_tmp7.xyz, reg_tmp7.xyz);
    reg_tmp13.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[3]);
    reg_tmp10.z = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[2]);
    reg_tmp10.y = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[1]);
    reg_tmp10.x = dot_s(vec4(reg_tmp9.xyz, 1.0), uniforms.f[0]);
    reg_tmp13.xy = (mul_s(uniforms.f[93].zyyy, -reg_tmp13.zzzz)).xy;
    reg_tmp12.x = rsq_s(reg_tmp12.x);
    vs_out_attr4 = -reg_tmp9;
    conditional_code.x = reg_tmp10.xxxx.x < reg_tmp13.xyyy.x;
    conditional_code.y = reg_tmp10.xxxx.y > reg_tmp13.xyyy.y;
    reg_tmp10.w = (reg_tmp13.zzzz).w;
    if (all(conditional_code)) {
        sub_78_79();
    }
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12.xxxx);
    vs_out_attr0 = reg_tmp10;
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    return false;
}
bool sub_78_79() {
    reg_tmp10.x = (-reg_tmp13.zzzz).x;
    return false;
}
bool sub_93_106() {
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_96_106() {
    reg_tmp15 = max(uniforms.f[93].xxxx, reg_tmp12);
    reg_tmp14 = max(uniforms.f[93].xxxx, -reg_tmp12);
    reg_tmp15 = mul_s(reg_tmp15, reg_tmp15);
    reg_tmp14 = mul_s(reg_tmp14, reg_tmp14);
    reg_tmp13.xyz = (mul_s(uniforms.f[88], reg_tmp15.zzzz)).xyz;
    reg_tmp12.xyz = (mul_s(uniforms.f[89], reg_tmp14.zzzz)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.xxxx, uniforms.f[84], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.xxxx, uniforms.f[85], reg_tmp12)).xyz;
    reg_tmp13.xyz = (fma_s(reg_tmp15.yyyy, uniforms.f[86], reg_tmp13)).xyz;
    reg_tmp12.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[87], reg_tmp12)).xyz;
    return false;
}
bool sub_184_4096() {
    uint jmp_to = 184u;
    while (true) {
        switch (jmp_to) {
        case 184u: {
            {
                sub_9_21();
            }
            vs_out_attr3.xyz = (vs_in_reg1).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[80], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[81], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[82], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2.xyyy)).xy;
            if (uniforms.b[0]) {
                sub_201_219();
            }
            vs_out_attr5.zw = (fma_s(reg_tmp12.xyxy, reg_tmp13.xzxz, reg_tmp13.ywyw)).zw;
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            {
                sub_93_106();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            reg_tmp2 = reg_tmp12 + reg_tmp13;
            {
                sub_45_55();
            }
            reg_tmp3 = -reg_tmp1 + reg_tmp2;
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyxy);
            vs_out_attr2.xyz = (fma_s(reg_tmp3, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp1.xyz = (mul_s(uniforms.f[68], reg_tmp0.xxxx)).xyz;
            {
                sub_55_85();
            }
            reg_tmp1.xyz = (fma_s(reg_tmp0.yyyy, uniforms.f[69], reg_tmp1)).xyz;
            reg_tmp1.xyz = (fma_s(reg_tmp0.zzzz, uniforms.f[70], reg_tmp1)).xyz;
            {
                sub_45_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[95].yyyy, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[95].yyyy, vs_in_reg2.xyyy)).xy;
            reg_tmp13 = mul_s(uniforms.f[95].yyyy, vs_in_reg3);
            reg_tmp14 = uniforms.f[71];
            reg_tmp13 = fma_s(reg_tmp13.yxxx, reg_tmp14.yxyx, reg_tmp14.wzwz);
            reg_tmp12 = vec4(rcp_s(reg_tmp10.w));
            reg_tmp12 = mul_s(reg_tmp10, reg_tmp12);
            reg_tmp14 = uniforms.f[72];
            reg_tmp12 = fma_s(reg_tmp12, reg_tmp14.yxyx, reg_tmp14.wzwz);
            vs_out_attr5.zw = (reg_tmp12.xyxy + reg_tmp13.xyxy).zw;
            vs_out_attr2.xyz = (fma_s(-reg_tmp1, reg_tmp0.wwww, reg_tmp1)).xyz;
            vs_out_attr2.w = (reg_tmp0.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            {
                sub_45_55();
            }
            reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
            reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
            reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
            reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            {
                sub_96_106();
            }
            reg_tmp15 = abs(reg_tmp1);
            reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
            reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
            reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            {
                sub_55_85();
            }
            {
                sub_93_106();
            }
            {
                sub_45_55();
            }
            reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            {
                sub_287_295();
            }
            vs_out_attr2 = mul_s(uniforms.f[95].zzzz, reg_tmp12);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_287_295();
            }
            reg_tmp2.x = (max(reg_tmp2.xxxx, reg_tmp2.yyyy)).x;
            vs_out_attr2.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12)).xyz;
            vs_out_attr2.w = (max(reg_tmp2.xxxx, reg_tmp2.zzzz)).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            vs_out_attr2.xyz = (mul_s(reg_tmp12, reg_tmp2)).xyz;
            vs_out_attr2.w = (reg_tmp12.wwww).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            {
                sub_267_287();
            }
            reg_tmp13.xyz = (mul_s(uniforms.f[95].zzzz, reg_tmp12.xyzz)).xyz;
            vs_out_attr2.w = (reg_tmp2.xxxx).w;
            vs_out_attr2.xyz = (fma_s(reg_tmp12.wwww, uniforms.f[83].xyzz, reg_tmp13.xyzz)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            {
                sub_93_106();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr2 = reg_tmp12 + reg_tmp13;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
            reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
            reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
            reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
            reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
            reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
            reg_tmp9.w = (reg_tmp8.wwww).w;
            reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
            reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
            reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
            reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
            vs_out_attr4 = -reg_tmp9;
            reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
            reg_tmp11.w = (uniforms.f[93].xxxx).w;
            reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
            reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
            reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
            reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
            vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
            vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
            vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
            vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
            reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
            reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
            reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
            conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
            reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
            reg_tmp0 = abs(reg_tmp0);
            reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
            reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
            if (!conditional_code.x) {
                sub_357_359();
            } else {
                sub_359_360();
            }
            reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
            vs_out_attr1.w = (uniforms.f[93].xxxx).w;
            reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
            reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
            {
                sub_321_364();
            }
            reg_tmp15 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr2 = fma_s(reg_tmp0.wwww, uniforms.f[83], reg_tmp15);
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_321_364();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr2 = mul_s(uniforms.f[83], reg_tmp0.wwww);
            if (uniforms.b[14]) {
                { jmp_to = 490u; break; }
            }
            vs_out_attr0.x = dot_s(uniforms.f[8], vs_in_reg0);
            vs_out_attr0.y = dot_s(uniforms.f[9], vs_in_reg0);
            vs_out_attr0.z = dot_s(uniforms.f[10], vs_in_reg0);
            vs_out_attr0.w = dot_s(uniforms.f[11], vs_in_reg0);
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg1);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg5.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp0 = uniforms.f[13];
            reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
            reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
            reg_tmp12.x = log2(reg_tmp12.x);
            reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
            reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
            reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
            reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
            reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
            reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
            if (uniforms.b[0]) {
                sub_392_400();
            }
            reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
            {
                sub_26_55();
            }
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xyz;
            vs_out_attr5.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg3);
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_9_21();
            }
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg2);
            vs_out_attr3.xyz = (mul_s(uniforms.f[94].xxxx, vs_in_reg1)).xyz;
            if (uniforms.b[14]) {
                { jmp_to = 488u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[15].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            reg_tmp8.x = (vs_in_reg1.wwww).x;
            reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            {
                sub_55_85();
            }
            {
                sub_45_55();
            }
            reg_tmp0.x = (uniforms.f[83].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[84].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[85].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[86].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[83].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[84].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[85].xyz, reg_tmp1.xyz);
            vs_out_attr5.yzw = vec3(dot_3(uniforms.f[86].xyz, reg_tmp1.xyz));
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg4);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            reg_tmp0.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg2)).xy;
            reg_tmp1.xy = (mul_s(uniforms.f[94].xxxx, vs_in_reg3)).xy;
            vs_out_attr5.zw = (mul_s(uniforms.f[94].xxxx, vs_in_reg4.xyxy)).zw;
            reg_tmp0.x = (uniforms.f[12].wwww + reg_tmp0.xxxx).x;
            reg_tmp0.y = (uniforms.f[13].wwww + reg_tmp0.yyyy).y;
            reg_tmp1.x = (uniforms.f[14].wwww + reg_tmp1.xxxx).x;
            reg_tmp1.y = (uniforms.f[15].wwww + reg_tmp1.yyyy).y;
            reg_tmp0.z = (uniforms.f[93].yyyy).z;
            reg_tmp1.z = (uniforms.f[93].yyyy).z;
            vs_out_attr3.x = dot_3(uniforms.f[12].xyz, reg_tmp0.xyz);
            vs_out_attr3.yzw = vec3(dot_3(uniforms.f[13].xyz, reg_tmp0.xyz));
            vs_out_attr5.x = dot_3(uniforms.f[14].xyz, reg_tmp1.xyz);
            vs_out_attr5.y = dot_3(uniforms.f[15].xyz, reg_tmp1.xyz);
            vs_out_attr2 = mul_s(uniforms.f[94].yyyy, vs_in_reg5);
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            {
                sub_21_55();
            }
            vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
            vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg3);
            vs_out_attr2 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 504u; break; }
            }
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr1 = vs_in_reg1;
            vs_out_attr2 = uniforms.f[93].yyyy;
            vs_out_attr4 = uniforms.f[93].xxxx;
            if (uniforms.b[14]) {
                { jmp_to = 496u; break; }
            }
            reg_tmp9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), uniforms.f[6]);
            vs_out_attr0 = vs_in_reg0;
            vs_out_attr3.yz = (uniforms.f[93].xxxx).yz;
            reg_tmp13.x = (-uniforms.f[13].yyyy + -reg_tmp9.zzzz).x;
            reg_tmp12.x = (uniforms.f[93].yyyy + -reg_tmp13.xxxx).x;
            reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
            reg_tmp12.xy = (min(uniforms.f[93].yyyy, reg_tmp12.xyyy)).xy;
            vs_out_attr3.x = (reg_tmp12.xxxx).x;
            if (uniforms.b[14]) {
                { jmp_to = 487u; break; }
            }
            vs_out_attr0 = uniforms.f[93].xxxx;
            vs_out_attr3.xyz = (uniforms.f[93].xxxx).xyz;
        }
        case 487u: {
            vs_out_attr2 = uniforms.f[93].xxxx;
        }
        case 488u: {
            vs_out_attr4 = uniforms.f[93].xxxx;
            vs_out_attr1 = uniforms.f[93].xxxx;
        }
        case 490u: {
            vs_out_attr3.w = (uniforms.f[93].xxxx).w;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 496u: {
            vs_out_attr3 = uniforms.f[93].xxxx;
            vs_out_attr5 = uniforms.f[93].xxxx;
            return true;
        }
        case 504u: {
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_219() {
    reg_tmp15.x = (uniforms.f[4].wwww).x;
    reg_tmp14.y = (uniforms.f[5].wwww).y;
    reg_tmp13.z = (uniforms.f[6].wwww).z;
    reg_tmp6.xyz = (mul_s(uniforms.f[4].xyzz, reg_tmp15.xxxx)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp14.yyyy, uniforms.f[5].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp13.zzzz, uniforms.f[6].xyzz, reg_tmp6.xyzz)).xyz;
    reg_tmp12 = reg_tmp8 + reg_tmp6;
    reg_tmp13.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp13.y = rsq_s(reg_tmp13.x);
    reg_tmp4 = mul_s(reg_tmp12, -reg_tmp13.yyyy);
    reg_tmp14.x = dot_3(reg_tmp4.xyz, reg_tmp7.xyz);
    reg_tmp14.y = (mul_s(uniforms.f[95].xxxx, reg_tmp14.xxxx)).y;
    reg_tmp5 = fma_s(reg_tmp14.yyyy, reg_tmp7, -reg_tmp4);
    reg_tmp12.xyz = (uniforms.f[93].xxyy + reg_tmp5.xyzz).xyz;
    reg_tmp12.w = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
    reg_tmp14.z = rsq_s(reg_tmp12.w);
    reg_tmp12.xy = (mul_s(reg_tmp5.xyzz, reg_tmp14.zzzz)).xy;
    reg_tmp13 = uniforms.f[83];
    return false;
}
bool sub_267_287() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    reg_tmp13 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    {
        sub_45_55();
    }
    reg_tmp13 = vec4(rsq_s(reg_tmp13.x));
    reg_tmp12.x = dot_3(uniforms.f[90].xyz, reg_tmp7.xyz);
    reg_tmp12.y = dot_3(uniforms.f[91].xyz, reg_tmp7.xyz);
    reg_tmp12.z = dot_3(uniforms.f[92].xyz, reg_tmp7.xyz);
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp13);
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    reg_tmp1 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    {
        sub_96_106();
    }
    reg_tmp15 = abs(reg_tmp1);
    reg_tmp14.w = (mul_s(uniforms.f[82].wwww, reg_tmp15.wwww)).w;
    reg_tmp14.w = (min(uniforms.f[93].yyyy, reg_tmp14.wwww)).w;
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    reg_tmp12.w = (uniforms.f[93].yyyy + -reg_tmp14.wwww).w;
    reg_tmp12.w = (mul_s(uniforms.f[83].wwww, reg_tmp12.wwww)).w;
    return false;
}
bool sub_287_295() {
    reg_tmp8.x = (vs_in_reg1.wwww).x;
    reg_tmp12 = mul_s(uniforms.f[93].wwwy, vs_in_reg1);
    {
        sub_55_85();
    }
    {
        sub_93_106();
    }
    {
        sub_45_55();
    }
    reg_tmp12.xyz = (reg_tmp12.xyzz + reg_tmp13.xyzz).xyz;
    vs_out_attr3 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    vs_out_attr5 = mul_s(uniforms.f[94].xxxx, vs_in_reg2);
    return false;
}
bool sub_321_364() {
    reg_tmp12 = mul_s(uniforms.f[93].wwww, vs_in_reg1);
    reg_tmp8.x = dot_s(uniforms.f[8], vs_in_reg0);
    reg_tmp8.y = dot_s(uniforms.f[9], vs_in_reg0);
    reg_tmp8.z = dot_s(uniforms.f[10], vs_in_reg0);
    reg_tmp8.w = dot_s(uniforms.f[11], vs_in_reg0);
    reg_tmp7.x = dot_3(uniforms.f[8].xyz, reg_tmp12.xyz);
    reg_tmp7.y = dot_3(uniforms.f[9].xyz, reg_tmp12.xyz);
    reg_tmp7.z = dot_3(uniforms.f[10].xyz, reg_tmp12.xyz);
    reg_tmp9.x = dot_s(uniforms.f[4], reg_tmp8);
    reg_tmp9.y = dot_s(uniforms.f[5], reg_tmp8);
    reg_tmp9.z = dot_s(uniforms.f[6], reg_tmp8);
    reg_tmp9.w = (reg_tmp8.wwww).w;
    reg_tmp12 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
    reg_tmp0 = vec4(dot_3(reg_tmp9.xyz, reg_tmp9.xyz));
    reg_tmp12 = vec4(rsq_s(reg_tmp12.x));
    reg_tmp0 = vec4(rsq_s(reg_tmp0.x));
    vs_out_attr4 = -reg_tmp9;
    reg_tmp7 = mul_s(reg_tmp7, reg_tmp12);
    reg_tmp11.w = (uniforms.f[93].xxxx).w;
    reg_tmp0 = mul_s(reg_tmp9, reg_tmp0);
    reg_tmp11.x = dot_3(uniforms.f[4].xyz, reg_tmp7.xyz);
    reg_tmp11.y = dot_3(uniforms.f[5].xyz, reg_tmp7.xyz);
    reg_tmp11.z = dot_3(uniforms.f[6].xyz, reg_tmp7.xyz);
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp9);
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp9);
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp9);
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp9);
    reg_tmp0 = vec4(dot_3(reg_tmp0.xyz, reg_tmp11.xyz));
    reg_tmp14 = uniforms.f[93].yyyy + reg_tmp11.zzzz;
    reg_tmp15 = mul_s(uniforms.f[95].zzzz, reg_tmp11);
    conditional_code = equal(-uniforms.f[93].yy, reg_tmp11.zz);
    reg_tmp14 = mul_s(uniforms.f[95].zzzz, reg_tmp14);
    reg_tmp0 = abs(reg_tmp0);
    reg_tmp14 = vec4(rsq_s(reg_tmp14.x));
    reg_tmp0.w = (mul_s(uniforms.f[82].wwww, reg_tmp0.wwww)).w;
    if (!conditional_code.x) {
        sub_357_359();
    } else {
        sub_359_360();
    }
    reg_tmp0.w = (min(uniforms.f[93].yyyy, reg_tmp0.wwww)).w;
    vs_out_attr1.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp0.wwww).w;
    reg_tmp0.w = (mul_s(uniforms.f[83].wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_357_359() {
    vs_out_attr1.z = rcp_s(reg_tmp14.x);
    vs_out_attr1.xy = (mul_s(reg_tmp15, reg_tmp14)).xy;
    return false;
}
bool sub_359_360() {
    vs_out_attr1.xyz = (uniforms.f[93].yxxx).xyz;
    return false;
}
bool sub_392_400() {
    reg_tmp0 = uniforms.f[13];
    reg_tmp12.xy = (fma_s(vs_in_reg3.wwww, uniforms.f[12].xyyy, reg_tmp0.xyyy)).xy;
    reg_tmp12.x = (max(uniforms.f[94].wwww, reg_tmp12.xxxx)).x;
    reg_tmp12.x = log2(reg_tmp12.x);
    reg_tmp12.x = (fma_s(reg_tmp12.xxxx, uniforms.f[12].zzzz, reg_tmp0.zzzz)).x;
    reg_tmp12.xy = (max(uniforms.f[93].xxxx, reg_tmp12.xyyy)).xy;
    reg_tmp12.y = (min(uniforms.f[93].yyyy, reg_tmp12.yyyy)).y;
    reg_tmp8.z = (fma_s(reg_tmp12.xxxx, reg_tmp12.yyyy, reg_tmp8.zzzz)).z;
    return false;
}
// reference: 90EDEE87E38BF42B, 559C5391498D90D5
// shader: 8B30, 3B6A7C8DFC06D15B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA79808D850C, 3B6A7C8DFC06D15B
// program: 559C5391498D90D5, AEA07E6271EAC2AC, 3B6A7C8DFC06D15B
// shader: 8B30, A742A131A2C1C94A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (const_color[4].a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E11FB89EB634CD24, A742A131A2C1C94A
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, A742A131A2C1C94A
// shader: 8B30, 1F52220E361BD1F6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA79AABF3B50, 1F52220E361BD1F6
// program: 559C5391498D90D5, AEA07E6271EAC2AC, 1F52220E361BD1F6
// shader: 8B30, 3C6BC7F4786359F1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.r) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor2.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A83DC7FA6F5C0414, 3C6BC7F4786359F1
// program: EF7C518C09192E40, AEA07E6271EAC2AC, 3C6BC7F4786359F1
// shader: 8B30, F8DCCC9C5ED1A2DA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(min((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(1.0)) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((last_tex_env_out.a) + (last_tex_env_out.a), 1.0) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((const_color[4].rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D99EFA32F235B561, F8DCCC9C5ED1A2DA
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, F8DCCC9C5ED1A2DA
// shader: 8B30, A6F7559751DACDCC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 1.0, alpha_output_4 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FB6475BFFD41263D, A6F7559751DACDCC
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, A6F7559751DACDCC
// shader: 8B30, 39825CF790A0F230

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F0035C3B497554B1, 39825CF790A0F230
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 39825CF790A0F230
// shader: 8B30, 22E867A9AC800AFA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 922CCCAC66B09A9D, 22E867A9AC800AFA
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 22E867A9AC800AFA
// shader: 8B30, D008DB2AF2ACFE45

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A382C82A39F55E54, D008DB2AF2ACFE45
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, D008DB2AF2ACFE45
// shader: 8B30, ED6E40AE4D38F2E9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 1.0, alpha_output_4 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A8E5E1AE6176C7DB, ED6E40AE4D38F2E9
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, ED6E40AE4D38F2E9
// shader: 8B30, EFF998405296A3AF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A7F51560F00D8FE9, EFF998405296A3AF
// program: B8666980F2837050, AEA07E6271EAC2AC, EFF998405296A3AF
// shader: 8B30, 8015854F968FC5EC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (const_color[4].a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E11FB89E18E43F08, 8015854F968FC5EC
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, 8015854F968FC5EC
// shader: 8B30, AD4CA6492116C0EE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 91CA33AE38EEFB94, AD4CA6492116C0EE
// program: 7C3FFF32EC4540E3, AEA07E6271EAC2AC, AD4CA6492116C0EE
// shader: 8B30, AD40FDE1AAD75463

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A7F51560AABF3B50, AD40FDE1AAD75463
// program: B8666980F2837050, AEA07E6271EAC2AC, AD40FDE1AAD75463
// shader: 8B30, 819B599DDBD91D08

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(min((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(1.0)) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((last_tex_env_out.a) + (last_tex_env_out.a), 1.0) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((const_color[4].rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D99EFA325CE5474D, 819B599DDBD91D08
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, 819B599DDBD91D08
// shader: 8B30, 5FB2D1A86EAB5FD7

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA79A98B29CC, 5FB2D1A86EAB5FD7
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 5FB2D1A86EAB5FD7
// shader: 8B30, 61E05CB2F2BDA909

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA79453CC2CF, 61E05CB2F2BDA909
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 61E05CB2F2BDA909
// shader: 8B30, 7550CA7FFC84893D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.r) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor2.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A83DC7FAC18CF638, 7550CA7FFC84893D
// program: EF7C518C09192E40, AEA07E6271EAC2AC, 7550CA7FFC84893D
// shader: 8B30, 62FF6CD707413AC7

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5F95D310FDA77672, 62FF6CD707413AC7
// program: 6A898B3A503366C0, AEA07E6271EAC2AC, 62FF6CD707413AC7
// shader: 8B30, AF6C750232F26332

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(min((primary_fragment_color.rgb) + (texcolor1.rgb), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3F7A31619B9B0203, AF6C750232F26332
// program: 69421A64BED706FA, AEA07E6271EAC2AC, AF6C750232F26332
// shader: 8B30, 804182748570079A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA79AF667FC0, 804182748570079A
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 804182748570079A
// shader: 8B30, 57DB435C09739630

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DB0BA7943D194C3, 57DB435C09739630
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 57DB435C09739630
// shader: 8B30, 8DA9DAA47CEA4A79

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb) + (const_color[3].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[4].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = (combiner_buffer.rgb);
float alpha_output_5 = byteround(clamp((last_tex_env_out.r) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 76CEBC757D725B0C, 8DA9DAA47CEA4A79
// program: 6A898B3A503366C0, AEA07E6271EAC2AC, 8DA9DAA47CEA4A79
// shader: 8B30, 768AB6AA8E956A0D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C1AD58BD3AEF7828, 768AB6AA8E956A0D
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 768AB6AA8E956A0D
// shader: 8B30, CD1D730A714EDBBD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C1AD58BD3C022E24, CD1D730A714EDBBD
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, CD1D730A714EDBBD
// shader: 8B30, ABAD1008212BB433

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(min((primary_fragment_color.rgb) + (texcolor1.rgb), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3F7A31619D76540F, ABAD1008212BB433
// program: 69421A64BED706FA, AEA07E6271EAC2AC, ABAD1008212BB433
// shader: 8B30, 99D571C1A266522A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = (lut_scale_rg * LookupLightingLUTUnsigned(5, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.b = (lut_scale_rb * LookupLightingLUTUnsigned(4, max(dot(normal, normalize(half_vector)), 0.0)));
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) + (primary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (secondary_fragment_color.a);
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb) + (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3 * 4.0, alpha_output_3 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor1.g), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6820C9DD8578BEBF, 99D571C1A266522A
// program: 85E4C1AF77F83609, AEA07E6271EAC2AC, 99D571C1A266522A
// shader: 8B30, 29CF780C8351ACAA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A7F5156096E27124, 29CF780C8351ACAA
// program: B8666980F2837050, AEA07E6271EAC2AC, 29CF780C8351ACAA
// shader: 8B30, EC9D516649580241

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 43BA948969E32A9F, EC9D516649580241
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, EC9D516649580241
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 886326305217700F
// shader: 8B30, F3AB5FC7A2868715

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 87752AE8025AE980, F3AB5FC7A2868715
// program: C5779815375CB1F0, AEA07E6271EAC2AC, F3AB5FC7A2868715
// shader: 8B30, DDFF22F492622A9D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F47481719B38DD3C, DDFF22F492622A9D
// program: B8666980F2837050, AEA07E6271EAC2AC, DDFF22F492622A9D
// shader: 8B30, 97D67BDC5F1173A0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0A45E4E6E204EA77, 97D67BDC5F1173A0
// program: 467A1A42436F227B, AEA07E6271EAC2AC, 97D67BDC5F1173A0
// shader: 8B30, 3FAC8075566D5238

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B6933CA0404727E7, 3FAC8075566D5238
// program: D86A087FD303196A, AEA07E6271EAC2AC, 3FAC8075566D5238
// shader: 8B30, 57DB435CE65D2743

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 43BA948943D194C3, 57DB435CE65D2743
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 57DB435CE65D2743
// shader: 8B30, 484949075FC2A569

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4D96F2E48B25128A, 484949075FC2A569
// program: 7C3FFF32EC4540E3, AEA07E6271EAC2AC, 484949075FC2A569
// shader: 8B30, CF9B0DCBB5DFD435

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (const_color[4].a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3D4379D4AB2FD616, CF9B0DCBB5DFD435
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, CF9B0DCBB5DFD435
// shader: 8B30, 0BCA31F7A394D907

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp(min((texcolor2.rgb) + (last_tex_env_out.aaa), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor2.a) + (last_tex_env_out.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (texcolor1.r);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 82AC14A3D950509C, 0BCA31F7A394D907
// program: 7C3FFF32EC4540E3, AEA07E6271EAC2AC, 0BCA31F7A394D907
// shader: 8B30, C5CA0B21BCBCFA88

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(min((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(1.0)) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((last_tex_env_out.a) + (last_tex_env_out.a), 1.0) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((const_color[4].rrr) * (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 05C23B78EF2EAE53, C5CA0B21BCBCFA88
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, C5CA0B21BCBCFA88
// shader: 8B30, ECD6CFD034AEDD9A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-view - light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(12, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(13, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.aaa) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.r) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (last_tex_env_out.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor2.rgb) * (texcolor1.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A958C6734C2056CD, ECD6CFD034AEDD9A
// program: EF7C518C09192E40, AEA07E6271EAC2AC, ECD6CFD034AEDD9A
// reference: 90EDEE870403E62E, 740C53E4FCBE97EC
// program: 740C53E4FCBE97EC, AEA07E6271EAC2AC, 6932857FE200E2E2
// reference: 90EDEE873D16D094, DF4B86DFCB80860C
// reference: 90EDEE87993EE21D, E976850DD5B08ED7
// program: 9E0C4EDBA04AF31D, AEA07E6271EAC2AC, 8AAF0E186384CAC2
// program: 19DE2B390CB8E9EA, AEA07E6271EAC2AC, 49173472DE69F89A
// program: 9E0C4EDBA04AF31D, AEA07E6271EAC2AC, E12E9921D8EC0CE3
// program: D86A087FD303196A, AEA07E6271EAC2AC, 527E2F2AF7039DB8
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, B9C756CCE3FCCF16
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, 60311184EC7109ED
// program: D86A087FD303196A, AEA07E6271EAC2AC, 64E1DC17EA49441D
// program: 9E0C4EDBA04AF31D, AEA07E6271EAC2AC, B1626B699E58B5F0
// program: 19DE2B390CB8E9EA, AEA07E6271EAC2AC, 8CAA876AE60FD30F
// program: 9E0C4EDBA04AF31D, AEA07E6271EAC2AC, AC83E2F1C73BBA81
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 015E75540DD34BB2
// program: 9E0C4EDBA04AF31D, AEA07E6271EAC2AC, 84515DBB5C82728B
// program: 19DE2B390CB8E9EA, AEA07E6271EAC2AC, 361C75374F85FE92
// program: 9E0C4EDBA04AF31D, AEA07E6271EAC2AC, 5CE60634BC9AF45F
// program: D86A087FD303196A, AEA07E6271EAC2AC, 15DF5B6C0C94493A
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 64E1DC17EA49441D
// program: B8666980F2837050, AEA07E6271EAC2AC, 967BCBD707EB39AB
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, AF531333720F27FF
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 161AEED51CE5526F
// program: B8666980F2837050, AEA07E6271EAC2AC, ADBFF0B5DEDA0A6E
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 9EEF351F2F3BAB51
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, D38BE52DD60D9D39
// program: D86A087FD303196A, AEA07E6271EAC2AC, 1FCF973F9EC8F39C
// program: D86A087FD303196A, AEA07E6271EAC2AC, 5A1DE251FBA01FAF
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, 8E0C20574D0ED30B
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, 87F2F3D16DF4686F
// program: D86A087FD303196A, AEA07E6271EAC2AC, 161AEED51CE5526F
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, 47EB3C74B1768AEE
// program: 85E4C1AF77F83609, AEA07E6271EAC2AC, E6D17D4779455D55
// program: C5779815375CB1F0, AEA07E6271EAC2AC, 4CB0E57D646B56C0
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 96475741C80C557D
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 41F146754BD6ADC3
// program: D86A087FD303196A, AEA07E6271EAC2AC, 48243F9FC9FB0C30
// program: D86A087FD303196A, AEA07E6271EAC2AC, DB052B801EF3D62D
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, 72296B545D54609E
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, DF18A815D6776034
// program: D86A087FD303196A, AEA07E6271EAC2AC, 41F146754BD6ADC3
// program: 7C3FFF32EC4540E3, AEA07E6271EAC2AC, F4DF8C7470D9FAC0
// program: 7C3FFF32EC4540E3, AEA07E6271EAC2AC, 85F8389F31E3F3EE
// program: 7C3FFF32EC4540E3, AEA07E6271EAC2AC, B75CF484D7B7F73B
// program: 7B583060472E2AEA, AEA07E6271EAC2AC, 2B6A9BCAB67878E3
// program: 6A898B3A503366C0, AEA07E6271EAC2AC, ADB33C6CE857EDA4
// program: 69421A64BED706FA, AEA07E6271EAC2AC, 95A2B5ED015766FE
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, 49BA253CC09B6D18
// program: 7C3FFF32EC4540E3, AEA07E6271EAC2AC, 7F9334D5BB0C4688
// program: D86A087FD303196A, AEA07E6271EAC2AC, 88F0F2F10D24AAFC
// program: EF7C518C09192E40, AEA07E6271EAC2AC, 3C412B5D382307A6
// program: EF7C518C09192E40, AEA07E6271EAC2AC, 92901863CFE92C8F
// reference: 90EDEE87E34D63E2, 409E719D94562862
// program: 409E719D94562862, AEA07E6271EAC2AC, 07AB54532856B481
// program: E976850DD5B08ED7, AEA07E6271EAC2AC, 376A345B910A4BD3
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, AD202664F10B6535
// program: 740C53E4FCBE97EC, AEA07E6271EAC2AC, C434504F88EE1D9D
// program: 19DE2B390CB8E9EA, AEA07E6271EAC2AC, 101AADE8E6105F95
// program: 9E0C4EDBA04AF31D, AEA07E6271EAC2AC, B870C06331B214D2
// program: 467A1A42436F227B, AEA07E6271EAC2AC, C306097EDA73D7D0
// program: 559C5391498D90D5, AEA07E6271EAC2AC, 3B6A7C8DFC06D15B
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, A742A131A2C1C94A
// program: 559C5391498D90D5, AEA07E6271EAC2AC, 1F52220E361BD1F6
// program: EF7C518C09192E40, AEA07E6271EAC2AC, 3C6BC7F4786359F1
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, F8DCCC9C5ED1A2DA
// program: 69421A64BED706FA, AEA07E6271EAC2AC, AF6C750232F26332
// shader: 8B30, 3D2DBA80E99B20CE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp(min((texcolor2.rgb) + (last_tex_env_out.aaa), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor2.a) + (last_tex_env_out.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((primary_fragment_color.a) * (combiner_buffer.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((secondary_fragment_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (texcolor1.r);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B1FC8FA428B9B766, 3D2DBA80E99B20CE
// program: 7C3FFF32EC4540E3, AEA07E6271EAC2AC, 3D2DBA80E99B20CE
// shader: 8B30, E7A809F15DC64DEA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[4].position + view);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(20, clamp(light_src[4].dist_atten_scale * length(-view - light_src[4].position) + light_src[4].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[5].position + view);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(21, clamp(light_src[5].dist_atten_scale * length(-view - light_src[5].position) + light_src[5].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[6].position + view);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(22, clamp(light_src[6].dist_atten_scale * length(-view - light_src[6].position) + light_src[6].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(14, max(dot(light_vector, spot_dir), 0.0)));
light_vector = normalize(light_src[7].position + view);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(half_vector)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(23, clamp(light_src[7].dist_atten_scale * length(-view - light_src[7].position) + light_src[7].dist_atten_bias, 0.0, 1.0)) * (lut_scale_sp * LookupLightingLUTUnsigned(15, max(dot(light_vector, spot_dir), 0.0)));
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp(min((primary_fragment_color.rgb) + (texcolor1.rgb), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D0766B2C5D5B4097, E7A809F15DC64DEA
// program: 69421A64BED706FA, AEA07E6271EAC2AC, E7A809F15DC64DEA
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 804182748570079A
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 57DB435C09739630
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, A6F7559751DACDCC
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 39825CF790A0F230
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 22E867A9AC800AFA
// shader: 8B30, B54F6B1D38F1B68F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((last_tex_env_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A382C82A13C7E008, B54F6B1D38F1B68F
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, B54F6B1D38F1B68F
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, ED6E40AE4D38F2E9
// program: B8666980F2837050, AEA07E6271EAC2AC, EFF998405296A3AF
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, 8015854F968FC5EC
// program: 7C3FFF32EC4540E3, AEA07E6271EAC2AC, AD4CA6492116C0EE
// program: B8666980F2837050, AEA07E6271EAC2AC, AD40FDE1AAD75463
// program: A62C212E4E3A0D30, AEA07E6271EAC2AC, 819B599DDBD91D08
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 5FB2D1A86EAB5FD7
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 61E05CB2F2BDA909
// program: EF7C518C09192E40, AEA07E6271EAC2AC, 7550CA7FFC84893D
// program: 6A898B3A503366C0, AEA07E6271EAC2AC, 62FF6CD707413AC7
// program: 6A898B3A503366C0, AEA07E6271EAC2AC, 8DA9DAA47CEA4A79
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, 768AB6AA8E956A0D
// program: 494C9A653BABAB04, AEA07E6271EAC2AC, CD1D730A714EDBBD
// program: 69421A64BED706FA, AEA07E6271EAC2AC, ABAD1008212BB433
