// On the PICA200, "infinity * 0 = 0" but in OpenGL "infinity * 0 = NaN". (infinity = 1.0 / 0.0)

// Pokemon x: mul_s, dot_3, rsq_s
// The Legend of Zelda: Ocarina of Time: mul_s
// Luigi's Mansion: Dark Moon: mul_s, fma_s, rcp_s

[accurate_mul_off]
#define mul_s(x, y) (x * y)
#define mul_3(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0f / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

[accurate_mul_fast]
#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) (x * y)
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

[accurate_mul_safe]
#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}
float rsq_s(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

[accurate_mul_slow]
#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}
float rsq_s(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}
#define dot_s(x, y) dot(mul_s(x, y), vec4(1.0))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))
